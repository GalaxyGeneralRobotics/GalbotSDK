{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Galbot SDK","text":"<p>\u672c\u6587\u6863\u8be6\u7ec6\u4ecb\u7ecd\u4e86 galbot_sdk\uff0c\u5305\u62ec\u5e93\u7684\u5b89\u88c5\u6559\u7a0b\u3001\u4f7f\u7528\u793a\u4f8b\u4ee5\u53ca Python \u548c C++ API \u53c2\u8003\u3002</p>"},{"location":"#_1","title":"\u5feb\u901f\u5f00\u59cb","text":"<p>\u5982\u679c\u4f60\u5e0c\u671b\u5feb\u901f\u4e0a\u624b\uff0c\u8bf7\u53c2\u8003 \u5b89\u88c5\u4e0e\u914d\u7f6e \u548c \u5165\u95e8\u6559\u7a0b\uff0c\u83b7\u53d6\u53ef\u76f4\u63a5\u8fd0\u884c\u7684\u4f7f\u7528\u6307\u5357\u3002</p>"},{"location":"#_2","title":"\u6587\u6863\u7ae0\u8282","text":"<ul> <li>\u6982\u89c8</li> </ul> <p>\u5feb\u901f\u4e86\u89e3 SDK \u603b\u4f53\u5185\u5bb9\uff0c\u638c\u63e1\u6574\u4f53\u6846\u67b6\u3002</p> <ul> <li>\u5b89\u88c5\u4e0e\u914d\u7f6e</li> </ul> <p>\u6309\u7167\u672c\u6307\u5357\u5b8c\u6210 galbot_sdk \u7684\u5b89\u88c5\u548c\u73af\u5883\u914d\u7f6e\u3002</p> <ul> <li>\u5165\u95e8\u6559\u7a0b</li> </ul> <p>\u901a\u8fc7\u591a\u4e2a\u793a\u4f8b\u5feb\u901f\u4f53\u9a8c\u673a\u5668\u4eba\u7684\u57fa\u7840\u63a7\u5236\u3001\u624b\u81c2\u64cd\u63a7\u3001\u5bfc\u822a\u3001\u4f20\u611f\u5668\u6570\u636e\u91c7\u96c6\u7b49\u529f\u80fd\u3002</p> <ul> <li>Python \u793a\u4f8b</li> </ul> <p>\u63d0\u4f9b Python \u793a\u4f8b\uff0c\u65b9\u4fbf\u53c2\u8003\u548c\u5feb\u901f\u96c6\u6210\u3002</p> <ul> <li>C++ \u793a\u4f8b</li> </ul> <p>\u63d0\u4f9b C++ \u793a\u4f8b\uff0c\u65b9\u4fbf\u53c2\u8003\u548c\u5feb\u901f\u96c6\u6210\u3002</p> <ul> <li>Python API \u53c2\u8003</li> </ul> <p>\u5b8c\u6574\u7684 Python API \u6587\u6863\uff0c\u6db5\u76d6\u6240\u6709\u53ef\u7528\u51fd\u6570\u3001\u7c7b\u548c\u65b9\u6cd5\u3002</p> <ul> <li>C++ API \u53c2\u8003</li> </ul> <p>\u5b8c\u6574\u7684 C++ API \u6587\u6863\uff0c\u6db5\u76d6\u6240\u6709\u53ef\u7528\u51fd\u6570\u3001\u7c7b\u548c\u65b9\u6cd5\u3002</p> <ul> <li>\u6545\u969c\u6392\u9664</li> </ul> <p>\u63d0\u4f9b\u5e38\u89c1\u95ee\u9898\u7684\u89e3\u51b3\u65b9\u6848\u4ee5\u53ca\u6700\u4f73\u5b9e\u8df5\u5efa\u8bae\u3002</p> <ul> <li>\u8bb8\u53ef\u8bc1</li> </ul> <p>\u8f6f\u4ef6\u8bb8\u53ef\u6761\u6b3e\u4e0e\u76f8\u5173\u4fe1\u606f\u3002</p>"},{"location":"api_cpp_reference/","title":"CPP API Reference","text":""},{"location":"api_cpp_reference/#types-classes-structs-namespaces","title":"Types (Classes, Structs &amp; Namespaces)","text":"<ul> <li>CameraInfo</li> <li>CollisionCheckOption</li> <li>DepthData</li> <li>DeviceInfo</li> <li>EffortInfo</li> <li>Error</li> <li>ErrorInfo</li> <li>ForceData</li> <li>g1</li> <li>GalbotMotion</li> <li>GalbotNavigation</li> <li>GalbotRobot</li> <li>GripperState</li> <li>Header</li> <li>IKSolverConfig</li> <li>ImuData</li> <li>JointCommand</li> <li>JointState</li> <li>JointStateMessage</li> <li>JointStates</li> <li>KinematicsBoundary</li> <li>LidarData</li> <li>LineTrajCheckPrimitive</li> <li>MotionPlanConfig</li> <li>OdomData</li> <li>Parameter</li> <li>PlannerConfig</li> <li>PlanTaskResult</li> <li>Point</li> <li>PointField</li> <li>Pose</li> <li>PoseState</li> <li>Quaternion</li> <li>RegionOfInterest</li> <li>RgbData</li> <li>RobotStates</li> <li>SamplerConfig</li> <li>SuctionCupState</li> <li>Timestamp</li> <li>Trajectory</li> <li>Trajectory</li> <li>TrajectoryFeasibilityCheckOption</li> <li>TrajectoryPlanConfig</li> <li>TrajectoryPoint</li> <li>TransformMessage</li> <li>UltrasonicData</li> <li>Vector3</li> </ul>"},{"location":"api_cpp_reference/#camerainfo-struct","title":"CameraInfo (struct)","text":"<p>Camera calibration information.Complete camera calibration data including intrinsic parameters, distortion coefficients, rectification, and projection matrices. Compatible with ROS 2 sensor_msgs/CameraInfo.</p>"},{"location":"api_cpp_reference/#member-variables","title":"Member Variables","text":"Name Type Description header Header Message header.Contains timestamp and camera coordinate frame ID (e.g., \"camera_optical_frame\"). height uint32_t Image height (pixels)Vertical resolution of images produced by this camera at calibration time. width uint32_t Image width (pixels)Horizontal resolution of images produced by this camera at calibration time. distortion_model std::string Distortion model name.Specifies the lens distortion model used. Common values:\"plumb_bob\": Brown-Conrady model with radial (k1,k2,k3) and tangential (p1,p2) distortion\"rational_polynomial\": Extended model with additional parameters\"equidistant\": Fisheye lens model d std::vector&lt; double &gt; Distortion coefficients (D)Vector of distortion parameters, size and interpretation depend on distortion_model. For \"plumb_bob\": [k1, k2, p1, p2, k3] (5 parameters)k1, k2, k3: Radial distortion coefficientsp1, p2: Tangential distortion coefficients k std::array&lt; double, 9 &gt; Intrinsic camera matrix (K)3\u00d73 matrix in row-major order, maps 3D points in camera frame to 2D pixel coordinates: [fx0cx][0fycy][001]fx, fy: Focal lengths in pixel unitscx, cy: Principal point (optical center) in pixels r std::array&lt; double, 9 &gt; Rectification matrix (R)3\u00d73 rotation matrix in row-major order. For stereo cameras: rotates left/right camera image planes to be coplanar and row-aligned. For monocular cameras: typically identity matrix (no rectification needed). p std::array&lt; double, 12 &gt; Projection matrix (P)3\u00d74 matrix in row-major order, projects 3D points to rectified image coordinates: [fx'0cx'Tx][0fy'cy'Ty][0010]fx', fy': Rectified focal lengthscx', cy': Rectified principal pointTx, Ty: Stereo baseline (Tx = -fx' \u00d7 baseline for right camera) binning_x uint32_t Horizontal binning factor.Number of camera pixels combined horizontally for each output pixel. Values: 0 or 1 = no binning, 2 = 2\u00d71 binning, etc. binning_y uint32_t Vertical binning factor.Number of camera pixels combined vertically for each output pixel. Values: 0 or 1 = no binning, 2 = 1\u00d72 binning, etc. roi RegionOfInterest Region of interest (ROI)Specifies a sub-window within the full sensor resolution. camera_type std::string Camera type identifier.Optional field specifying camera type or model. Examples: \"monocular\", \"stereo_left\", \"stereo_right\", \"depth\" T std::vector&lt; double &gt; Additional transform matrix.Optional transformation matrix for vendor-specific or extended calibration data. Size and interpretation depend on implementation."},{"location":"api_cpp_reference/#collisioncheckoption-struct","title":"CollisionCheckOption (struct)","text":"<p>Collision detection enable/disable configuration.This structure provides fine-grained control over collision checking during motion planning and execution. It supports independent toggling of self-collision detection (robot links colliding with each other) and environment collision detection (robot colliding with obstacles or workspace boundaries).Disabling collision checks improves computational performance but may result in unsafe trajectories. Use with caution in controlled environments.</p>"},{"location":"api_cpp_reference/#set_disable_self_collision_check","title":"set_disable_self_collision_check","text":"<pre><code>void galbot::sdk::g1::CollisionCheckOption::set_disable_self_collision_check(bool disable)\n</code></pre> Item Description Function Enable or disable self-collision detection. Parameters disable: true to disable self-collision checking, false to enable Return None"},{"location":"api_cpp_reference/#set_disable_env_collision_check","title":"set_disable_env_collision_check","text":"<pre><code>void galbot::sdk::g1::CollisionCheckOption::set_disable_env_collision_check(bool disable)\n</code></pre> Item Description Function Enable or disable environment collision detection. Parameters disable: true to disable environment collision checking, false to enable Return None"},{"location":"api_cpp_reference/#get_disable_self_collision_check","title":"get_disable_self_collision_check","text":"<pre><code>bool galbot::sdk::g1::CollisionCheckOption::get_disable_self_collision_check() const\n</code></pre> Item Description Function Check if self-collision detection is disabled. Parameters None Return true if self-collision detection is currently disabled, false if enabled"},{"location":"api_cpp_reference/#get_disable_env_collision_check","title":"get_disable_env_collision_check","text":"<pre><code>bool galbot::sdk::g1::CollisionCheckOption::get_disable_env_collision_check() const\n</code></pre> Item Description Function Check if environment collision detection is disabled. Parameters None Return true if environment collision detection is currently disabled, false if enabled"},{"location":"api_cpp_reference/#print","title":"print","text":"<pre><code>void galbot::sdk::g1::CollisionCheckOption::print() const\n</code></pre> Item Description Function Print collision detection configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#depthdata-struct","title":"DepthData (struct)","text":"<p>Depth image data structure.Contains compressed depth image data from depth cameras or RGB-D sensors. Compatible with ROS 2 sensor_msgs/CompressedImage format with depth extensions.</p>"},{"location":"api_cpp_reference/#convert_to_cv2_mat","title":"convert_to_cv2_mat","text":"<pre><code>std::shared_ptr&lt;cv::Mat&gt; galbot::sdk::g1::DepthData::convert_to_cv2_mat()\n</code></pre> Item Description Function Convert depth data to OpenCV Mat. Parameters None Return std::shared_ptr Smart pointer to decoded depth image on success, nullptr on failure"},{"location":"api_cpp_reference/#member-variables_1","title":"Member Variables","text":"Name Type Description header Header Message header.Contains acquisition timestamp and camera coordinate frame ID. height uint32_t Image height (pixels)Number of rows in the depth image. width uint32_t Image width (pixels)Number of columns in the depth image. format std::string Image format descriptor.Specifies depth encoding and compression format. Example: \"16UC1; compressedDepth png\" (16-bit unsigned, 1 channel, PNG compressed) data std::vector&lt; uint8_t &gt; Depth image data.Binary blob containing raw or compressed depth image data. depth_scale uint32_t Depth scale factor.Quantization factor for converting pixel values to metric depth. True depth (meters) = pixel_value / depth_scale Example: depth_scale = 1000 means pixel values are in millimeters"},{"location":"api_cpp_reference/#deviceinfo-struct","title":"DeviceInfo (struct)","text":"<p>Device information structure.Describes basic information about the robot or module, used for device management, logging, diagnostics, and maintenance tracking.</p>"},{"location":"api_cpp_reference/#member-variables_2","title":"Member Variables","text":"Name Type Description model std::string Device model name or identifier serial_number std::string Unique serial number for device identification firmware_version std::string System firmware version string (e.g., \"1.2.3\") hardware_version std::string Hardware version or revision number manufacturer std::string Manufacturer name or company identifier"},{"location":"api_cpp_reference/#effortinfo-struct","title":"EffortInfo (struct)","text":"<p>6D wrench information (force + torque)Represents a 6-DOF wrench (force and torque) typically measured by a force/torque sensor. Also known as a spatial force or generalized force.</p>"},{"location":"api_cpp_reference/#member-variables_3","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Measurement timestamp (nanoseconds since epoch) force Vector3 Force vector (Newtons): [fx, fy, fz] torque Vector3 Torque vector (Newton-meters): [tx, ty, tz]"},{"location":"api_cpp_reference/#error-struct","title":"Error (struct)","text":"<p>Error information.Describes an error from a single module or component, including error code and human-readable description for debugging and diagnostics.</p>"},{"location":"api_cpp_reference/#error","title":"Error","text":"<pre><code>galbot::sdk::g1::Error::Error(std::string commpent_input, int error_code_input, std::string description_input)\n</code></pre> Item Description Function Constructor. Parameters commpent_input: Fault module or component nameerror_code_input: Numerical error codedescription_input: Human-readable error description Return None"},{"location":"api_cpp_reference/#member-variables_4","title":"Member Variables","text":"Name Type Description commpent std::string Fault module or component name (note: field name contains typo but preserved for API compatibility) error_code uint64_t Numerical error code for programmatic error handling description std::string Human-readable error description"},{"location":"api_cpp_reference/#errorinfo-struct","title":"ErrorInfo (struct)","text":"<p>Error information collection.Contains a timestamped collection of error messages from multiple modules or components.</p>"},{"location":"api_cpp_reference/#member-variables_5","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Timestamp when errors were collected (nanoseconds since epoch) error_vec std::vector&lt; Error &gt; Vector of error messages from various system components"},{"location":"api_cpp_reference/#forcedata-struct","title":"ForceData (struct)","text":"<p>Force sensor data.Contains timestamped force and torque measurements from a 6-axis force/torque sensor, typically mounted at robot wrists or tool interfaces.</p>"},{"location":"api_cpp_reference/#member-variables_6","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Measurement timestamp (nanoseconds since epoch) force Vector3 Force vector (Newtons): [fx, fy, fz] torque Vector3 Torque vector (Newton-meters): [tx, ty, tz]"},{"location":"api_cpp_reference/#g1-namespace","title":"g1 (namespace)","text":"<p>Namespace for Galbot G1 humanoid robot.</p>"},{"location":"api_cpp_reference/#member-variables_7","title":"Member Variables","text":"Name Type Description g_actuate_type_map std::unordered_map&lt; std::string, ActuateType &gt; Whole-body planning actuation type mapping table.This static map provides a string-to-enum conversion for ActuateType enumeration values, enabling actuation type selection from configuration files or function parameters:\"with_chain_only\" -&gt; ACTUATE_WITH_CHAIN_ONLY : Execute kinematic chain actions only (arms only)\"with_torso\" -&gt; ACTUATE_WITH_TORSO : Include torso joint actuation\"with_leg\" -&gt; ACTUATE_WITH_LEG : Include leg joint actuation\"type_num\" -&gt; ACTUATE_TYPE_NUM : Total number of actuation types (for iteration)This map is used for runtime string-based actuation type resolution.ActuateType status_string_map_ std::unordered_map&lt; MotionStatus, std::string &gt; MotionStatus enumeration to human-readable string mapping table.This static map converts MotionStatus enumeration values to descriptive strings for logging, debugging, and user interface display purposes.Status mappings:MotionStatus::SUCCESS -&gt; \"SUCCESS: Execution succeeded\"MotionStatus::TIMEOUT -&gt; \"TIMEOUT: Execution timeout\"MotionStatus::FAULT -&gt; \"FAULT: Fault occurred, unable to continue execution\"MotionStatus::INVALID_INPUT -&gt; \"INVALID_INPUT: Input parameters do not meet requirements\"MotionStatus::INIT_FAILED -&gt; \"INIT_FAILED: Internal communication component creation failed\"MotionStatus::IN_PROGRESS -&gt; \"IN_PROGRESS: In motion but target not yet reached\"MotionStatus::STOPPED_UNREACHED -&gt; \"STOPPED_UNREACHED: Motion stopped before reaching target\"MotionStatus::DATA_FETCH_FAILED -&gt; \"DATA_FETCH_FAILED: Failed to retrieve required data\"MotionStatus::PUBLISH_FAIL -&gt; \"PUBLISH_FAIL: Failed to transmit command/data\"MotionStatus::COMM_DISCONNECTED -&gt; \"COMM_DISCONNECTED: Communication link disconnected\"MotionStatus::STATUS_NUM -&gt; \"STATUS_NUM: Total number of status enumerations\"MotionStatus::UNSUPPORTED_FUNCRION -&gt; \"UNSUPPORTED_FUNCRION: Function not supported yet\"The map is primarily used by status_to_string() method.MotionStatusstatus_to_string() default_param std::shared_ptr&lt; Parameter &gt; Default parameter object for motion planning.Provides a shared default Parameter instance with standard configuration values. Can be used when custom parameters are not required.Parameter"},{"location":"api_cpp_reference/#enums","title":"Enums","text":""},{"location":"api_cpp_reference/#navigationstatus-enum","title":"NavigationStatus","text":"<p>Navigation task execution status enumeration.Defines the possible outcomes when executing navigation commands such as moving to a goal position or following a path.</p> Enum Value Description SUCCESS Execution succeeded, navigation task completed as expected FAIL Execution failed due to unspecified error TIMEOUT Execution timeout, task did not complete within allowed time INVALID_INPUT Input parameters do not meet requirements or are out of valid range MODE_ERR Current mode does not support this operation COMM_ERR Communication error occurred during execution WAIT_INITIALIZED Waiting for system initialization, navigation system not ready"},{"location":"api_cpp_reference/#controlstatus-enum","title":"ControlStatus","text":"<p>Control command execution status enumeration.Represents the execution status of robot control commands, including joint control, end-effector control, and other motion control operations.</p> Enum Value Description SUCCESS Execution succeeded, command completed with valid result TIMEOUT Execution timeout, task not completed within specified time limit FAULT Fault occurred, system detected anomaly and aborted execution INVALID_INPUT Input parameters invalid or not meeting interface requirements INIT_FAILED Initialization failed, internal communication or dependent component creation failed IN_PROGRESS Command is executing but has not reached target state STOPPED_UNREACHED Stopped during execution without reaching target position or state DATA_FETCH_FAILED Data retrieval failed during operation, unable to read required state PUBLISH_FAIL Control or state data publication failed, command may not be transmitted COMM_DISCONNECTED Communication connection lost, cannot continue execution STATUS_NUM Total number of status enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#sensorstatus-enum","title":"SensorStatus","text":"<p>Sensor execution status enumeration.Represents the status of sensor data acquisition and processing operations, applicable to cameras, lidar, IMU, force sensors, and other sensor types.</p> Enum Value Description SUCCESS Execution succeeded, sensor data valid and operation completed TIMEOUT Execution timeout, data acquisition or operation not completed within specified time limit FAULT Fault occurred, sensor detected anomaly and cannot continue normal operation INVALID_INPUT Input parameters invalid or not meeting interface requirements INIT_FAILED Initialization failed, internal communication or dependent component creation failed IN_PROGRESS Operation in progress but not yet completed STOPPED_UNREACHED Stopped during execution without completing expected operation DATA_FETCH_FAILED Data acquisition or reading failed, sensor may be disconnected or malfunctioning PUBLISH_FAIL Data transmission or reporting failed, unable to publish sensor data COMM_DISCONNECTED Sensor communication connection lost, no data available STATUS_NUM Total number of status enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#motionstatus-enum","title":"MotionStatus","text":"<p>Robot motion execution status enumeration.Represents the execution status of robot motion commands, including trajectory following, pose reaching, and other motion planning operations.</p> Enum Value Description SUCCESS Execution succeeded, motion reached expected target position/pose TIMEOUT Execution timeout, motion not completed within specified time limit FAULT Fault occurred, motion cannot continue due to hardware or safety issue INVALID_INPUT Input parameters invalid or not meeting interface requirements INIT_FAILED Internal initialization failed, communication component or resource creation failed IN_PROGRESS Motion in progress but has not reached target yet STOPPED_UNREACHED Stopped during motion without reaching target position/pose DATA_FETCH_FAILED Data retrieval failed, e.g., sensor or state reading failure PUBLISH_FAIL Data transmission or command delivery failed, motion command may not be executed COMM_DISCONNECTED Communication disconnected or control node unavailable STATUS_NUM Total number of status enumerations (for boundary checking or array sizing) UNSUPPORTED_FUNCRION Function not yet supported, called interface or operation not implemented (note: typo in enum name preserved for API compatibility)"},{"location":"api_cpp_reference/#trajectorycontrolstatus-enum","title":"TrajectoryControlStatus","text":"<p>Robot trajectory execution status enumeration.Represents the real-time execution status when the robot follows a pre-planned trajectory consisting of multiple waypoints.</p> Enum Value Description INVALID_INPUT Input parameters do not meet requirements, trajectory cannot be executed RUNNING Trajectory is currently executing, not yet completed COMPLETED Trajectory execution completed successfully, reached final target point STOPPED_UNREACHED Stopped during trajectory execution without reaching endpoint ERROR Error occurred, trajectory execution cannot continue DATA_FETCH_FAILED Execution data retrieval failed, e.g., joint state or sensor feedback unavailable STATUS_NUM Total number of status enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#jointgroup-enum","title":"JointGroup","text":"<p>Joint group enumeration describing different functional modules of the robot.Groups robot joints into functional units for coordinated control and motion planning. Each group typically represents a kinematic chain or end-effector subsystem.</p> Enum Value Description HEAD Head joint group, typically for pan-tilt or vision orientation LEFT_ARM Left arm joint group, multi-DOF manipulator chain RIGHT_ARM Right arm joint group, multi-DOF manipulator chain LEG Leg joint group, for humanoid or legged robots CHASSIS Chassis joint group, mobile base or lower platform LEFT_GRIPPER Left gripper joint group, typically 1-2 DOF parallel jaw gripper RIGHT_GRIPPER Right gripper joint group, typically 1-2 DOF parallel jaw gripper LEFT_SUCTION_CUP Left suction cup joint group, vacuum-based end-effector RIGHT_SUCTION_CUP Right suction cup joint group, vacuum-based end-effector JOINT_GROUP_NUM Total number of joint group enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#sensortype-enum","title":"SensorType","text":"<p>Sensor type enumeration describing various sensors on the robot.Identifies different sensor types available on the robot for perception, localization, and manipulation tasks.</p> Enum Value Description HEAD_LEFT_CAMERA Head left camera, typically RGB camera for stereo vision HEAD_RIGHT_CAMERA Head right camera, typically RGB camera for stereo vision LEFT_ARM_CAMERA Left arm camera, mounted on left manipulator for visual servoing RIGHT_ARM_CAMERA Right arm camera, mounted on right manipulator for visual servoing LEFT_ARM_DEPTH_CAMERA Left arm depth camera, provides RGB-D data for left arm workspace RIGHT_ARM_DEPTH_CAMERA Right arm depth camera, provides RGB-D data for right arm workspace BASE_LIDAR Base lidar, laser scanner for 2D/3D environment mapping and obstacle detection TORSO_IMU Torso IMU (Inertial Measurement Unit), measures acceleration and angular velocity BASE_ULTRASONIC Base ultrasonic sensor array, for proximity detection and collision avoidance SENSOR_NUM Total number of sensor enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#ultrasonictype-enum","title":"UltrasonicType","text":"<p>Chassis ultrasonic sensor probe enumeration (8 directions)Identifies individual ultrasonic sensors arranged around the mobile base chassis for omnidirectional obstacle detection and proximity sensing.</p> Enum Value Description FRONT_LEFT Front left ultrasonic sensor FRONT_RIGHT Front right ultrasonic sensor RIGHT_LEFT Right side front ultrasonic sensor RIGHT_RIGHT Right side rear ultrasonic sensor BACK_LEFT Back left ultrasonic sensor BACK_RIGHT Back right ultrasonic sensor LEFT_LEFT Left side front ultrasonic sensor LEFT_RIGHT Left side rear ultrasonic sensor ULTRASONIC_NUM Total number of ultrasonic sensors (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#galbotonefoxtrotsensor-enum","title":"GalbotOneFoxtrotSensor","text":"<p>Force sensor enumeration describing robot wrist force sensors.Identifies force/torque sensors mounted at the robot's wrist joints for force-controlled manipulation and contact detection.</p> Enum Value Description LEFT_WRIST_FORCE Left wrist force/torque sensor, typically 6-axis (3 forces + 3 torques) RIGHT_WRIST_FORCE Right wrist force/torque sensor, typically 6-axis (3 forces + 3 torques) FORCE_NUM Total number of force sensor enumerations (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#chaintype-enum","title":"ChainType","text":"<p>Robot kinematic chain type enumeration.Identifies different kinematic chains in the robot structure for forward/inverse kinematics calculations and motion planning.</p> Enum Value Description HEAD Head kinematic chain, from base/torso to head end-effector LEFT_ARM Left arm kinematic chain, from base/torso to left end-effector RIGHT_ARM Right arm kinematic chain, from base/torso to right end-effector LEG Leg kinematic chain, for legged locomotion TORSO Torso kinematic chain, connects base to upper body CHAIN_NUM Total number of kinematic chains (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#actuatetype-enum","title":"ActuateType","text":"<p>Actuation type enumeration.Specifies which kinematic chains should be actuated during motion planning and execution. This controls whether the robot uses only the target arm, or also involves torso or leg motion.</p> Enum Value Description ACTUATE_WITH_CHAIN_ONLY Actuate only the target joint chain (e.g., arm only), base remains fixed ACTUATE_WITH_TORSO Actuate target joint chain and torso for extended workspace ACTUATE_WITH_LEG Actuate target joint chain and legs for mobile manipulation ACTUATE_TYPE_NUM Total number of actuation types (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#seedtype-enum","title":"SeedType","text":"<p>IK solver seed type enumeration.Specifies the initialization strategy for inverse kinematics (IK) solvers. Different seed types affect convergence speed and solution quality.</p> Enum Value Description RANDOM_SEED Random seed, generates random initial joint configurations RANDOM_PROGRESSIVE_SEED Random progressive seed, tries multiple random seeds iteratively (recommended for robustness) USER_DEFINED_SEED User-defined seed, uses explicitly provided initial joint configuration SEED_TYPE_NUM Total number of seed types (for boundary checking or array sizing)"},{"location":"api_cpp_reference/#referenceframe-enum","title":"ReferenceFrame","text":"<p>Reference frame enumeration.Specifies the coordinate frame in which poses, positions, or trajectories are expressed. Note: This is a plain enum (not enum class) for C-style compatibility.</p> Enum Value Description FRAME_WORLD World/global coordinate frame, fixed reference frame FRAME_BASE Robot base coordinate frame, attached to mobile base"},{"location":"api_cpp_reference/#suction_action_state-enum","title":"SUCTION_ACTION_STATE","text":"<p>Suction cup action state enumeration.Represents the operational state of a vacuum suction cup end-effector, tracking the suction process from idle to success or failure.</p> Enum Value Description suction_action_idle Idle state, vacuum not activated suction_action_sucking Suction in progress, attempting to grasp object suction_action_success Suction successful, pressure decreased indicating secure grasp suction_action_failed Suction failed, pressure did not decrease (no object or seal failure)"},{"location":"api_cpp_reference/#galbotmotion-class","title":"GalbotMotion (class)","text":"<p>Unified motion planning and control interface for Galbot robots.This class provides a comprehensive API for robot motion control, including:Forward and inverse kinematics computationSingle-chain and multi-chain trajectory planningCollision detection (self-collision and environment)Tool and obstacle managementWhole-body coordinated motion planningGalbotMotion follows the Singleton design pattern to ensure a single instance manages all motion-related operations and robot state. Thread-safety is not guaranteed; external synchronization required for multi-threaded access.All angular units are radians, linear units are meters (SI standard).Quaternions must be unit-normalized: sqrt(x\u00b2 + y\u00b2 + z\u00b2 + w\u00b2) = 1.Usage Example:GalbotMotion&amp;motion=GalbotMotion::get_instance();if(!motion.init()){//Handleinitializationfailure}</p>"},{"location":"api_cpp_reference/#get_instance","title":"get_instance","text":"<pre><code>static GalbotMotion&amp; galbot::sdk::g1::GalbotMotion::get_instance()\n</code></pre> Item Description Function Get the singleton instance of GalbotMotion. Parameters None Return Reference to the unique GalbotMotion instance"},{"location":"api_cpp_reference/#init","title":"init","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::init()\n</code></pre> Item Description Function Initialize motion planning system and communication interfaces. Parameters None Return true if initialization succeedsfalse if initialization fails (check logs for details)"},{"location":"api_cpp_reference/#is_valid","title":"is_valid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::is_valid()\n</code></pre> Item Description Function Check if the motion interface is properly initialized and operational. Parameters None Return true if object is valid and ready for usefalse if initialization failed or object is in invalid state"},{"location":"api_cpp_reference/#forward_kinematics","title":"forward_kinematics","text":"<pre><code>std::tuple&lt;MotionStatus, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::forward_kinematics(const std::string &amp;target_frame, const std::string &amp;reference_frame=\"base_link\", const std::unordered_map&lt; std::string, std::vector&lt; double &gt;&gt; &amp;joint_state={}, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Compute forward kinematics for a target link. Parameters target_frame: Name of the link whose pose is to be computed (e.g., \"left_ee_link\", \"camera_link\")reference_frame: Coordinate frame for pose expression (default: \"base_link\")joint_state: Joint configurations by chain: {chain_name -&gt; joint_angles}. Empty map uses current robot joint state.params: Planning parameters (collision checking, timeout, etc.) Return Tuple of (status, pose_vector): status: MotionStatus::SUCCESS on success, error code otherwise pose_vector: [x, y, z, qx, qy, qz, qw] (meters, quaternion) or empty on failure"},{"location":"api_cpp_reference/#forward_kinematics_by_state","title":"forward_kinematics_by_state","text":"<pre><code>std::tuple&lt;MotionStatus, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::forward_kinematics_by_state(const std::string &amp;target_frame, const std::shared_ptr&lt; RobotStates &gt; &amp;reference_robot_states=nullptr, const std::string &amp;reference_frame=\"base_link\", std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Compute forward kinematics using complete robot state. Parameters target_frame: Link name for pose computationreference_robot_states: Complete robot state; nullptr uses current robot statereference_frame: Coordinate frame for pose expression (default: \"base_link\")params: Planning parameters Return Tuple of (status, pose_vector): status: MotionStatus::SUCCESS on success, error code otherwise pose_vector: [x, y, z, qx, qy, qz, qw] (meters, quaternion) or empty on failure"},{"location":"api_cpp_reference/#inverse_kinematics","title":"inverse_kinematics","text":"<pre><code>std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;double&gt; &gt; &gt; galbot::sdk::g1::GalbotMotion::inverse_kinematics(const std::vector&lt; double &gt; &amp;target_pose, const std::vector&lt; std::string &gt; &amp;chain_names, const std::string &amp;target_frame=\"EndEffector\", const std::string &amp;reference_frame=\"base_link\", const std::unordered_map&lt; std::string, std::vector&lt; double &gt;&gt; &amp;initial_joint_positions={}, const bool &amp;enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Compute inverse kinematics for target Cartesian pose. Parameters target_pose: Target Cartesian pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion)chain_names: Kinematic chains to coordinate (e.g., {\"left_arm\"}, {\"right_arm\", \"torso\"})target_frame: Frame on chain for pose target (e.g., \"EndEffector\", \"Camera\", \"TCP\")reference_frame: Coordinate frame for pose specification (default: \"base_link\")initial_joint_positions: Seed configurations by chain: {chain_name -&gt; joint_angles}. Empty map uses current robot state as seed.enable_collision_check: If true, only returns collision-free solutionsparams: Planning parameters (timeout, actuation type, etc.) Return Tuple of (status, solution_map): status: MotionStatus::SUCCESS if solvable, error code otherwise solution_map: {chain_name -&gt; joint_angles} (radians) for each chain, empty on failure"},{"location":"api_cpp_reference/#inverse_kinematics_by_state","title":"inverse_kinematics_by_state","text":"<pre><code>std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;double&gt; &gt; &gt; galbot::sdk::g1::GalbotMotion::inverse_kinematics_by_state(const std::vector&lt; double &gt; &amp;target_pose, const std::vector&lt; std::string &gt; &amp;chain_names, const std::string &amp;target_frame=\"EndEffector\", const std::string &amp;reference_frame=\"base_link\", const std::shared_ptr&lt; RobotStates &gt; &amp;reference_robot_states=nullptr, const bool &amp;enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Compute inverse kinematics using complete robot state as seed. Parameters target_pose: Target Cartesian pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion)chain_names: Kinematic chains to coordinatetarget_frame: Frame on chain for pose targetreference_frame: Coordinate frame for pose specification (default: \"base_link\")reference_robot_states: Complete robot state as IK seed; nullptr uses current stateenable_collision_check: If true, only returns collision-free solutionsparams: Planning parameters Return Tuple of (status, solution_map): status: MotionStatus::SUCCESS if solvable, error code otherwise solution_map: {chain_name -&gt; joint_angles} (radians), empty on failure"},{"location":"api_cpp_reference/#get_end_effector_pose","title":"get_end_effector_pose","text":"<pre><code>std::tuple&lt;MotionStatus, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::get_end_effector_pose(const std::string &amp;end_effector_frame, const std::string &amp;reference_frame=\"base_link\")\n</code></pre> Item Description Function Get current end-effector pose from robot state. Parameters end_effector_frame: Name of end-effector link (must exist in URDF, e.g., \"left_ee_link\")reference_frame: Coordinate frame for pose expression (default: \"base_link\") Return Tuple of (status, pose_vector): status: MotionStatus::SUCCESS on success, error codes: DATA_FETCH_FAILED: TF lookup failed INVALID_INPUT: Invalid frame names pose_vector: [x, y, z, qx, qy, qz, qw] (meters, quaternion) or empty on failure"},{"location":"api_cpp_reference/#get_end_effector_pose_on_chain","title":"get_end_effector_pose_on_chain","text":"<pre><code>std::tuple&lt;MotionStatus, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::get_end_effector_pose_on_chain(const std::string &amp;chain_name, const std::string frame_id=\"EndEffector\", const std::string &amp;reference_frame=\"base_link\")\n</code></pre> Item Description Function Get current end-effector pose for a specific kinematic chain. Parameters chain_name: Kinematic chain identifier (e.g., \"left_arm\", \"right_arm\")frame_id: End-effector frame type: \"EndEffector\" (flange), \"Camera\", etc.reference_frame: Coordinate frame for pose expression (default: \"base_link\") Return Tuple of (status, pose_vector): status: MotionStatus::SUCCESS on success, error code otherwise pose_vector: [x, y, z, qx, qy, qz, qw] (meters, quaternion) or empty on failure"},{"location":"api_cpp_reference/#set_end_effector_pose","title":"set_end_effector_pose","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::set_end_effector_pose(const std::vector&lt; double &gt; &amp;target_pose, const std::string &amp;end_effector_frame, const std::string &amp;reference_frame=\"base_link\", std::shared_ptr&lt; RobotStates &gt; reference_robot_states=nullptr, const bool &amp;enable_collision_check=true, const bool &amp;is_blocking=true, const double &amp;timeout=-1.0, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Command end-effector to move to target Cartesian pose. Parameters target_pose: Target Cartesian pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion)end_effector_frame: Kinematic chain identifier (e.g., \"left_arm\", \"right_arm\")reference_frame: Coordinate frame for pose specification (default: \"base_link\")reference_robot_states: Planning seed state; nullptr uses current state. Warning: For direct execution, typically leave as nullptr to avoid conflicts between seed and actual robot state.enable_collision_check: If true, only executes collision-free trajectoriesis_blocking: If true, blocks until motion completes or times out; if false, returns immediatelytimeout: Blocking timeout (seconds). If &lt; 0 and is_blocking=true, uses params-&gt;timeout_secondparams: Motion planning parameters (linear motion, actuation type, etc.) Return MotionStatus: SUCCESS: Motion completed successfully (blocking) or command sent (non-blocking) TIMEOUT: Motion exceeded timeout duration INVALID_INPUT: Invalid pose or parameters FAULT: Planning or execution failure"},{"location":"api_cpp_reference/#motion_plan","title":"motion_plan","text":"<pre><code>std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;double&gt; &gt; &gt; &gt; galbot::sdk::g1::GalbotMotion::motion_plan(std::shared_ptr&lt; RobotStates &gt; target, std::shared_ptr&lt; RobotStates &gt; start=nullptr, std::shared_ptr&lt; RobotStates &gt; reference_robot_states=nullptr, bool enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Plan trajectory for a single kinematic chain. Parameters target: Target state (must be PoseState or JointStates, not base RobotStates). Specifies the goal configuration for planning.start: Optional start state (typically JointStates). nullptr uses current robot state as start. Warning: For direct execution, leave as nullptr to avoid conflicts.reference_robot_states: Whole-body reference state for planning context. nullptr uses current robot state. If start is provided, its joint values overwrite the corresponding chain in reference_robot_states. Warning: For direct execution, leave as nullptr.enable_collision_check: If true, only returns collision-free trajectoriesparams: Planning parameters (timeout, actuation type, linear motion, etc.) Return Tuple of (status, trajectory_map): status: MotionStatus::SUCCESS if planning succeeds, error code otherwise trajectory_map: {chain_name -&gt; waypoint_list}, where waypoint_list is a sequence of joint configurations (radians) along the trajectory. Empty on failure."},{"location":"api_cpp_reference/#motion_plan_multi_waypoints","title":"motion_plan_multi_waypoints","text":"<pre><code>std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;double&gt; &gt; &gt; &gt; galbot::sdk::g1::GalbotMotion::motion_plan_multi_waypoints(std::shared_ptr&lt; RobotStates &gt; target, std::vector&lt; std::vector&lt; double &gt;&gt; targets, std::shared_ptr&lt; RobotStates &gt; start=nullptr, std::shared_ptr&lt; RobotStates &gt; reference_robot_states=nullptr, bool enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Plan trajectory through multiple waypoints for a single chain. Parameters target: Template state defining waypoint type (PoseState or JointStates) and specifying chain_name. The state values in target are not used; only the type and chain_name are referenced.targets: Sequence of waypoint values. Format depends on target type: PoseState: each waypoint is [x, y, z, qx, qy, qz, qw] (meters, quaternion) JointStates: each waypoint is joint configuration (radians)start: Optional start state (JointStates). nullptr uses current robot state. Warning: For direct execution, leave as nullptr.reference_robot_states: Whole-body reference state for planning context. nullptr uses current state. Warning: For direct execution, leave as nullptr.enable_collision_check: If true, only returns collision-free trajectoriesparams: Planning parameters Return Tuple of (status, trajectory_map): status: MotionStatus::SUCCESS if planning succeeds, error code otherwise trajectory_map: {chain_name -&gt; waypoint_list}, smooth trajectory through all waypoints"},{"location":"api_cpp_reference/#motion_plan_multi_waypoints_1","title":"motion_plan_multi_waypoints","text":"<pre><code>std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;double&gt; &gt; &gt; &gt; galbot::sdk::g1::GalbotMotion::motion_plan_multi_waypoints(std::unordered_map&lt; std::shared_ptr&lt; RobotStates &gt;, std::vector&lt; std::vector&lt; double &gt;&gt;&gt; targets, std::vector&lt; std::shared_ptr&lt; RobotStates &gt;&gt; start={}, std::shared_ptr&lt; RobotStates &gt; reference_robot_states=nullptr, bool enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Plan coordinated trajectories through waypoints for multiple chains. Parameters targets: Map of {state_template -&gt; waypoint_list} for each chain. Keys are RobotStates (with chain_name set) defining waypoint type; values are waypoint sequences in same format as single-chain version.start: Optional start states (JointStates) for each chain. Empty uses current state. Warning: For direct execution, leave empty.reference_robot_states: Whole-body reference state for planning context. nullptr uses current state. Warning: For direct execution, leave as nullptr.enable_collision_check: If true, only returns collision-free trajectoriesparams: Planning parameters Return Tuple of (status, trajectory_map): status: MotionStatus::SUCCESS if planning succeeds, error code otherwise trajectory_map: {chain_name -&gt; waypoint_list} for all chains"},{"location":"api_cpp_reference/#check_collision","title":"check_collision","text":"<pre><code>std::tuple&lt;MotionStatus, std::vector&lt;bool&gt; &gt; galbot::sdk::g1::GalbotMotion::check_collision(const std::vector&lt; std::shared_ptr&lt; RobotStates &gt;&gt; &amp;start, bool enable_collision_check=true, std::shared_ptr&lt; Parameter &gt; params=default_param)\n</code></pre> Item Description Function Check robot states for collisions. Parameters start: Vector of robot states to check. Each state can be: RobotStates: complete whole-body configuration JointStates: single-chain configuration (other joints use current state)enable_collision_check: If true, checks both self and environment collisions; if false, only checks self-collisionsparams: Optional parameters Return Tuple of (status, collision_results): status: MotionStatus::SUCCESS if check completes, error code otherwise collision_results: Boolean vector (same size as start): true = collision detected, false = collision-free"},{"location":"api_cpp_reference/#attach_tool","title":"attach_tool","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::attach_tool(const std::string &amp;chain, const std::string &amp;tool)\n</code></pre> Item Description Function Attach a tool to an end-effector. Parameters chain: Kinematic chain for tool attachment (e.g., \"left_arm\", \"right_arm\")tool: Tool identifier (must be predefined in tool library, see getSupportToolList()) Return MotionStatus: SUCCESS: Tool attached successfully INVALID_INPUT: Invalid chain or tool name FAULT: Tool attachment failed"},{"location":"api_cpp_reference/#detach_tool","title":"detach_tool","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::detach_tool(const std::string &amp;chain)\n</code></pre> Item Description Function Detach the current tool from an end-effector. Parameters chain: Kinematic chain to detach tool from (e.g., \"left_arm\", \"right_arm\") Return MotionStatus: SUCCESS: Tool detached successfully INVALID_INPUT: Invalid chain name or no tool attached FAULT: Tool detachment failed"},{"location":"api_cpp_reference/#add_obstacle","title":"add_obstacle","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::add_obstacle(const std::string &amp;obstacle_id, const std::string &amp;obstacle_type, const std::vector&lt; double &gt; &amp;pose, const std::array&lt; double, 3 &gt; &amp;scale={}, const std::string &amp;key=\"\", const std::string &amp;target_frame=\"world\", const std::string &amp;ee_frame=\"ee_base\", const std::vector&lt; double &gt; &amp;reference_joint_positions={}, const std::vector&lt; double &gt; &amp;reference_base_pose={}, const std::vector&lt; std::string &gt; &amp;ignore_collision_link_names={}, const double &amp;safe_margin=0, const double &amp;resolution=0.01)\n</code></pre> Item Description Function Load collision object into environment. Parameters obstacle_id: Unique obstacle identifier (must not exist in scene). Used for later removal/updates.obstacle_type: Obstacle geometry type (e.g., \"box\", \"sphere\", \"cylinder\", \"mesh\", \"point_cloud\", \"depth_image\"). See getSupportObstacleType() for valid types.pose: Obstacle pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion) relative to target_frame.scale: Geometry dimensions (meters): box: [length, width, height] sphere: [radius, -, -] cylinder: [radius, height, -] mesh/point_cloud: scaling factors [sx, sy, sz]key: Type-specific data: mesh/point_cloud: file path (e.g., \"/path/to/model.stl\") depth_image: camera source (\"front_head\", \"left_arm\", \"right_arm\") primitives: unused, leave emptytarget_frame: Reference frame for pose (default: \"world\"). Can be \"world\", \"base_link\", or chain name (e.g., \"left_arm\").ee_frame: If target_frame is a chain, specifies frame on chain: \"ee_base\" (end-effector), \"camera_base\", \"camera_object\".reference_joint_positions: Robot joint state for computing frame transforms (radians). Empty uses current robot state.reference_base_pose: Robot base pose in map frame: [x, y, z, qx, qy, qz, qw]. Empty uses current localization.ignore_collision_link_names: Robot links to exclude from collision with this obstacle. Useful for carried objects or mounting surfaces.safe_margin: Safety distance buffer (meters). Collision reported if distance &lt; safe_margin. Default: 0 (contact-based).resolution: Discretization resolution (meters) for complex geometries (mesh, point cloud, depth image). Default: 0.01m. Return MotionStatus: SUCCESS: Obstacle added successfully INVALID_INPUT: Invalid obstacle_id (duplicate), type, or parameters FAULT: Failed to process geometry or add to scene"},{"location":"api_cpp_reference/#remove_obstacle","title":"remove_obstacle","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::remove_obstacle(const std::string &amp;obstacle_id)\n</code></pre> Item Description Function Remove a collision obstacle from the planning scene. Parameters obstacle_id: Unique identifier of obstacle to remove (must exist in scene) Return MotionStatus: SUCCESS: Obstacle removed successfully INVALID_INPUT: obstacle_id not found in scene FAULT: Removal operation failed"},{"location":"api_cpp_reference/#clear_obstacle","title":"clear_obstacle","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::clear_obstacle()\n</code></pre> Item Description Function Remove all collision obstacles from the planning scene. Parameters None Return MotionStatus: SUCCESS: All obstacles cleared successfully FAULT: Clear operation failed"},{"location":"api_cpp_reference/#attach_target_object","title":"attach_target_object","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::attach_target_object(const std::string &amp;obstacle_id, const std::string &amp;obstacle_type, const std::vector&lt; double &gt; &amp;pose, const std::array&lt; double, 3 &gt; &amp;scale={}, const std::string &amp;key=\"\", const std::string &amp;target_frame=\"world\", const std::string &amp;ee_frame=\"ee_base\", const std::vector&lt; double &gt; &amp;reference_joint_positions={}, const std::vector&lt; double &gt; &amp;reference_base_pose={}, const std::vector&lt; std::string &gt; &amp;ignore_collision_link_names={}, const double &amp;safe_margin=0, const double &amp;resolution=0.01)\n</code></pre> Item Description Function Attach a collision object to the robot (e.g., grasped object). Parameters obstacle_id: Unique object identifier (must not exist in scene).obstacle_type: Object geometry type (e.g., \"box\", \"sphere\", \"mesh\"). See getSupportObstacleType() for valid types.pose: Object pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion) relative to target_frame at attachment time.scale: Geometry dimensions (meters): box: [length, width, height] sphere: [radius, -, -] cylinder: [radius, height, -]key: Type-specific data (e.g., mesh file path for \"mesh\" type).target_frame: Attachment frame (default: \"world\"). Typically a chain name (e.g., \"left_arm\") for grasped objects.ee_frame: If target_frame is a chain, specifies frame on chain (\"ee_base\", \"camera_base\", etc.).reference_joint_positions: Robot joint state for computing attachment transform (radians). Empty uses current robot state.reference_base_pose: Robot base pose in map: [x, y, z, qx, qy, qz, qw]. Empty uses current localization.ignore_collision_link_names: Robot links to exclude from collision with this object. Typically includes the grasping end-effector links.safe_margin: Safety distance buffer (meters). Default: 0.resolution: Discretization resolution for complex geometries (meters). Default: 0.01m. Return MotionStatus: SUCCESS: Object attached successfully INVALID_INPUT: Invalid parameters or duplicate obstacle_id FAULT: Attachment operation failed"},{"location":"api_cpp_reference/#detach_target_object","title":"detach_target_object","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::detach_target_object(const std::string &amp;obstacle_id)\n</code></pre> Item Description Function Detach an object from the robot (e.g., after release). Parameters obstacle_id: Unique identifier of attached object to remove Return MotionStatus: SUCCESS: Object detached successfully INVALID_INPUT: obstacle_id not found in attached objects FAULT: Detachment operation failed"},{"location":"api_cpp_reference/#set_motion_plan_config","title":"set_motion_plan_config","text":"<pre><code>MotionStatus galbot::sdk::g1::GalbotMotion::set_motion_plan_config(std::shared_ptr&lt; MotionPlanConfig &gt; config)\n</code></pre> Item Description Function Set global motion planning configuration. Parameters config: Shared pointer to MotionPlanConfig with desired settings Return MotionStatus: SUCCESS: Configuration applied successfully INVALID_INPUT: Invalid configuration parameters FAULT: Configuration update failed"},{"location":"api_cpp_reference/#get_motion_plan_config","title":"get_motion_plan_config","text":"<pre><code>std::tuple&lt;MotionStatus, MotionPlanConfig&gt; galbot::sdk::g1::GalbotMotion::get_motion_plan_config()\n</code></pre> Item Description Function Get current motion planning configuration. Parameters None Return Tuple of (status, config): status: MotionStatus::SUCCESS on success, error code otherwise config: Current MotionPlanConfig object (default-constructed on failure)"},{"location":"api_cpp_reference/#get_link_names","title":"get_link_names","text":"<pre><code>std::vector&lt;std::string&gt; galbot::sdk::g1::GalbotMotion::get_link_names(bool only_end_effector=false)\n</code></pre> Item Description Function Get robot link names from kinematic model. Parameters only_end_effector: If true, returns only end-effector/tool links; if false, returns all links including base, intermediate, and end-effector links. Default: false (all links). Return Vector of link name strings (empty if retrieval fails)"},{"location":"api_cpp_reference/#getsupportlinks","title":"getSupportLinks","text":"<pre><code>const std::set&lt;std::string&gt;&amp; galbot::sdk::g1::GalbotMotion::getSupportLinks()\n</code></pre> Item Description Function Get set of valid link names in robot model. Parameters None Return Const reference to set of supported link name strings"},{"location":"api_cpp_reference/#getsupportchains","title":"getSupportChains","text":"<pre><code>const std::set&lt;std::string&gt;&amp; galbot::sdk::g1::GalbotMotion::getSupportChains()\n</code></pre> Item Description Function Get set of valid kinematic chain names. Parameters None Return Const reference to set of supported chain name strings"},{"location":"api_cpp_reference/#getsupportframe","title":"getSupportFrame","text":"<pre><code>const std::set&lt;std::string&gt;&amp; galbot::sdk::g1::GalbotMotion::getSupportFrame()\n</code></pre> Item Description Function Get set of valid reference frame names. Parameters None Return Const reference to set of supported reference frame name strings"},{"location":"api_cpp_reference/#getsupporteeframe","title":"getSupportEEFrame","text":"<pre><code>const std::set&lt;std::string&gt;&amp; galbot::sdk::g1::GalbotMotion::getSupportEEFrame()\n</code></pre> Item Description Function Get set of valid end-effector frame types. Parameters None Return Const reference to set of supported end-effector frame type strings"},{"location":"api_cpp_reference/#getsupporttoollist","title":"getSupportToolList","text":"<pre><code>const std::set&lt;std::string&gt;&amp; galbot::sdk::g1::GalbotMotion::getSupportToolList()\n</code></pre> Item Description Function Get list of available tools that can be attached. Parameters None Return Const reference to set of tool name strings"},{"location":"api_cpp_reference/#getsupportobstacletype","title":"getSupportObstacleType","text":"<pre><code>std::set&lt;std::string&gt; galbot::sdk::g1::GalbotMotion::getSupportObstacleType()\n</code></pre> Item Description Function Get list of supported collision obstacle geometry types. Parameters None Return Set of supported obstacle type strings"},{"location":"api_cpp_reference/#getbuiltobjectlist","title":"getBuiltObjectList","text":"<pre><code>std::vector&lt;std::string&gt; galbot::sdk::g1::GalbotMotion::getBuiltObjectList()\n</code></pre> Item Description Function Get list of currently added obstacles in planning scene. Parameters None Return Vector of obstacle ID strings (empty if no obstacles)"},{"location":"api_cpp_reference/#islinknamevalid","title":"isLinkNameValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isLinkNameValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate link name against robot model. Parameters value: Link name to validatethrow_exception: If true, throws std::invalid_argument on validation failure; if false, returns false silently. Default: false. Return true if link name is valid, false otherwise"},{"location":"api_cpp_reference/#ischainnamevalid","title":"isChainNameValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isChainNameValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate kinematic chain name. Parameters value: Chain name to validate (e.g., \"left_arm\", \"right_arm\")throw_exception: If true, throws exception on failure. Default: false. Return true if chain name is valid, false otherwise"},{"location":"api_cpp_reference/#isframenamevalid","title":"isFrameNameValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isFrameNameValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate reference frame name. Parameters value: Frame name to validate (e.g., \"base_link\", \"world\")throw_exception: If true, throws exception on failure. Default: false. Return true if frame name is valid, false otherwise"},{"location":"api_cpp_reference/#iseeframevalid","title":"isEEFrameValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isEEFrameValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate end-effector frame type. Parameters value: Frame type to validate (e.g., \"EndEffector\", \"Camera\", \"TCP\")throw_exception: If true, throws exception on failure. Default: false. Return true if frame type is valid, false otherwise"},{"location":"api_cpp_reference/#istoolnamevalid","title":"isToolNameValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isToolNameValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate tool name. Parameters value: Tool name to validatethrow_exception: If true, throws exception on failure. Default: false. Return true if tool name is valid, false otherwise"},{"location":"api_cpp_reference/#isobstacletypevalid","title":"isObstacleTypeValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isObstacleTypeValid(const std::string &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate obstacle geometry type. Parameters value: Obstacle type to validate (e.g., \"box\", \"sphere\", \"mesh\")throw_exception: If true, throws exception on failure. Default: false. Return true if obstacle type is valid, false otherwise"},{"location":"api_cpp_reference/#iswholebodystatevalid","title":"isWholeBodyStateValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isWholeBodyStateValid(const std::vector&lt; double &gt; &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate whole-body joint configuration vector. Parameters value: Joint configuration vector (radians) to validatethrow_exception: If true, throws exception on failure. Default: false. Return true if vector size matches robot DOF, false otherwise"},{"location":"api_cpp_reference/#ispose7dvalid","title":"isPose7dValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isPose7dValid(const std::vector&lt; double &gt; &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate 7D pose vector (position + quaternion). Parameters value: Pose vector to validatethrow_exception: If true, throws exception on failure. Default: false. Return true if vector size is 7, false otherwise"},{"location":"api_cpp_reference/#ischainjointstatevalid","title":"isChainJointStateValid","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::isChainJointStateValid(const std::unordered_map&lt; std::string, std::vector&lt; double &gt;&gt; &amp;value, bool throw_exception=false)\n</code></pre> Item Description Function Validate chain-indexed joint configuration map. Parameters value: Map of {chain_name -&gt; joint_configuration} to validatethrow_exception: If true, throws exception on failure. Default: false. Return true if all chain names and vector sizes are valid, false otherwise"},{"location":"api_cpp_reference/#getrobotdof","title":"getRobotDof","text":"<pre><code>int galbot::sdk::g1::GalbotMotion::getRobotDof()\n</code></pre> Item Description Function Get robot total degrees of freedom (DOF). Parameters None Return Number of robot DOF (actuated joints)"},{"location":"api_cpp_reference/#getrobotstates","title":"getRobotStates","text":"<pre><code>RobotStates galbot::sdk::g1::GalbotMotion::getRobotStates()\n</code></pre> Item Description Function Get current complete robot state. Parameters None Return RobotStates object containing: whole_body_joint: complete joint configuration (radians) base_state: mobile base pose [x, y, z, qx, qy, qz, qw] (meters, quaternion)"},{"location":"api_cpp_reference/#getwholebodystate","title":"getWholeBodyState","text":"<pre><code>std::vector&lt;double&gt; galbot::sdk::g1::GalbotMotion::getWholeBodyState()\n</code></pre> Item Description Function Get current whole-body joint configuration. Parameters None Return Vector of joint angles (radians), size = getRobotDof()"},{"location":"api_cpp_reference/#getchassisstate","title":"getChassisState","text":"<pre><code>std::vector&lt;double&gt; galbot::sdk::g1::GalbotMotion::getChassisState()\n</code></pre> Item Description Function Get current mobile base pose. Parameters None Return Base pose vector: [x, y, z, qx, qy, qz, qw] (meters, unit quaternion)"},{"location":"api_cpp_reference/#getchainjointstate","title":"getChainJointState","text":"<pre><code>std::unordered_map&lt;std::string, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::getChainJointState()\n</code></pre> Item Description Function Get current joint configurations for all kinematic chains. Parameters None Return Map of {chain_name -&gt; joint_configuration} (radians) for each chain (e.g., {\"left_arm\" -&gt; [7 joint angles], \"right_arm\" -&gt; [7 joint angles]})"},{"location":"api_cpp_reference/#getchainposestate","title":"getChainPoseState","text":"<pre><code>std::unordered_map&lt;std::string, std::vector&lt;double&gt; &gt; galbot::sdk::g1::GalbotMotion::getChainPoseState(const std::string &amp;frame=\"base_link\")\n</code></pre> Item Description Function Get current Cartesian poses for all kinematic chains. Parameters frame: Reference frame for pose expression (default: \"base_link\") Return Map of {chain_name -&gt; pose_vector}, where pose_vector is [x, y, z, qx, qy, qz, qw] (meters, quaternion) for each chain's end-effector"},{"location":"api_cpp_reference/#replace_joint_state","title":"replace_joint_state","text":"<pre><code>bool galbot::sdk::g1::GalbotMotion::replace_joint_state(const std::string &amp;chain_name, const std::vector&lt; double &gt; &amp;chain_joint, std::vector&lt; double &gt; &amp;whole_body_joint)\n</code></pre> Item Description Function Update a specific chain's joints in a whole-body configuration. Parameters chain_name: Chain identifier whose joints to replacechain_joint: New joint configuration for the chain (radians)whole_body_joint: Whole-body joint vector to modify (in/out parameter) Return true if replacement succeeds, false if chain_name invalid or size mismatch"},{"location":"api_cpp_reference/#status_to_string","title":"status_to_string","text":"<pre><code>std::string galbot::sdk::g1::GalbotMotion::status_to_string(MotionStatus status)\n</code></pre> Item Description Function Convert MotionStatus enum to human-readable string. Parameters status: MotionStatus enumeration value Return Descriptive status string (e.g., \"SUCCESS: Execution succeeded\", \"TIMEOUT: Execution timeout\")"},{"location":"api_cpp_reference/#galbotnavigation-class","title":"GalbotNavigation (class)","text":"<p>Navigation interface for mobile robot chassis motion planning and localization.This class provides a thread-safe singleton interface for controlling the mobile base navigation system. It supports 2D pose estimation, relocalization, goal-directed navigation with dynamic obstacle avoidance, and path planning capabilities.The navigation system operates in a global map frame and provides both blocking and non-blocking navigation modes. It supports both differential drive and omnidirectional motion planning strategies.This class uses the singleton pattern with thread-safe initialization.All pose coordinates are specified in the map frame unless explicitly stated otherwise.Typical usage: auto&amp;nav=GalbotNavigation::get_instance();if(nav.init()){Posegoal;goal.x=1.0;//metersgoal.y=2.0;//metersgoal.theta=0.0;//radiansnav.navigate_to_goal(goal,true,false,30.0,true);}</p>"},{"location":"api_cpp_reference/#get_instance_1","title":"get_instance","text":"<pre><code>static GalbotNavigation&amp; galbot::sdk::g1::GalbotNavigation::get_instance()\n</code></pre> Item Description Function Get the thread-safe singleton instance of GalbotNavigation. Parameters None Return Reference to the GalbotNavigation singleton instance."},{"location":"api_cpp_reference/#init_1","title":"init","text":"<pre><code>bool galbot::sdk::g1::GalbotNavigation::init()\n</code></pre> Item Description Function Initialize the navigation subsystem and its dependencies. Parameters None Return true if initialization succeeded, false otherwise."},{"location":"api_cpp_reference/#relocalize","title":"relocalize","text":"<pre><code>NavigationStatus galbot::sdk::g1::GalbotNavigation::relocalize(const Pose &amp;init_pose)\n</code></pre> Item Description Function Perform relocalization to re-estimate the robot's pose in the map frame. Parameters init_pose: Initial pose estimate in the map frame (x, y in meters, theta in radians). This serves as the starting point for the relocalization algorithm. Return NavigationStatus indicating the result of the relocalization request. See NavigationStatus enumeration for possible values."},{"location":"api_cpp_reference/#is_localized","title":"is_localized","text":"<pre><code>bool galbot::sdk::g1::GalbotNavigation::is_localized()\n</code></pre> Item Description Function Check whether the robot is currently localized in the map. Parameters None Return true if the robot is localized with acceptable confidence, false if localization is lost or uncertain."},{"location":"api_cpp_reference/#get_current_pose","title":"get_current_pose","text":"<pre><code>Pose galbot::sdk::g1::GalbotNavigation::get_current_pose()\n</code></pre> Item Description Function Get the current estimated pose of the robot chassis in the map frame. Parameters None Return Pose structure containing: x: X-coordinate in meters (map frame) y: Y-coordinate in meters (map frame) theta: Orientation in radians (map frame, counter-clockwise from x-axis)"},{"location":"api_cpp_reference/#navigate_to_goal","title":"navigate_to_goal","text":"<pre><code>NavigationStatus galbot::sdk::g1::GalbotNavigation::navigate_to_goal(const Pose &amp;goal_pose, bool enable_collision_check=true, bool is_blocking=false, float timeout=8, bool omni_plan=true)\n</code></pre> Item Description Function Navigate the robot to a target goal pose in the map frame. Parameters goal_pose: Target goal pose in the map frame. Contains: x: Target x-coordinate in meters y: Target y-coordinate in meters theta: Target orientation in radiansenable_collision_check: If true, enables dynamic obstacle detection and avoidance during navigation. If false, only static map obstacles are considered. Default: true.is_blocking: Execution mode flag. Default: false. false (non-blocking): Returns immediately after sending the navigation command. The return status indicates whether the command was successfully sent, not whether the goal was reached. true (blocking): Blocks until the goal is reached, navigation fails, or timeout occurs. The return status reflects the final navigation outcome.timeout: Maximum wait time in seconds for blocking mode. Default: 8.0 seconds. Only relevant when is_blocking is true. If the goal is not reached within this time, the method returns with a timeout status.omni_plan: Motion planning mode flag. Default: true. true: Enables omnidirectional motion planning (holonomic drive), allowing the robot to move in any direction and rotate independently. false: Uses differential drive planning with kinematic constraints. Return NavigationStatus indicating the result: In non-blocking mode: Command acceptance status In blocking mode: Final navigation outcome (success, failure, timeout)"},{"location":"api_cpp_reference/#move_straight_to","title":"move_straight_to","text":"<pre><code>NavigationStatus galbot::sdk::g1::GalbotNavigation::move_straight_to(const Pose &amp;goal_pose, bool is_blocking=true, float timeout=8)\n</code></pre> Item Description Function Move the robot to a relative target pose in the odometry frame. Parameters goal_pose: Target pose relative to the current robot base_link frame. Contains: x: Forward/backward displacement in meters (+ forward, - backward) y: Left/right displacement in meters (+ left, - right) theta: Relative rotation in radians (counter-clockwise positive)is_blocking: Execution mode flag. Default: true. true (blocking): Blocks until the motion is complete, fails, or timeout occurs. The return status reflects the final outcome. false (non-blocking): Returns immediately after sending the motion command. The return status indicates command acceptance.timeout: Maximum wait time in seconds for blocking mode. Default: 8.0 seconds. Only relevant when is_blocking is true. Return NavigationStatus indicating the result: In non-blocking mode: Command acceptance status In blocking mode: Final motion outcome (success, failure, timeout)"},{"location":"api_cpp_reference/#stop_navigation","title":"stop_navigation","text":"<pre><code>NavigationStatus galbot::sdk::g1::GalbotNavigation::stop_navigation()\n</code></pre> Item Description Function Stop the current navigation task and bring the robot to a halt. Parameters None Return NavigationStatus indicating whether the stop command was successfully sent to the navigation system."},{"location":"api_cpp_reference/#check_path_reachability","title":"check_path_reachability","text":"<pre><code>bool galbot::sdk::g1::GalbotNavigation::check_path_reachability(const Pose &amp;goal_pose, const Pose &amp;start_pose)\n</code></pre> Item Description Function Check if a collision-free path exists from start to goal in the map. Parameters goal_pose: Goal pose in the map frame. Contains: x: Goal x-coordinate in meters y: Goal y-coordinate in meters theta: Goal orientation in radiansstart_pose: Start pose in the map frame. Contains: x: Start x-coordinate in meters y: Start y-coordinate in meters theta: Start orientation in radians Return true if a collision-free path exists from start to goal, false if no valid path can be found."},{"location":"api_cpp_reference/#check_goal_arrival","title":"check_goal_arrival","text":"<pre><code>bool galbot::sdk::g1::GalbotNavigation::check_goal_arrival()\n</code></pre> Item Description Function Check if the robot has successfully reached the current goal. Parameters None Return true if the robot has reached the goal within tolerance thresholds, false if still navigating, no active goal, or goal not yet reached."},{"location":"api_cpp_reference/#galbotrobot-class","title":"GalbotRobot (class)","text":"<p>Main robot control interface for Galbot G1 humanoid robot.This class provides a singleton interface for controlling the Galbot G1 robot. It supports:Joint position and trajectory controlEnd-effector control (grippers and suction cups)Mobile base velocity controlSensor data acquisition (IMU, cameras, LiDAR, ultrasonic)Coordinate frame transformationsSystem lifecycle managementThe class follows the singleton pattern to ensure a single instance controls the robot hardware throughout the application lifecycle.All angles are in radians unless otherwise specified.All linear distances are in meters unless otherwise specified.All timestamps are in nanoseconds unless otherwise specified.</p>"},{"location":"api_cpp_reference/#get_instance_2","title":"get_instance","text":"<pre><code>static GalbotRobot&amp; galbot::sdk::g1::GalbotRobot::get_instance()\n</code></pre> Item Description Function Get the singleton instance of GalbotRobot. Parameters None Return Reference to the singleton instance"},{"location":"api_cpp_reference/#init_2","title":"init","text":"<pre><code>bool galbot::sdk::g1::GalbotRobot::init(const std::unordered_set&lt; SensorType &gt; &amp;enable_sensor_set={})\n</code></pre> Item Description Function Initialize the robot control system. Parameters enable_sensor_set: Set of sensors to enable. If empty, a default set of sensors will be enabled. Specify only required sensors to reduce computational overhead and memory consumption. Return true if initialization succeededfalse if initialization failed"},{"location":"api_cpp_reference/#set_joint_commands","title":"set_joint_commands","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_joint_commands(const std::vector&lt; JointCommand &gt; &amp;joint_commands, const std::vector&lt; std::string &gt; &amp;joint_groups={}, const std::vector&lt; std::string &gt; &amp;joint_names={})\n</code></pre> Item Description Function Set low-level joint commands for specified joints. Parameters joint_commands: Vector of joint commands containing control parameters for each jointjoint_groups: Joint groups to control. Supported groups: legs, head, left_arm, right_arm, gripper, suction_cup. Empty vector defaults to all body joints (legs, head, left_arm, right_arm).joint_names: Specific joint names to control. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored. Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#set_joint_commands_1","title":"set_joint_commands","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_joint_commands(const std::vector&lt; JointCommand &gt; &amp;joint_commands, const std::vector&lt; JointGroup &gt; &amp;joint_groups={}, const std::vector&lt; std::string &gt; &amp;joint_names={})\n</code></pre> Item Description Function Set low-level joint commands for specified joint groups. Parameters joint_commands: Vector of joint commands containing control parameters for each jointjoint_groups: Joint groups to control using JointGroup enumerations. Supported groups: legs, head, left_arm, right_arm, gripper, suction_cup. Empty vector defaults to all body joints (legs, head, left_arm, right_arm).joint_names: Specific joint names to control. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored. Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#set_joint_positions","title":"set_joint_positions","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_joint_positions(const std::vector&lt; double &gt; &amp;joint_positions, const std::vector&lt; JointGroup &gt; &amp;joint_groups={}, const std::vector&lt; std::string &gt; &amp;joint_names={}, const bool is_blocking=true, const double speed_rad_s=0.2, const double timeout_s=15)\n</code></pre> Item Description Function Set target joint positions for specified joint groups. Parameters joint_positions: Vector of target joint angles in radians. The order must match the joint ordering returned by get_joint_names() for the specified joint_groups or joint_names.joint_groups: Joint groups to control using JointGroup enumerations. Supported groups: legs, head, left_arm, right_arm. Empty vector defaults to all body joints (legs, head, left_arm, right_arm).joint_names: Specific joint names to control. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored.is_blocking: If true, blocks until motion completes or timeout occurs. If false, returns immediately after command is sent.speed_rad_s: Maximum joint angular velocity in radians per second (rad/s). Default: 0.2 rad/s.timeout_s: Maximum blocking wait time in seconds. Returns immediately upon timeout regardless of execution completion. Default: 15 seconds. Return ControlStatus indicating success or failure of the motion command"},{"location":"api_cpp_reference/#set_joint_positions_1","title":"set_joint_positions","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_joint_positions(const std::vector&lt; double &gt; &amp;joint_positions, const std::vector&lt; std::string &gt; &amp;joint_groups={}, const std::vector&lt; std::string &gt; &amp;joint_names={}, const bool is_blocking=true, const double speed_rad_s=0.2, const double timeout_s=15)\n</code></pre> Item Description Function Set target joint positions for specified joint groups by name. Parameters joint_positions: Vector of target joint angles in radians. The order must match the joint ordering returned by get_joint_names() for the specified joint_groups or joint_names.joint_groups: Joint group names to control. Supported groups: \"legs\", \"head\", \"left_arm\", \"right_arm\". Empty vector defaults to all body joints (legs, head, left_arm, right_arm).joint_names: Specific joint names to control. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored.is_blocking: If true, blocks until motion completes or timeout occurs. If false, returns immediately after command is sent.speed_rad_s: Maximum joint angular velocity in radians per second (rad/s). Default: 0.2 rad/s.timeout_s: Maximum blocking wait time in seconds. Returns immediately upon timeout regardless of execution completion. Default: 15 seconds. Return ControlStatus indicating success or failure of the motion command"},{"location":"api_cpp_reference/#check_trajectory_execution_status","title":"check_trajectory_execution_status","text":"<pre><code>std::vector&lt;TrajectoryControlStatus&gt; galbot::sdk::g1::GalbotRobot::check_trajectory_execution_status(std::vector&lt; std::string &gt; joint_groups)\n</code></pre> Item Description Function Get trajectory execution status for specified joint groups. Parameters joint_groups: Vector of joint group names to query Return Vector of TrajectoryControlStatus indicating execution state for each group"},{"location":"api_cpp_reference/#check_trajectory_execution_status_1","title":"check_trajectory_execution_status","text":"<pre><code>std::vector&lt;TrajectoryControlStatus&gt; galbot::sdk::g1::GalbotRobot::check_trajectory_execution_status(std::vector&lt; JointGroup &gt; joint_groups)\n</code></pre> Item Description Function Get trajectory execution status for specified joint groups. Parameters joint_groups: Vector of JointGroup enumerations to query Return Vector of TrajectoryControlStatus indicating execution state for each group"},{"location":"api_cpp_reference/#execute_joint_trajectory","title":"execute_joint_trajectory","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::execute_joint_trajectory(const Trajectory &amp;trajectory, bool is_blocking=true)\n</code></pre> Item Description Function Execute a pre-planned joint trajectory. Parameters trajectory: Trajectory data structure containing waypoints and timingis_blocking: If true, blocks until trajectory execution completes. If false, returns immediately after trajectory is submitted. Return ControlStatus indicating success or failure of trajectory execution/submission"},{"location":"api_cpp_reference/#set_suction_cup_command","title":"set_suction_cup_command","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_suction_cup_command(JointGroup end_effector, bool activate)\n</code></pre> Item Description Function Control suction cup activation state. Parameters end_effector: JointGroup enumeration specifying which suction cup to controlactivate: If true, activates vacuum suction. If false, releases suction. Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#set_gripper_command","title":"set_gripper_command","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_gripper_command(JointGroup end_effector, double width_m, double velocity_mps=0.03, double effort=30, bool is_blocking=true)\n</code></pre> Item Description Function Control gripper opening width and force. Parameters end_effector: JointGroup enumeration specifying which gripper to controlwidth_m: Target gripper opening width in meters (m), measured between the inner surfaces of the gripper fingers.velocity_mps: Gripper closing/opening velocity in meters per second (m/s). Default: 0.03 m/s.effort: Maximum gripping force in Newton-meters (N\u00b7m). This limits the torque applied to prevent damage to grasped objects. Default: 30 N\u00b7m.is_blocking: If true, blocks until gripper reaches target position or times out. If false, returns immediately after command is sent. Return ControlStatus indicating success or failure of gripper command"},{"location":"api_cpp_reference/#get_gripper_state","title":"get_gripper_state","text":"<pre><code>std::shared_ptr&lt;GripperState&gt; galbot::sdk::g1::GalbotRobot::get_gripper_state(const JointGroup end_effector)\n</code></pre> Item Description Function Get current gripper state. Parameters end_effector: JointGroup enumeration specifying which gripper to query Return Shared pointer to GripperState, or nullptr if retrieval fails"},{"location":"api_cpp_reference/#get_suction_cup_state","title":"get_suction_cup_state","text":"<pre><code>std::shared_ptr&lt;SuctionCupState&gt; galbot::sdk::g1::GalbotRobot::get_suction_cup_state(const JointGroup end_effector)\n</code></pre> Item Description Function Get current suction cup state. Parameters end_effector: JointGroup enumeration specifying which suction cup to query Return Shared pointer to SuctionCupState, or nullptr if retrieval fails"},{"location":"api_cpp_reference/#get_joint_positions","title":"get_joint_positions","text":"<pre><code>std::vector&lt;double&gt; galbot::sdk::g1::GalbotRobot::get_joint_positions(const std::vector&lt; std::string &gt; &amp;joint_groups, const std::vector&lt; std::string &gt; &amp;joint_names)\n</code></pre> Item Description Function Get current joint positions by group name. Parameters joint_groups: Joint group names to query. Empty vector retrieves all body joints.joint_names: Specific joint names to query. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored. Return Vector of current joint angles in radians"},{"location":"api_cpp_reference/#get_joint_positions_1","title":"get_joint_positions","text":"<pre><code>std::vector&lt;double&gt; galbot::sdk::g1::GalbotRobot::get_joint_positions(const std::vector&lt; JointGroup &gt; &amp;joint_groups, const std::vector&lt; std::string &gt; &amp;joint_names={})\n</code></pre> Item Description Function Get current joint positions by group enumeration. Parameters joint_groups: JointGroup enumerations to query. Empty vector retrieves all body joints.joint_names: Specific joint names to query. This parameter takes precedence over joint_groups. When provided, joint_groups is ignored. Return Vector of current joint angles in radians"},{"location":"api_cpp_reference/#get_joint_group_names","title":"get_joint_group_names","text":"<pre><code>std::vector&lt;std::string&gt; galbot::sdk::g1::GalbotRobot::get_joint_group_names()\n</code></pre> Item Description Function Get available joint group names for the robot. Parameters None Return Vector of joint group names, or empty vector if retrieval fails"},{"location":"api_cpp_reference/#get_joint_names","title":"get_joint_names","text":"<pre><code>std::vector&lt;std::string&gt; galbot::sdk::g1::GalbotRobot::get_joint_names(bool only_active_joint=true, const std::vector&lt; std::string &gt; &amp;joint_groups={})\n</code></pre> Item Description Function Get robot joint names by group name. Parameters only_active_joint: If true, returns only actuated joints (excludes passive/fixed joints). If false, returns all joints including passive ones.joint_groups: Joint group names to query. Empty vector retrieves joints from all groups. Return Vector of joint names in kinematic chain order"},{"location":"api_cpp_reference/#get_joint_names_1","title":"get_joint_names","text":"<pre><code>std::vector&lt;std::string&gt; galbot::sdk::g1::GalbotRobot::get_joint_names(bool only_active_joint=true, const std::vector&lt; JointGroup &gt; &amp;joint_groups={})\n</code></pre> Item Description Function Get robot joint names by group enumeration. Parameters only_active_joint: If true, returns only actuated joints (excludes passive/fixed joints). If false, returns all joints including passive ones.joint_groups: JointGroup enumerations to query. Empty vector retrieves joints from all groups. Return Vector of joint names in kinematic chain order"},{"location":"api_cpp_reference/#get_joint_states","title":"get_joint_states","text":"<pre><code>std::vector&lt;JointState&gt; galbot::sdk::g1::GalbotRobot::get_joint_states(const std::vector&lt; std::string &gt; &amp;joint_group_vec, const std::vector&lt; std::string &gt; &amp;joint_names_vec={})\n</code></pre> Item Description Function Get real-time joint states by group name. Parameters joint_group_vec: Joint group names to query. Empty vector defaults to all body joints.joint_names_vec: Specific joint names to query. This parameter takes precedence over joint_group_vec. When provided, joint_group_vec is ignored. Return Vector of JointState structures containing current state for each joint"},{"location":"api_cpp_reference/#get_joint_states_1","title":"get_joint_states","text":"<pre><code>std::vector&lt;JointState&gt; galbot::sdk::g1::GalbotRobot::get_joint_states(const std::vector&lt; JointGroup &gt; &amp;joint_group, const std::vector&lt; std::string &gt; &amp;joint_names={})\n</code></pre> Item Description Function Get real-time joint states by group enumeration. Parameters joint_group: JointGroup enumerations to query. Empty vector defaults to all body joints.joint_names: Specific joint names to query. This parameter takes precedence over joint_group. When provided, joint_group is ignored. Return Vector of JointState structures containing current state for each joint"},{"location":"api_cpp_reference/#set_base_velocity","title":"set_base_velocity","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::set_base_velocity(const std::array&lt; double, 3 &gt; &amp;linear_velocity, const std::array&lt; double, 3 &gt; &amp;angular_velocity)\n</code></pre> Item Description Function Set mobile base velocity command. Parameters linear_velocity: Linear velocity in meters per second (m/s), expressed in base frame. Order: {vx, vy, vz} where: vx: forward/backward velocity (positive forward) vy: left/right velocity (positive left) vz: up/down velocity (typically 0 for ground robots)angular_velocity: Angular velocity in radians per second (rad/s), expressed in base frame. Order: {wx, wy, wz} where: wx: roll rate (rotation about x-axis) wy: pitch rate (rotation about y-axis) wz: yaw rate (rotation about z-axis, positive counter-clockwise) Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#stop_base","title":"stop_base","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::stop_base()\n</code></pre> Item Description Function Emergency stop mobile base movement. Parameters None Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#stop_trajectory_execution","title":"stop_trajectory_execution","text":"<pre><code>ControlStatus galbot::sdk::g1::GalbotRobot::stop_trajectory_execution()\n</code></pre> Item Description Function Stop all currently executing joint trajectories. Parameters None Return ControlStatus indicating success or failure of command transmission"},{"location":"api_cpp_reference/#get_imu_data","title":"get_imu_data","text":"<pre><code>std::shared_ptr&lt;ImuData&gt; galbot::sdk::g1::GalbotRobot::get_imu_data(SensorType imu_type)\n</code></pre> Item Description Function Get IMU (Inertial Measurement Unit) sensor data. Parameters imu_type: SensorType enumeration specifying which IMU to query Return Shared pointer to ImuData structure, or nullptr if sensor is not enabled or data retrieval fails"},{"location":"api_cpp_reference/#get_odom","title":"get_odom","text":"<pre><code>std::shared_ptr&lt;OdomData&gt; galbot::sdk::g1::GalbotRobot::get_odom()\n</code></pre> Item Description Function Get robot odometry information. Parameters None Return Shared pointer to OdomData containing: Position in meters (m) relative to odometry frame origin Orientation as quaternion Linear velocity in meters per second (m/s) Angular velocity in radians per second (rad/s) Timestamp in nanoseconds Returns nullptr if odometry is unavailable."},{"location":"api_cpp_reference/#get_rgb_data","title":"get_rgb_data","text":"<pre><code>std::shared_ptr&lt;RgbData&gt; galbot::sdk::g1::GalbotRobot::get_rgb_data(const SensorType rgb_camera)\n</code></pre> Item Description Function Get latest RGB image from specified camera. Parameters rgb_camera: SensorType enumeration specifying which RGB camera to query Return Shared pointer to RgbData containing image buffer, dimensions, encoding, and timestamp. Returns nullptr if camera is not enabled or data retrieval fails."},{"location":"api_cpp_reference/#get_depth_data","title":"get_depth_data","text":"<pre><code>std::shared_ptr&lt;DepthData&gt; galbot::sdk::g1::GalbotRobot::get_depth_data(const SensorType depth_camera)\n</code></pre> Item Description Function Get latest depth image from specified camera. Parameters depth_camera: SensorType enumeration specifying which depth camera to query Return Shared pointer to DepthData containing depth image buffer, dimensions, encoding, and timestamp. Returns nullptr if camera is not enabled or data retrieval fails."},{"location":"api_cpp_reference/#get_lidar_data","title":"get_lidar_data","text":"<pre><code>std::shared_ptr&lt;LidarData&gt; galbot::sdk::g1::GalbotRobot::get_lidar_data(const SensorType lidar)\n</code></pre> Item Description Function Get latest LiDAR point cloud data. Parameters lidar: SensorType enumeration specifying which LiDAR to query Return Shared pointer to LidarData (PointCloud2 format) containing point cloud with coordinates in meters (m) relative to the LiDAR frame. Returns nullptr if LiDAR is not enabled or data retrieval fails."},{"location":"api_cpp_reference/#get_ultrasonic_data","title":"get_ultrasonic_data","text":"<pre><code>std::shared_ptr&lt;UltrasonicData&gt; galbot::sdk::g1::GalbotRobot::get_ultrasonic_data(const UltrasonicType ultrasonic_type)\n</code></pre> Item Description Function Get distance measurement from specified ultrasonic sensor. Parameters ultrasonic_type: UltrasonicType enumeration specifying which ultrasonic sensor to query (one of 8 directional sensors) Return Shared pointer to UltrasonicData containing distance in meters (m), or nullptr if sensor is not enabled or data retrieval fails"},{"location":"api_cpp_reference/#get_transform","title":"get_transform","text":"<pre><code>std::pair&lt;std::vector&lt;double&gt;, int64_t&gt; galbot::sdk::g1::GalbotRobot::get_transform(const std::string &amp;target_frame, const std::string &amp;source_frame, int64_t timestamp_ns=0, int64_t timeout_ms=100)\n</code></pre> Item Description Function Query coordinate frame transformation (TF) Parameters target_frame: Name of the target coordinate frame (frame to transform into)source_frame: Name of the source coordinate frame (frame to transform from)timestamp_ns: Desired transform timestamp in nanoseconds. Pass 0 to get the most recent available transformation.timeout_ms: Maximum time to wait for the transform in milliseconds. Default: 100 milliseconds. Return Pair containing: Vector of 7 doubles representing the transform [x, y, z, qx, qy, qz, qw] where (x, y, z) is translation in meters and (qx, qy, qz, qw) is orientation quaternion Timestamp in nanoseconds when the transform was valid Returns empty vector and timestamp 0 if retrieval fails or times out."},{"location":"api_cpp_reference/#get_force_sensor_data","title":"get_force_sensor_data","text":"<pre><code>std::shared_ptr&lt;ForceData&gt; galbot::sdk::g1::GalbotRobot::get_force_sensor_data(const GalbotOneFoxtrotSensor sensor_type)\n</code></pre> Item Description Function Get force/torque sensor data. Parameters sensor_type: GalbotOneFoxtrotSensor enumeration specifying which force sensor to query Return Shared pointer to ForceData containing: Force vector in Newtons (N): [fx, fy, fz] Torque vector in Newton-meters (N\u00b7m): [tx, ty, tz] Timestamp in nanoseconds Returns nullptr if sensor is not enabled or data retrieval fails."},{"location":"api_cpp_reference/#is_running","title":"is_running","text":"<pre><code>bool galbot::sdk::g1::GalbotRobot::is_running()\n</code></pre> Item Description Function Check if the robot control system is running. Parameters None Return true if system is running normallyfalse if shutdown signal has been received and system is preparing to exit"},{"location":"api_cpp_reference/#request_shutdown","title":"request_shutdown","text":"<pre><code>void galbot::sdk::g1::GalbotRobot::request_shutdown()\n</code></pre> Item Description Function Request system shutdown. Parameters None Return None"},{"location":"api_cpp_reference/#wait_for_shutdown","title":"wait_for_shutdown","text":"<pre><code>void galbot::sdk::g1::GalbotRobot::wait_for_shutdown()\n</code></pre> Item Description Function Block until shutdown signal is received. Parameters None Return None"},{"location":"api_cpp_reference/#destroy","title":"destroy","text":"<pre><code>void galbot::sdk::g1::GalbotRobot::destroy()\n</code></pre> Item Description Function Clean up system resources. Parameters None Return None"},{"location":"api_cpp_reference/#register_exit_callback","title":"register_exit_callback","text":"<pre><code>void galbot::sdk::g1::GalbotRobot::register_exit_callback(std::function&lt; void()&gt; exit_function)\n</code></pre> Item Description Function Register callback function for shutdown event. Parameters exit_function: Callback function with signature void() to be executed during shutdown. Use this to perform application-specific cleanup (e.g., saving data, stopping threads). Return None"},{"location":"api_cpp_reference/#gripperstate-struct","title":"GripperState (struct)","text":"<p>Gripper state.Represents the current state of a parallel-jaw gripper, including opening width, motion status, and grasping force.</p>"},{"location":"api_cpp_reference/#member-variables_8","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t State timestamp (nanoseconds since epoch) width double Gripper opening width (meters), distance between fingers velocity double Gripper closing/opening velocity (meters/second), positive = opening effort double Gripper grasping force (Newtons), force applied by fingers is_moving bool Motion flag: true if gripper is currently moving, false if stationary joint_positions std::vector&lt; double &gt; Gripper joint positions (radians), typically 1-2 joints for finger actuators"},{"location":"api_cpp_reference/#header-struct","title":"Header (struct)","text":"<p>Message header structure.Standard message header containing timestamp and coordinate frame information. Compatible with ROS 2 std_msgs/Header format, used in sensor messages and transforms.</p>"},{"location":"api_cpp_reference/#member-variables_9","title":"Member Variables","text":"Name Type Description stamp Timestamp Timestamp of data acquisition.Records when the data was captured or generated. frame_id std::string Frame ID.Identifies the coordinate frame in which the data is expressed. Examples: \"base_link\", \"world\", \"camera_optical_frame\", \"lidar_link\", \"map\""},{"location":"api_cpp_reference/#iksolverconfig-struct","title":"IKSolverConfig (struct)","text":"<p>Inverse kinematics (IK) solver configuration parameters.This structure configures the numerical inverse kinematics solver used to compute joint configurations that achieve desired end-effector poses. It supports collision-aware IK with configurable seed strategies, convergence tolerances, joint limit handling, and timeout parameters.IK solving is an iterative numerical optimization process that may benefit from multiple random initializations to find feasible collision-free solutions.</p>"},{"location":"api_cpp_reference/#set_col_aware_ik_timeout","title":"set_col_aware_ik_timeout","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_col_aware_ik_timeout(double timeout)\n</code></pre> Item Description Function Set timeout for collision-aware IK solver. Parameters timeout: Maximum solver iteration time (units: ms) Return None"},{"location":"api_cpp_reference/#set_seed_type","title":"set_seed_type","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_seed_type(SeedType type)\n</code></pre> Item Description Function Set initial configuration seed generation strategy. Parameters type: Seed generation method for IK optimization initialization Return None"},{"location":"api_cpp_reference/#set_col_aware_ik_joint_limit_bias","title":"set_col_aware_ik_joint_limit_bias","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_col_aware_ik_joint_limit_bias(double bias)\n</code></pre> Item Description Function Set safety margin from joint position limits. Parameters bias: Distance from joint limits to treat as forbidden region (units: rad) Return None"},{"location":"api_cpp_reference/#set_translation_eps","title":"set_translation_eps","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_translation_eps(const std::array&lt; double, 3 &gt; &amp;eps)\n</code></pre> Item Description Function Set Cartesian position error tolerance for IK convergence. Parameters eps: Per-axis position error tolerance {x, y, z} (units: m) Return None"},{"location":"api_cpp_reference/#set_rotation_eps","title":"set_rotation_eps","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_rotation_eps(const std::array&lt; double, 3 &gt; &amp;eps)\n</code></pre> Item Description Function Set orientation error tolerance for IK convergence. Parameters eps: Per-axis orientation error tolerance {roll, pitch, yaw} (units: rad) Return None"},{"location":"api_cpp_reference/#set_enable_collision_check_log","title":"set_enable_collision_check_log","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::set_enable_collision_check_log(bool enable)\n</code></pre> Item Description Function Enable or disable detailed collision checking diagnostic logs. Parameters enable: true to output collision detection logs, false to suppress Return None"},{"location":"api_cpp_reference/#get_col_aware_ik_timeout","title":"get_col_aware_ik_timeout","text":"<pre><code>double galbot::sdk::g1::IKSolverConfig::get_col_aware_ik_timeout() const\n</code></pre> Item Description Function Get collision-aware IK solver timeout. Parameters None Return Timeout duration (units: ms)"},{"location":"api_cpp_reference/#get_seed_type","title":"get_seed_type","text":"<pre><code>SeedType galbot::sdk::g1::IKSolverConfig::get_seed_type() const\n</code></pre> Item Description Function Get IK solver seed generation strategy. Parameters None Return Current seed type"},{"location":"api_cpp_reference/#get_col_aware_ik_joint_limit_bias","title":"get_col_aware_ik_joint_limit_bias","text":"<pre><code>double galbot::sdk::g1::IKSolverConfig::get_col_aware_ik_joint_limit_bias() const\n</code></pre> Item Description Function Get joint limit safety margin. Parameters None Return Joint limit bias distance (units: rad)"},{"location":"api_cpp_reference/#get_translation_eps","title":"get_translation_eps","text":"<pre><code>const std::array&lt;double, 3&gt;&amp; galbot::sdk::g1::IKSolverConfig::get_translation_eps() const\n</code></pre> Item Description Function Get Cartesian position error tolerance. Parameters None Return Per-axis position tolerance {x, y, z} (units: m)"},{"location":"api_cpp_reference/#get_rotation_eps","title":"get_rotation_eps","text":"<pre><code>const std::array&lt;double, 3&gt;&amp; galbot::sdk::g1::IKSolverConfig::get_rotation_eps() const\n</code></pre> Item Description Function Get orientation error tolerance. Parameters None Return Per-axis orientation tolerance {roll, pitch, yaw} (units: rad)"},{"location":"api_cpp_reference/#get_enable_collision_check_log","title":"get_enable_collision_check_log","text":"<pre><code>bool galbot::sdk::g1::IKSolverConfig::get_enable_collision_check_log() const\n</code></pre> Item Description Function Check if collision check logging is enabled. Parameters None Return true if logging is enabled, false otherwise"},{"location":"api_cpp_reference/#print_1","title":"print","text":"<pre><code>void galbot::sdk::g1::IKSolverConfig::print() const\n</code></pre> Item Description Function Print IK solver configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#enums_1","title":"Enums","text":""},{"location":"api_cpp_reference/#seedtype-enum","title":"SeedType","text":"<p>Initial guess generation strategy for IK optimization.</p> Enum Value Description RANDOM_SEED Uniformly random joint configurations within limits RANDOM_PROGRESSIVE_SEED Progressive random sampling with increasing coverage USER_DEFINED_SEED User-provided initial joint configurations"},{"location":"api_cpp_reference/#imudata-struct","title":"ImuData (struct)","text":"<p>IMU data structure.Contains timestamped data from an Inertial Measurement Unit (IMU), including accelerometer, gyroscope, and magnetometer measurements.</p>"},{"location":"api_cpp_reference/#member-variables_10","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Measurement timestamp (nanoseconds since epoch) accel Vector3 Linear acceleration (meters/second\u00b2): [ax, ay, az] gyro Vector3 Angular velocity (radians/second): [\u03c9x, \u03c9y, \u03c9z] magnet Vector3 Magnetic field strength (micro-Tesla): [mx, my, mz]"},{"location":"api_cpp_reference/#jointcommand-struct","title":"JointCommand (struct)","text":"<p>Single joint control command.Specifies desired motion parameters for a single robot joint in a trajectory or control command.</p>"},{"location":"api_cpp_reference/#member-variables_11","title":"Member Variables","text":"Name Type Description position double Desired joint position (radians) velocity double Desired joint velocity (radians/second) acceleration double Desired joint acceleration (radians/second\u00b2) effort double Desired joint torque/effort (Newton-meters)"},{"location":"api_cpp_reference/#jointstate-struct","title":"JointState (struct)","text":"<p>Single joint state structure.Represents the complete real-time state of a single robot joint, including kinematic quantities (position, velocity, acceleration) and dynamic quantities (torque/effort and motor current).</p>"},{"location":"api_cpp_reference/#jointstate","title":"JointState","text":"<pre><code>galbot::sdk::g1::JointState::JointState()=default\n</code></pre> Item Description Function Default constructor. Parameters None Return None"},{"location":"api_cpp_reference/#jointstate_1","title":"JointState","text":"<pre><code>galbot::sdk::g1::JointState::JointState(double position_input, double velocity_input, double acceleration_input, double effort_input, double current_input)\n</code></pre> Item Description Function Parameterized constructor. Parameters position_input: Joint angular position (radians)velocity_input: Joint angular velocity (radians/second)acceleration_input: Joint angular acceleration (radians/second\u00b2)effort_input: Joint torque/effort (Newton-meters)current_input: Motor current (amperes) Return None"},{"location":"api_cpp_reference/#member-variables_12","title":"Member Variables","text":"Name Type Description position double Joint angular position (radians) velocity double Joint angular velocity (radians/second) acceleration double Joint angular acceleration (radians/second\u00b2) effort double Joint torque/effort (Newton-meters) current double Motor current (amperes)"},{"location":"api_cpp_reference/#jointstatemessage-struct","title":"JointStateMessage (struct)","text":"<p>Joint state message structure.Timestamped collection of joint states for multiple joints, typically representing a snapshot of the robot's complete joint configuration at one instant.</p>"},{"location":"api_cpp_reference/#member-variables_13","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Acquisition timestamp (nanoseconds since epoch) joint_state_vec std::vector&lt; JointState &gt; Vector of individual joint states"},{"location":"api_cpp_reference/#jointstates-class","title":"JointStates (class)","text":"<p>Joint-space target specification.Represents target joint configuration for a kinematic chain. Extends RobotStates to specify joint-based motion goals. Used in joint trajectory planning and forward kinematics computation.All joint angles must be in radians.Vector size must match the DOF of the specified kinematic chain.</p>"},{"location":"api_cpp_reference/#gettype","title":"getType","text":"<pre><code>Type galbot::sdk::g1::JointStates::getType() const override\n</code></pre> Item Description Function Get runtime type identifier. Parameters None Return Type::JOINT, indicating this is a joint-space target"},{"location":"api_cpp_reference/#set_joint_positions_2","title":"set_joint_positions","text":"<pre><code>void galbot::sdk::g1::JointStates::set_joint_positions(const std::vector&lt; double &gt; &amp;joints)\n</code></pre> Item Description Function Set complete joint configuration for the kinematic chain. Parameters joints: Vector of joint angles (radians), must match chain DOF Return None"},{"location":"api_cpp_reference/#set_joint","title":"set_joint","text":"<pre><code>void galbot::sdk::g1::JointStates::set_joint(int index, int val)\n</code></pre> Item Description Function Set individual joint angle by index. Parameters index: Zero-based joint index within the chainval: Joint angle value (radians) Return None"},{"location":"api_cpp_reference/#member-variables_14","title":"Member Variables","text":"Name Type Description joint_positions std::vector&lt; double &gt; Target joint configuration for the chain (radians), ordered by joint index."},{"location":"api_cpp_reference/#kinematicsboundary-struct","title":"KinematicsBoundary (struct)","text":"<p>Kinematic boundary parameters for robot kinematic chain joints.This structure defines the kinematic constraints for a robot kinematic chain (e.g., manipulator arms, mobile base, or leg chains). It specifies position, velocity, acceleration, and jerk limits for each joint in the chain.These boundaries are critical for ensuring safe and physically feasible motion during trajectory planning and execution. Each vector should contain one value per joint in the kinematic chain.All joint space quantities are specified in radians or radians per unit time.</p>"},{"location":"api_cpp_reference/#set_chain_name","title":"set_chain_name","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_chain_name(const std::string &amp;name)\n</code></pre> Item Description Function Set the name identifier for this kinematic chain. Parameters name: Chain name identifier, e.g., \"left_arm\", \"right_arm\", \"mobile_base\" Return None"},{"location":"api_cpp_reference/#set_lower_limit","title":"set_lower_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_lower_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint position lower bounds. Parameters limits: Vector of lower position limits for each joint (units: rad) Return None"},{"location":"api_cpp_reference/#set_upper_limit","title":"set_upper_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_upper_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint position upper bounds. Parameters limits: Vector of upper position limits for each joint (units: rad) Return None"},{"location":"api_cpp_reference/#set_vel_lower_limit","title":"set_vel_lower_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_vel_lower_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint velocity lower bounds. Parameters limits: Vector of lower velocity limits for each joint (units: rad/s) Return None"},{"location":"api_cpp_reference/#set_vel_upper_limit","title":"set_vel_upper_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_vel_upper_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint velocity upper bounds. Parameters limits: Vector of upper velocity limits for each joint (units: rad/s) Return None"},{"location":"api_cpp_reference/#set_acc_lower_limit","title":"set_acc_lower_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_acc_lower_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint acceleration lower bounds. Parameters limits: Vector of lower acceleration limits for each joint (units: rad/s\u00b2) Return None"},{"location":"api_cpp_reference/#set_acc_upper_limit","title":"set_acc_upper_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_acc_upper_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint acceleration upper bounds. Parameters limits: Vector of upper acceleration limits for each joint (units: rad/s\u00b2) Return None"},{"location":"api_cpp_reference/#set_jerk_lower_limit","title":"set_jerk_lower_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_jerk_lower_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint jerk lower bounds. Parameters limits: Vector of lower jerk limits for each joint (units: rad/s\u00b3) Return None"},{"location":"api_cpp_reference/#set_jerk_upper_limit","title":"set_jerk_upper_limit","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::set_jerk_upper_limit(const std::vector&lt; double &gt; &amp;limits)\n</code></pre> Item Description Function Set joint jerk upper bounds. Parameters limits: Vector of upper jerk limits for each joint (units: rad/s\u00b3) Return None"},{"location":"api_cpp_reference/#get_chain_name","title":"get_chain_name","text":"<pre><code>const std::string&amp; galbot::sdk::g1::KinematicsBoundary::get_chain_name() const\n</code></pre> Item Description Function Get the kinematic chain name identifier. Parameters None Return Const reference to chain name string"},{"location":"api_cpp_reference/#get_lower_limit","title":"get_lower_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_lower_limit() const\n</code></pre> Item Description Function Get joint position lower bounds. Parameters None Return Const reference to vector of lower position limits (units: rad)"},{"location":"api_cpp_reference/#get_upper_limit","title":"get_upper_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_upper_limit() const\n</code></pre> Item Description Function Get joint position upper bounds. Parameters None Return Const reference to vector of upper position limits (units: rad)"},{"location":"api_cpp_reference/#get_vel_lower_limit","title":"get_vel_lower_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_vel_lower_limit() const\n</code></pre> Item Description Function Get joint velocity lower bounds. Parameters None Return Const reference to vector of lower velocity limits (units: rad/s)"},{"location":"api_cpp_reference/#get_vel_upper_limit","title":"get_vel_upper_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_vel_upper_limit() const\n</code></pre> Item Description Function Get joint velocity upper bounds. Parameters None Return Const reference to vector of upper velocity limits (units: rad/s)"},{"location":"api_cpp_reference/#get_acc_lower_limit","title":"get_acc_lower_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_acc_lower_limit() const\n</code></pre> Item Description Function Get joint acceleration lower bounds. Parameters None Return Const reference to vector of lower acceleration limits (units: rad/s\u00b2)"},{"location":"api_cpp_reference/#get_acc_upper_limit","title":"get_acc_upper_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_acc_upper_limit() const\n</code></pre> Item Description Function Get joint acceleration upper bounds. Parameters None Return Const reference to vector of upper acceleration limits (units: rad/s\u00b2)"},{"location":"api_cpp_reference/#get_jerk_lower_limit","title":"get_jerk_lower_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_jerk_lower_limit() const\n</code></pre> Item Description Function Get joint jerk lower bounds. Parameters None Return Const reference to vector of lower jerk limits (units: rad/s\u00b3)"},{"location":"api_cpp_reference/#get_jerk_upper_limit","title":"get_jerk_upper_limit","text":"<pre><code>const std::vector&lt;double&gt;&amp; galbot::sdk::g1::KinematicsBoundary::get_jerk_upper_limit() const\n</code></pre> Item Description Function Get joint jerk upper bounds. Parameters None Return Const reference to vector of upper jerk limits (units: rad/s\u00b3)"},{"location":"api_cpp_reference/#print_2","title":"print","text":"<pre><code>void galbot::sdk::g1::KinematicsBoundary::print() const\n</code></pre> Item Description Function Print kinematic boundary information to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#lidardata-struct","title":"LidarData (struct)","text":"<p>Lidar data structure.Generic N-dimensional point cloud structure compatible with ROS 2 sensor_msgs/PointCloud2. Stores point data as a binary blob with field descriptors defining the data layout. Supports both ordered (structured) and unordered (unstructured) point clouds.</p>"},{"location":"api_cpp_reference/#member-variables_15","title":"Member Variables","text":"Name Type Description header Header Message header.Contains acquisition timestamp and coordinate frame for temporal and spatial reference. height uint32_t Point cloud height (rows)Unordered point cloud: height = 1 (single row)Ordered point cloud: height = number of rows (e.g., from spinning lidar or depth camera) width uint32_t Point cloud width (points per row)Unordered point cloud: width = total number of pointsOrdered point cloud: width = number of points per row (columns) Total points = height \u00d7 width fields std::vector&lt; PointField &gt; Field descriptors.Describes the data channels (x, y, z, intensity, rgb, etc.) present in each point and their binary layout (offset, type, count). is_bigendian bool Endianness flag.true: Data is Big Endian byte orderfalse: Data is Little Endian byte order (typical for x86/ARM systems) point_step uint32_t Point step (bytes per point)Total byte size of a single point structure, including all fields and padding. Must be \u2265 sum of all field sizes, may include alignment padding. row_step uint32_t Row step (bytes per row)Total byte size of one row of points. Formula: row_step = point_step \u00d7 width data std::vector&lt; uint8_t &gt; Point cloud binary data.Binary blob containing all point data in row-major order. Size should equal: row_step \u00d7 height bytes Each point occupies point_step bytes, laid out according to fields descriptors. is_dense bool Dense cloud flag.true: All points are valid, no NaN or Inf values presentfalse: Cloud may contain invalid points (NaN/Inf coordinates or fields)"},{"location":"api_cpp_reference/#linetrajcheckprimitive-struct","title":"LineTrajCheckPrimitive (struct)","text":"<p>Geometric primitive configuration for Cartesian linear trajectory validation.This structure configures the collision detection geometric representation for linear end-effector trajectories in Cartesian space. It supports two primitive types: infinitesimally thin lines and swept-volume cylinders.Choosing the appropriate primitive affects collision detection conservativeness and computational cost. Cylinder primitives model the robot's actual swept volume more accurately but require more expensive geometric queries.</p>"},{"location":"api_cpp_reference/#set_line_check_primitive_type","title":"set_line_check_primitive_type","text":"<pre><code>void galbot::sdk::g1::LineTrajCheckPrimitive::set_line_check_primitive_type(PrimitiveType type)\n</code></pre> Item Description Function Set geometric primitive type for linear trajectory validation. Parameters type: Primitive representation (LINE or CYLINDER) Return None"},{"location":"api_cpp_reference/#set_cylinder_prim_radius","title":"set_cylinder_prim_radius","text":"<pre><code>void galbot::sdk::g1::LineTrajCheckPrimitive::set_cylinder_prim_radius(double radius)\n</code></pre> Item Description Function Set swept-volume cylinder radius for trajectory collision checking. Parameters radius: Cylinder radius representing robot swept volume (units: m) Return None"},{"location":"api_cpp_reference/#set_line_prim_curvature","title":"set_line_prim_curvature","text":"<pre><code>void galbot::sdk::g1::LineTrajCheckPrimitive::set_line_prim_curvature(double curvature)\n</code></pre> Item Description Function Set curvature approximation tolerance for line primitive. Parameters curvature: Maximum deviation tolerance for piecewise-linear approximation (units: m) Return None"},{"location":"api_cpp_reference/#get_line_check_primitive_type","title":"get_line_check_primitive_type","text":"<pre><code>PrimitiveType galbot::sdk::g1::LineTrajCheckPrimitive::get_line_check_primitive_type() const\n</code></pre> Item Description Function Get the geometric primitive type for trajectory checking. Parameters None Return Current primitive type (LINE or CYLINDER)"},{"location":"api_cpp_reference/#get_cylinder_prim_radius","title":"get_cylinder_prim_radius","text":"<pre><code>double galbot::sdk::g1::LineTrajCheckPrimitive::get_cylinder_prim_radius() const\n</code></pre> Item Description Function Get the cylinder primitive swept-volume radius. Parameters None Return Cylinder radius (units: m)"},{"location":"api_cpp_reference/#get_line_prim_curvature","title":"get_line_prim_curvature","text":"<pre><code>double galbot::sdk::g1::LineTrajCheckPrimitive::get_line_prim_curvature() const\n</code></pre> Item Description Function Get the line primitive curvature approximation tolerance. Parameters None Return Curvature tolerance (units: m)"},{"location":"api_cpp_reference/#print_3","title":"print","text":"<pre><code>void galbot::sdk::g1::LineTrajCheckPrimitive::print() const\n</code></pre> Item Description Function Print line trajectory check primitive configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#enums_2","title":"Enums","text":""},{"location":"api_cpp_reference/#primitivetype-enum","title":"PrimitiveType","text":"<p>Geometric representation for linear trajectory collision checking.</p> Enum Value Description LINE Zero-thickness line segment (fast but less conservative) CYLINDER Swept-volume cylinder with configurable radius (accurate but slower)"},{"location":"api_cpp_reference/#motionplanconfig-class","title":"MotionPlanConfig (class)","text":"<p>Comprehensive motion planning configuration management.MotionPlanConfig serves as a centralized configuration container for all motion planning subsystems. It aggregates sampling strategies, trajectory generation parameters, inverse kinematics solver settings, collision detection options, feasibility validation criteria, and kinematic constraint boundaries.This class provides a unified interface for configuring complex motion planning pipelines, supporting both simple manipulator planning and whole-body humanoid motion generation with multiple kinematic chains.Configuration objects are lazily initialized and managed through shared pointers to optimize memory usage and support optional feature configuration.</p>"},{"location":"api_cpp_reference/#motionplanconfig","title":"MotionPlanConfig","text":"<pre><code>galbot::sdk::g1::MotionPlanConfig::MotionPlanConfig()=default\n</code></pre> Item Description Function Default constructor. Parameters None Return None"},{"location":"api_cpp_reference/#set_update_time","title":"set_update_time","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_update_time(int64_t t)\n</code></pre> Item Description Function Set configuration update timestamp. Parameters t: Timestamp of last configuration modification (units: ns, typically CLOCK_MONOTONIC) Return None"},{"location":"api_cpp_reference/#get_update_time","title":"get_update_time","text":"<pre><code>int64_t galbot::sdk::g1::MotionPlanConfig::get_update_time()\n</code></pre> Item Description Function Get configuration update timestamp. Parameters None Return Timestamp of last configuration modification (units: ns)"},{"location":"api_cpp_reference/#create_sampler_config","title":"create_sampler_config","text":"<pre><code>std::shared_ptr&lt;SamplerConfig&gt; galbot::sdk::g1::MotionPlanConfig::create_sampler_config()\n</code></pre> Item Description Function Create or retrieve sampler configuration. Parameters None Return Shared pointer to sampler configuration with default settings"},{"location":"api_cpp_reference/#create_trajectory_plan_config","title":"create_trajectory_plan_config","text":"<pre><code>std::shared_ptr&lt;TrajectoryPlanConfig&gt; galbot::sdk::g1::MotionPlanConfig::create_trajectory_plan_config()\n</code></pre> Item Description Function Create or retrieve trajectory planning configuration. Parameters None Return Shared pointer to trajectory planning configuration with default settings"},{"location":"api_cpp_reference/#create_ik_solver_config","title":"create_ik_solver_config","text":"<pre><code>std::shared_ptr&lt;IKSolverConfig&gt; galbot::sdk::g1::MotionPlanConfig::create_ik_solver_config()\n</code></pre> Item Description Function Create or retrieve inverse kinematics solver configuration. Parameters None Return Shared pointer to IK solver configuration with default settings"},{"location":"api_cpp_reference/#create_collision_check_option","title":"create_collision_check_option","text":"<pre><code>std::shared_ptr&lt;CollisionCheckOption&gt; galbot::sdk::g1::MotionPlanConfig::create_collision_check_option()\n</code></pre> Item Description Function Create or retrieve collision check option configuration. Parameters None Return Shared pointer to collision check options with default settings"},{"location":"api_cpp_reference/#create_trajectory_feasibility_check_option","title":"create_trajectory_feasibility_check_option","text":"<pre><code>std::shared_ptr&lt;TrajectoryFeasibilityCheckOption&gt; galbot::sdk::g1::MotionPlanConfig::create_trajectory_feasibility_check_option()\n</code></pre> Item Description Function Create or retrieve trajectory feasibility check option configuration. Parameters None Return Shared pointer to trajectory feasibility check options with default settings"},{"location":"api_cpp_reference/#create_line_traj_check_primitive","title":"create_line_traj_check_primitive","text":"<pre><code>std::shared_ptr&lt;LineTrajCheckPrimitive&gt; galbot::sdk::g1::MotionPlanConfig::create_line_traj_check_primitive()\n</code></pre> Item Description Function Create or retrieve line trajectory check primitive configuration. Parameters None Return Shared pointer to line trajectory check primitive with default settings"},{"location":"api_cpp_reference/#set_sampler_config","title":"set_sampler_config","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_sampler_config(const std::shared_ptr&lt; SamplerConfig &gt; &amp;config)\n</code></pre> Item Description Function Set or replace sampler configuration. Parameters config: Shared pointer to sampler configuration; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_trajectory_plan_config","title":"set_trajectory_plan_config","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_trajectory_plan_config(const std::shared_ptr&lt; TrajectoryPlanConfig &gt; &amp;config)\n</code></pre> Item Description Function Set or replace trajectory planning configuration. Parameters config: Shared pointer to trajectory planning configuration; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_ik_solver_config","title":"set_ik_solver_config","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_ik_solver_config(const std::shared_ptr&lt; IKSolverConfig &gt; &amp;config)\n</code></pre> Item Description Function Set or replace inverse kinematics solver configuration. Parameters config: Shared pointer to IK solver configuration; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_collision_check_option","title":"set_collision_check_option","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_collision_check_option(const std::shared_ptr&lt; CollisionCheckOption &gt; &amp;option)\n</code></pre> Item Description Function Set or replace collision check option configuration. Parameters option: Shared pointer to collision check options; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_trajectory_feasibility_check_option","title":"set_trajectory_feasibility_check_option","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_trajectory_feasibility_check_option(const std::shared_ptr&lt; TrajectoryFeasibilityCheckOption &gt; &amp;option)\n</code></pre> Item Description Function Set or replace trajectory feasibility check option configuration. Parameters option: Shared pointer to trajectory feasibility check options; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_feasibility_boundary","title":"set_feasibility_boundary","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_feasibility_boundary(const std::vector&lt; KinematicsBoundary &gt; &amp;boundary)\n</code></pre> Item Description Function Set kinematic feasibility boundaries for all chains. Parameters boundary: Vector of kinematic boundaries, one per chain Return None"},{"location":"api_cpp_reference/#set_line_traj_check_primitive","title":"set_line_traj_check_primitive","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_line_traj_check_primitive(const std::shared_ptr&lt; LineTrajCheckPrimitive &gt; &amp;primitive)\n</code></pre> Item Description Function Set or replace line trajectory check primitive configuration. Parameters primitive: Shared pointer to line trajectory check primitive; nullptr clears the configuration Return None"},{"location":"api_cpp_reference/#set_ik_joint_limit","title":"set_ik_joint_limit","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_ik_joint_limit(const std::vector&lt; KinematicsBoundary &gt; &amp;boundary)\n</code></pre> Item Description Function Set joint limits used during IK solving phase. Parameters boundary: Vector of kinematic boundaries for IK solver joint constraints Return None"},{"location":"api_cpp_reference/#set_sampler_joint_limit","title":"set_sampler_joint_limit","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_sampler_joint_limit(const std::vector&lt; KinematicsBoundary &gt; &amp;boundary)\n</code></pre> Item Description Function Set joint limits used during sampling-based planning phase. Parameters boundary: Vector of kinematic boundaries for sampling algorithms Return None"},{"location":"api_cpp_reference/#set_hard_joint_limit","title":"set_hard_joint_limit","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_hard_joint_limit(const std::vector&lt; KinematicsBoundary &gt; &amp;boundary)\n</code></pre> Item Description Function Set absolute hard joint limits (safety-critical boundaries) Parameters boundary: Vector of kinematic boundaries representing mechanical/safety limits Return None"},{"location":"api_cpp_reference/#set_revert_ik_joint_limit","title":"set_revert_ik_joint_limit","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_revert_ik_joint_limit(bool flag)\n</code></pre> Item Description Function Enable or disable IK joint limit reversion to hard limits. Parameters flag: true to revert IK joint limits to hard limits, false to use configured IK limits Return None"},{"location":"api_cpp_reference/#set_revert_ik_joint_limit_chains","title":"set_revert_ik_joint_limit_chains","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::set_revert_ik_joint_limit_chains(const std::vector&lt; std::string &gt; &amp;chains)\n</code></pre> Item Description Function Set specific kinematic chains for IK joint limit reversion. Parameters chains: Vector of chain names to apply IK limit reversion (e.g., {\"left_arm\", \"torso\"}) Return None"},{"location":"api_cpp_reference/#get_sampler_config","title":"get_sampler_config","text":"<pre><code>std::shared_ptr&lt;SamplerConfig&gt; galbot::sdk::g1::MotionPlanConfig::get_sampler_config() const\n</code></pre> Item Description Function Get sampler configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to sampler configuration, or nullptr if not set"},{"location":"api_cpp_reference/#get_trajectory_plan_config","title":"get_trajectory_plan_config","text":"<pre><code>std::shared_ptr&lt;TrajectoryPlanConfig&gt; galbot::sdk::g1::MotionPlanConfig::get_trajectory_plan_config() const\n</code></pre> Item Description Function Get trajectory planning configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to trajectory planning configuration, or nullptr if not set"},{"location":"api_cpp_reference/#get_ik_solver_config","title":"get_ik_solver_config","text":"<pre><code>std::shared_ptr&lt;IKSolverConfig&gt; galbot::sdk::g1::MotionPlanConfig::get_ik_solver_config() const\n</code></pre> Item Description Function Get inverse kinematics solver configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to IK solver configuration, or nullptr if not set"},{"location":"api_cpp_reference/#get_collision_check_option","title":"get_collision_check_option","text":"<pre><code>std::shared_ptr&lt;CollisionCheckOption&gt; galbot::sdk::g1::MotionPlanConfig::get_collision_check_option() const\n</code></pre> Item Description Function Get collision check option configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to collision check options, or nullptr if not set"},{"location":"api_cpp_reference/#get_trajectory_feasibility_check_option","title":"get_trajectory_feasibility_check_option","text":"<pre><code>std::shared_ptr&lt;TrajectoryFeasibilityCheckOption&gt; galbot::sdk::g1::MotionPlanConfig::get_trajectory_feasibility_check_option() const\n</code></pre> Item Description Function Get trajectory feasibility check option configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to trajectory feasibility check options, or nullptr if not set"},{"location":"api_cpp_reference/#get_line_traj_check_primitive","title":"get_line_traj_check_primitive","text":"<pre><code>std::shared_ptr&lt;LineTrajCheckPrimitive&gt; galbot::sdk::g1::MotionPlanConfig::get_line_traj_check_primitive() const\n</code></pre> Item Description Function Get line trajectory check primitive configuration (may be nullptr if not initialized) Parameters None Return Shared pointer to line trajectory check primitive, or nullptr if not set"},{"location":"api_cpp_reference/#get_sampler_config_ref","title":"get_sampler_config_ref","text":"<pre><code>SamplerConfig&amp; galbot::sdk::g1::MotionPlanConfig::get_sampler_config_ref()\n</code></pre> Item Description Function Get mutable reference to sampler configuration. Parameters None Return Mutable reference to sampler configuration (guaranteed non-null)"},{"location":"api_cpp_reference/#get_trajectory_plan_config_ref","title":"get_trajectory_plan_config_ref","text":"<pre><code>TrajectoryPlanConfig&amp; galbot::sdk::g1::MotionPlanConfig::get_trajectory_plan_config_ref()\n</code></pre> Item Description Function Get mutable reference to trajectory planning configuration. Parameters None Return Mutable reference to trajectory planning configuration (guaranteed non-null)"},{"location":"api_cpp_reference/#get_ik_solver_config_ref","title":"get_ik_solver_config_ref","text":"<pre><code>IKSolverConfig&amp; galbot::sdk::g1::MotionPlanConfig::get_ik_solver_config_ref()\n</code></pre> Item Description Function Get mutable reference to inverse kinematics solver configuration. Parameters None Return Mutable reference to IK solver configuration (guaranteed non-null)"},{"location":"api_cpp_reference/#get_collision_check_option_ref","title":"get_collision_check_option_ref","text":"<pre><code>CollisionCheckOption&amp; galbot::sdk::g1::MotionPlanConfig::get_collision_check_option_ref()\n</code></pre> Item Description Function Get mutable reference to collision check option configuration. Parameters None Return Mutable reference to collision check options (guaranteed non-null)"},{"location":"api_cpp_reference/#get_trajectory_feasibility_check_option_ref","title":"get_trajectory_feasibility_check_option_ref","text":"<pre><code>TrajectoryFeasibilityCheckOption&amp; galbot::sdk::g1::MotionPlanConfig::get_trajectory_feasibility_check_option_ref()\n</code></pre> Item Description Function Get mutable reference to trajectory feasibility check option configuration. Parameters None Return Mutable reference to trajectory feasibility check options (guaranteed non-null)"},{"location":"api_cpp_reference/#get_line_traj_check_primitive_ref","title":"get_line_traj_check_primitive_ref","text":"<pre><code>LineTrajCheckPrimitive&amp; galbot::sdk::g1::MotionPlanConfig::get_line_traj_check_primitive_ref()\n</code></pre> Item Description Function Get mutable reference to line trajectory check primitive configuration. Parameters None Return Mutable reference to line trajectory check primitive (guaranteed non-null)"},{"location":"api_cpp_reference/#get_feasibility_boundary","title":"get_feasibility_boundary","text":"<pre><code>const std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_feasibility_boundary() const\n</code></pre> Item Description Function Get kinematic feasibility boundaries for all chains (read-only) Parameters None Return Const reference to vector of kinematic feasibility boundaries"},{"location":"api_cpp_reference/#get_feasibility_boundary_1","title":"get_feasibility_boundary","text":"<pre><code>std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_feasibility_boundary()\n</code></pre> Item Description Function Get kinematic feasibility boundaries for all chains (mutable) Parameters None Return Mutable reference to vector of kinematic feasibility boundaries"},{"location":"api_cpp_reference/#get_ik_joint_limit","title":"get_ik_joint_limit","text":"<pre><code>const std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_ik_joint_limit() const\n</code></pre> Item Description Function Get IK phase joint limits (read-only) Parameters None Return Const reference to vector of IK joint limit boundaries"},{"location":"api_cpp_reference/#get_ik_joint_limit_1","title":"get_ik_joint_limit","text":"<pre><code>std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_ik_joint_limit()\n</code></pre> Item Description Function Get IK phase joint limits (mutable) Parameters None Return Mutable reference to vector of IK joint limit boundaries"},{"location":"api_cpp_reference/#get_sampler_joint_limit","title":"get_sampler_joint_limit","text":"<pre><code>const std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_sampler_joint_limit() const\n</code></pre> Item Description Function Get sampling phase joint limits (read-only) Parameters None Return Const reference to vector of sampling joint limit boundaries"},{"location":"api_cpp_reference/#get_sampler_joint_limit_1","title":"get_sampler_joint_limit","text":"<pre><code>std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_sampler_joint_limit()\n</code></pre> Item Description Function Get sampling phase joint limits (mutable) Parameters None Return Mutable reference to vector of sampling joint limit boundaries"},{"location":"api_cpp_reference/#get_hard_joint_limit","title":"get_hard_joint_limit","text":"<pre><code>const std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_hard_joint_limit() const\n</code></pre> Item Description Function Get hard joint limits (read-only) Parameters None Return Const reference to vector of hard joint limit boundaries"},{"location":"api_cpp_reference/#get_hard_joint_limit_1","title":"get_hard_joint_limit","text":"<pre><code>std::vector&lt;KinematicsBoundary&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_hard_joint_limit()\n</code></pre> Item Description Function Get hard joint limits (mutable) Parameters None Return Mutable reference to vector of hard joint limit boundaries"},{"location":"api_cpp_reference/#get_revert_ik_joint_limit_chains","title":"get_revert_ik_joint_limit_chains","text":"<pre><code>const std::vector&lt;std::string&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_revert_ik_joint_limit_chains() const\n</code></pre> Item Description Function Get kinematic chains for selective IK joint limit reversion (read-only) Parameters None Return Const reference to vector of chain names for IK limit reversion"},{"location":"api_cpp_reference/#get_revert_ik_joint_limit_chains_1","title":"get_revert_ik_joint_limit_chains","text":"<pre><code>std::vector&lt;std::string&gt;&amp; galbot::sdk::g1::MotionPlanConfig::get_revert_ik_joint_limit_chains()\n</code></pre> Item Description Function Get kinematic chains for selective IK joint limit reversion (mutable) Parameters None Return Mutable reference to vector of chain names for IK limit reversion"},{"location":"api_cpp_reference/#get_revert_ik_joint_limit","title":"get_revert_ik_joint_limit","text":"<pre><code>bool galbot::sdk::g1::MotionPlanConfig::get_revert_ik_joint_limit()\n</code></pre> Item Description Function Check if IK joint limit reversion is enabled. Parameters None Return true if IK limits should revert to hard limits, false otherwise"},{"location":"api_cpp_reference/#print_4","title":"print","text":"<pre><code>void galbot::sdk::g1::MotionPlanConfig::print() const\n</code></pre> Item Description Function Print comprehensive motion planning configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#odomdata-struct","title":"OdomData (struct)","text":"<p>Odometry data.Contains robot pose estimate from odometry sources (wheel encoders, visual odometry, etc.). Used for robot localization and navigation.</p>"},{"location":"api_cpp_reference/#member-variables_16","title":"Member Variables","text":"Name Type Description timestamp int64_t Odometry timestamp (seconds since epoch) position std::array&lt; double, 3 &gt; Position [x, y, z] (meters) orientation std::array&lt; double, 4 &gt; Orientation as quaternion [qx, qy, qz, qw]"},{"location":"api_cpp_reference/#parameter-class","title":"Parameter (class)","text":"<p>Motion planning parameter configuration class.This class extends PlannerConfig to provide comprehensive configuration options for whole-body motion planning and execution. It encapsulates execution mode, actuation type, tool frame handling, collision checking, and coordinate frame specifications.All angular parameters are expected in radians, linear parameters in meters (SI units).</p>"},{"location":"api_cpp_reference/#parameter","title":"Parameter","text":"<pre><code>galbot::sdk::g1::Parameter::Parameter()=default\n</code></pre> Item Description Function Default constructor. Parameters None Return None"},{"location":"api_cpp_reference/#parameter_1","title":"Parameter","text":"<pre><code>galbot::sdk::g1::Parameter::Parameter(bool direct_execute, bool blocking, double timeout, std::string actuate, bool tool_pose, bool check_collision, const std::string &amp;frame=\"base_link\")\n</code></pre> Item Description Function Parameterized constructor for whole-body motion planning configuration. Parameters direct_execute: If true, immediately executes the planned motion; if false, only computes the planblocking: If true, blocks until motion completes or times out; if false, returns immediatelytimeout: Maximum allowed time for motion execution (in seconds)actuate: Actuation type string key (see g_actuate_type_map): \"with_chain_only\", \"with_torso\", or \"with_leg\"tool_pose: If true, target pose is relative to tool frame; if false, relative to end-effector flangecheck_collision: If true, enables collision checking during planning; if false, skips collision detectionframe: Reference frame for pose specifications, defaults to \"base_link\" (robot base frame) Return None"},{"location":"api_cpp_reference/#setdirectexecute","title":"setDirectExecute","text":"<pre><code>void galbot::sdk::g1::Parameter::setDirectExecute(bool direct_execute)\n</code></pre> Item Description Function Set direct execution mode. Parameters direct_execute: If true, planned motion is immediately executed on the robot; if false, only computes the trajectory without execution Return None"},{"location":"api_cpp_reference/#setblocking","title":"setBlocking","text":"<pre><code>void galbot::sdk::g1::Parameter::setBlocking(bool blocking)\n</code></pre> Item Description Function Set blocking execution mode. Parameters blocking: If true, function blocks until motion completes or times out; if false, returns immediately after sending motion command Return None"},{"location":"api_cpp_reference/#settimeout","title":"setTimeout","text":"<pre><code>void galbot::sdk::g1::Parameter::setTimeout(double timeout)\n</code></pre> Item Description Function Set motion execution timeout. Parameters timeout: Maximum allowed time for motion execution (in seconds, must be positive) Return None"},{"location":"api_cpp_reference/#setactuate","title":"setActuate","text":"<pre><code>void galbot::sdk::g1::Parameter::setActuate(const std::string &amp;actuate)\n</code></pre> Item Description Function Set actuation type for whole-body coordination. Parameters actuate: Actuation type string key: \"with_chain_only\" (arms only), \"with_torso\" (arms + torso), or \"with_leg\" (arms + legs) Return None"},{"location":"api_cpp_reference/#settoolpose","title":"setToolPose","text":"<pre><code>void galbot::sdk::g1::Parameter::setToolPose(bool tool_pose)\n</code></pre> Item Description Function Set tool coordinate frame usage. Parameters tool_pose: If true, target poses are interpreted relative to the tool frame (TCP); if false, relative to the end-effector flange frame Return None"},{"location":"api_cpp_reference/#setcheckcollision","title":"setCheckCollision","text":"<pre><code>void galbot::sdk::g1::Parameter::setCheckCollision(bool check_collision)\n</code></pre> Item Description Function Enable or disable collision checking. Parameters check_collision: If true, planner performs collision detection against self-collisions and environment obstacles; if false, skips collision checking Return None"},{"location":"api_cpp_reference/#setreferenceframe","title":"setReferenceFrame","text":"<pre><code>void galbot::sdk::g1::Parameter::setReferenceFrame(const std::string &amp;frame)\n</code></pre> Item Description Function Set the reference frame for pose specifications. Parameters frame: Reference frame name (e.g., \"base_link\", \"world\", \"odom\") Return None"},{"location":"api_cpp_reference/#setmoveline","title":"setMoveLine","text":"<pre><code>void galbot::sdk::g1::Parameter::setMoveLine(bool flag)\n</code></pre> Item Description Function Set Cartesian linear motion mode. Parameters flag: If true, uses linear (straight-line) Cartesian motion; if false, uses joint-space interpolation (may result in curved end-effector paths) Return None"},{"location":"api_cpp_reference/#getdirectexecute","title":"getDirectExecute","text":"<pre><code>bool galbot::sdk::g1::Parameter::getDirectExecute() const\n</code></pre> Item Description Function Get direct execution mode status. Parameters None Return true if direct execution is enabled, false otherwise"},{"location":"api_cpp_reference/#getblocking","title":"getBlocking","text":"<pre><code>bool galbot::sdk::g1::Parameter::getBlocking() const\n</code></pre> Item Description Function Get blocking execution mode status. Parameters None Return true if blocking mode is enabled, false otherwise"},{"location":"api_cpp_reference/#gettimeout","title":"getTimeout","text":"<pre><code>double galbot::sdk::g1::Parameter::getTimeout() const\n</code></pre> Item Description Function Get motion execution timeout value. Parameters None Return Timeout duration in seconds (positive value)"},{"location":"api_cpp_reference/#getactuatetype","title":"getActuateType","text":"<pre><code>std::string galbot::sdk::g1::Parameter::getActuateType() const\n</code></pre> Item Description Function Get actuation type as string. Parameters None Return Actuation type string (\"with_chain_only\", \"with_torso\", \"with_leg\", or \"unknown\" if not found)"},{"location":"api_cpp_reference/#gettoolpose","title":"getToolPose","text":"<pre><code>bool galbot::sdk::g1::Parameter::getToolPose() const\n</code></pre> Item Description Function Get tool coordinate frame usage status. Parameters None Return true if using tool frame (TCP), false if using end-effector flange frame"},{"location":"api_cpp_reference/#getcheckcollision","title":"getCheckCollision","text":"<pre><code>bool galbot::sdk::g1::Parameter::getCheckCollision() const\n</code></pre> Item Description Function Get collision checking status. Parameters None Return true if collision checking is enabled, false otherwise"},{"location":"api_cpp_reference/#getreferenceframe","title":"getReferenceFrame","text":"<pre><code>std::string galbot::sdk::g1::Parameter::getReferenceFrame() const\n</code></pre> Item Description Function Get reference frame name. Parameters None Return Reference frame identifier string (e.g., \"base_link\", \"world\")"},{"location":"api_cpp_reference/#ismoveline","title":"isMoveLine","text":"<pre><code>bool galbot::sdk::g1::Parameter::isMoveLine()\n</code></pre> Item Description Function Check if Cartesian linear motion mode is enabled. Parameters None Return true if using linear Cartesian interpolation, false if using joint-space interpolation"},{"location":"api_cpp_reference/#plannerconfig-struct","title":"PlannerConfig (struct)","text":"<p>Motion planning configuration structure.Comprehensive configuration for robot motion planning and execution, controlling behavior such as planning mode, collision checking, reference frames, and execution parameters.</p>"},{"location":"api_cpp_reference/#member-variables_17","title":"Member Variables","text":"Name Type Description is_direct_execute bool Whether to execute trajectory immediately after planning.true: Plan and execute the trajectory in one operationfalse: Only plan the trajectory without executing (for preview or validation) is_blocking bool Whether to wait synchronously for operation completion.true: Block until planning/execution completes or timeout occursfalse: Return immediately after initiating operation (asynchronous mode) timeout_second double Timeout duration for blocking operations (seconds)Maximum time to wait for planning or execution completion when is_blocking = true. Default: 20 seconds actuate_type ActuateType Actuation mode specifying which kinematic chains to use.Determines whether to use only the target arm, or also involve torso/leg motion for extended workspace or mobile manipulation. is_tool_pose bool Whether target is specified as tool center point (TCP) pose.true: Target is end-effector TCP pose (Cartesian space)false: Target is joint space configuration is_relative_pose bool Whether target pose is relative to current pose.true: Target pose is relative displacement from current end-effector posefalse: Target pose is absolute in the specified reference frame is_check_collision bool Whether to enable collision checking during planning.true: Check collisions with obstacles and self-collisionsfalse: Disable collision checking (use with caution) reference_frame std::string Reference coordinate frame for target pose.Specifies the coordinate frame in which target poses are expressed. Common values: \"base_link\", \"world\", \"odom\" joint_state std::unordered_map&lt; JointGroup, std::vector&lt; double &gt; &gt; Initial joint state for planning.Specifies starting joint configuration for planning. If empty, uses current robot state. Key: Joint group identifier Value: Vector of joint angles (radians) for that group move_line bool Whether to plan Cartesian linear path.true: Plan straight-line motion in Cartesian space (end-effector moves in straight line)false: Plan standard joint-space or task-space trajectory (may not be Cartesian linear)"},{"location":"api_cpp_reference/#plantaskresult-struct","title":"PlanTaskResult (struct)","text":"<p>Planning task result structure.Contains the complete result of a motion planning operation, including success status, generated trajectory, kinematics solutions, and collision information.</p>"},{"location":"api_cpp_reference/#member-variables_18","title":"Member Variables","text":"Name Type Description task_id std::string Unique task identifier.Used to track and distinguish different planning tasks, especially in asynchronous operations. success bool Success flag.true: Planning completed successfullyfalse: Planning failed (check error_code and error_message for details) error_code int Numerical error code.Used for programmatic error handling. Zero typically indicates success, non-zero values indicate specific error conditions. error_message std::string Human-readable error message.Provides detailed description of failure reason or exception information when success = false. trajectory struct galbot::sdk::g1::PlanTaskResult::Trajectory None ik_result std::unordered_map&lt; std::string, std::vector&lt; double &gt; &gt; Inverse kinematics solution.Maps kinematic chain name to solved joint configuration (radians). Key: Joint chain name (e.g., \"left_arm\", \"right_arm\") Value: Vector of joint angles (radians) fk_result std::unordered_map&lt; std::string, Pose &gt; Forward kinematics solution.Maps link or end-effector name to computed pose. Key: Link or end-effector name (e.g., \"left_gripper\", \"right_hand\") Value: Computed pose (position + orientation) collision_result std::vector&lt; double &gt; Collision detection result.Optional field containing collision distances or penetration depths. Empty vector typically means no collision check was performed. Non-empty values may represent minimum distances to obstacles or collision severity."},{"location":"api_cpp_reference/#point-struct","title":"Point (struct)","text":"<p>3D pointRepresents a position in three-dimensional Cartesian space.</p>"},{"location":"api_cpp_reference/#member-variables_19","title":"Member Variables","text":"Name Type Description x double X coordinate (meters) y double Y coordinate (meters) z double Z coordinate (meters)"},{"location":"api_cpp_reference/#pointfield-struct","title":"PointField (struct)","text":"<p>Point cloud field descriptor.Describes one data field in a PointCloud2 point structure, defining its name, type, offset, and count. Compatible with ROS 2 sensor_msgs/PointField.</p>"},{"location":"api_cpp_reference/#member-variables_20","title":"Member Variables","text":"Name Type Description name std::string Field name.Identifier for this data channel. Standard field names include:\"x\", \"y\", \"z\": 3D Cartesian coordinates (meters)\"intensity\": Reflection intensity (unitless or sensor-specific)\"rgb\" or \"rgba\": Color information (packed RGB or RGBA)\"ring\": Lidar ring/laser index (integer)\"timestamp\": Per-point timestamp (seconds or nanoseconds) offset uint32_t Byte offset from point start.Byte offset of this field from the beginning of a point's data structure. Example: For point layout {x:float32, y:float32, z:float32}, offsets are: x=0, y=4, z=8 datatype DataType Data type of this field.Specifies the primitive data type using the DataType enumeration. count uint32_t Number of elements in this field.Array length for this field. Typically 1 for scalar fields (x, y, z, intensity). May be &gt; 1 for array fields (e.g., count=3 for a 3-element vector)."},{"location":"api_cpp_reference/#enums_3","title":"Enums","text":""},{"location":"api_cpp_reference/#datatype-enum","title":"DataType","text":"<p>Data type enumeration.Defines primitive data types for point cloud fields, determining byte size and interpretation method for each field value.</p> Enum Value Description UNKNOWN Unknown or unspecified type INT8 8-bit signed integer (1 byte) UINT8 8-bit unsigned integer (1 byte) INT16 16-bit signed integer (2 bytes) UINT16 16-bit unsigned integer (2 bytes) INT32 32-bit signed integer (4 bytes) UINT32 32-bit unsigned integer (4 bytes) FLOAT32 32-bit IEEE 754 floating point (4 bytes) FLOAT64 64-bit IEEE 754 floating point (8 bytes)"},{"location":"api_cpp_reference/#pose-struct","title":"Pose (struct)","text":"<p>Pose (position + orientation) structure.Represents a full 6-DOF (Degrees of Freedom) pose in 3D space, combining position (translation) and orientation (rotation) information. Commonly used for robot end-effector poses, object poses, and coordinate frame transforms.</p>"},{"location":"api_cpp_reference/#pose","title":"Pose","text":"<pre><code>galbot::sdk::g1::Pose::Pose()=default\n</code></pre> Item Description Function Default constructor. Parameters None Return None"},{"location":"api_cpp_reference/#pose_1","title":"Pose","text":"<pre><code>galbot::sdk::g1::Pose::Pose(const T &amp;pos, const T &amp;quat)\n</code></pre> Item Description Function Initialize Pose using separate position and quaternion containers. Parameters pos: 3D position vector [x, y, z] in meters, must have size 3quat: Quaternion vector [x, y, z, w], must have size 4 Return None"},{"location":"api_cpp_reference/#pose_2","title":"Pose","text":"<pre><code>galbot::sdk::g1::Pose::Pose(const T &amp;vec)\n</code></pre> Item Description Function Initialize Pose using a single 7-dimensional vector. Parameters vec: 7D vector: [x, y, z, qx, qy, qz, qw] where first 3 elements are position (meters) and last 4 elements are quaternion Return None"},{"location":"api_cpp_reference/#member-variables_21","title":"Member Variables","text":"Name Type Description position Point Position in 3D space (x, y, z) in meters orientation Quaternion Orientation as unit quaternion (x, y, z, w)"},{"location":"api_cpp_reference/#posestate-class","title":"PoseState (class)","text":"<p>Cartesian pose target specification.Represents a target end-effector pose in Cartesian space (SE(3)). Extends RobotStates to specify pose-based motion goals for kinematic chains. Used in inverse kinematics and Cartesian trajectory planning.Pose values: position in meters, orientation as unit quaternion.Coordinate frames must exist in the robot's TF tree.</p>"},{"location":"api_cpp_reference/#gettype_1","title":"getType","text":"<pre><code>Type galbot::sdk::g1::PoseState::getType() const override\n</code></pre> Item Description Function Get runtime type identifier. Parameters None Return Type::POSE, indicating this is a Cartesian pose target"},{"location":"api_cpp_reference/#member-variables_22","title":"Member Variables","text":"Name Type Description frame_id std::string Target frame on the kinematic chain (e.g., \"EndEffector\", \"Camera\", \"TCP\") reference_frame std::string Reference coordinate frame (e.g., \"base_link\", \"world\", \"odom\") pose Pose Target Cartesian pose: position (meters) + orientation (unit quaternion)"},{"location":"api_cpp_reference/#quaternion-struct","title":"Quaternion (struct)","text":"<p>Quaternion.Represents a 3D rotation using quaternion representation (x, y, z, w). A unit quaternion has magnitude 1 and represents a valid rotation.</p>"},{"location":"api_cpp_reference/#member-variables_23","title":"Member Variables","text":"Name Type Description x double X component of the quaternion vector part y double Y component of the quaternion vector part z double Z component of the quaternion vector part w double W component, scalar part (for identity rotation, w=1 and x=y=z=0)"},{"location":"api_cpp_reference/#regionofinterest-struct","title":"RegionOfInterest (struct)","text":"<p>Region of interest (ROI)Defines a rectangular sub-region within an image for selective processing. Compatible with ROS 2 sensor_msgs/RegionOfInterest.</p>"},{"location":"api_cpp_reference/#member-variables_24","title":"Member Variables","text":"Name Type Description x_offset uint32_t X offset (left edge)Horizontal pixel coordinate of the ROI's left edge. 0 means ROI starts at the image's left edge. y_offset uint32_t Y offset (top edge)Vertical pixel coordinate of the ROI's top edge. 0 means ROI starts at the image's top edge. height uint32_t ROI height (pixels)Number of pixel rows in the region of interest. width uint32_t ROI width (pixels)Number of pixel columns in the region of interest. do_rectify bool Rectification flag.true: Apply camera rectification to this ROI before processingfalse: Use raw image data without rectification, or capture full resolution"},{"location":"api_cpp_reference/#rgbdata-struct","title":"RgbData (struct)","text":"<p>RGB/color image data structure.Contains compressed color image data from RGB cameras. Compatible with ROS 2 sensor_msgs/CompressedImage format.</p>"},{"location":"api_cpp_reference/#convert_to_cv2_mat_1","title":"convert_to_cv2_mat","text":"<pre><code>std::shared_ptr&lt;cv::Mat&gt; galbot::sdk::g1::RgbData::convert_to_cv2_mat()\n</code></pre> Item Description Function Decode compressed image data to OpenCV Mat. Parameters None Return std::shared_ptr Smart pointer to decoded image on success, nullptr on failure"},{"location":"api_cpp_reference/#member-variables_25","title":"Member Variables","text":"Name Type Description header Header Message header.Contains acquisition timestamp and camera coordinate frame ID. format std::string Image format descriptor.Specifies compression format and encoding. Examples: \"jpeg\", \"png\", \"bgr8; jpeg compressed bgr8\" data std::vector&lt; uint8_t &gt; Compressed image data.Binary blob containing the compressed image (JPEG, PNG, etc.)."},{"location":"api_cpp_reference/#robotstates-class","title":"RobotStates (class)","text":"<p>Robot kinematic state representation.Encapsulates the complete kinematic state of the robot, including whole-body joint configuration and mobile base pose. This class serves as a base for more specialized state representations (PoseState, JointStates) and is used throughout the planning and control pipeline for state specification and feedback.All angular values are in radians, linear values in meters (SI units).Base pose uses quaternion representation for orientation (x, y, z, qx, qy, qz, qw).</p>"},{"location":"api_cpp_reference/#gettype_2","title":"getType","text":"<pre><code>virtual Type galbot::sdk::g1::RobotStates::getType() const\n</code></pre> Item Description Function Get the runtime type of this state object. Parameters None Return Type enumeration value, ROBOT_STATES for base class"},{"location":"api_cpp_reference/#robotstates","title":"RobotStates","text":"<pre><code>galbot::sdk::g1::RobotStates::RobotStates()=default\n</code></pre> Item Description Function Default constructor. Parameters None Return None"},{"location":"api_cpp_reference/#setwholebodyjoint","title":"setWholeBodyJoint","text":"<pre><code>void galbot::sdk::g1::RobotStates::setWholeBodyJoint(const std::vector&lt; double &gt; &amp;joint_positions)\n</code></pre> Item Description Function Set complete whole-body joint configuration. Parameters joint_positions: Vector of joint angles (in radians), must match robot DOF Return None"},{"location":"api_cpp_reference/#setbasestate","title":"setBaseState","text":"<pre><code>void galbot::sdk::g1::RobotStates::setBaseState(const Pose &amp;base_pose)\n</code></pre> Item Description Function Set mobile base pose. Parameters base_pose: Base pose in SE(3): position (meters) and orientation (quaternion) Return None"},{"location":"api_cpp_reference/#robotstates_1","title":"RobotStates","text":"<pre><code>galbot::sdk::g1::RobotStates::RobotStates(const std::string &amp;chain, const std::vector&lt; double &gt; &amp;whole_joint, const Pose &amp;base_pose)\n</code></pre> Item Description Function Parameterized constructor for complete robot state initialization. Parameters chain: Kinematic chain name (e.g., \"left_arm\", \"right_arm\")whole_joint: Complete joint configuration vector (radians)base_pose: Mobile base pose: position (meters) + orientation (unit quaternion) Return None"},{"location":"api_cpp_reference/#member-variables_26","title":"Member Variables","text":"Name Type Description chain_name std::string Kinematic chain identifier (e.g., \"left_arm\", \"right_arm\") whole_body_joint std::vector&lt; double &gt; Complete robot joint configuration (radians), ordered by joint index. base_state std::vector&lt; double &gt; Mobile base pose: [x, y, z, qx, qy, qz, qw] (meters, quaternion)"},{"location":"api_cpp_reference/#enums_4","title":"Enums","text":""},{"location":"api_cpp_reference/#type-enum","title":"Type","text":"<p>Enumeration for distinguishing derived state types.Used for runtime type identification of RobotStates-derived classes.</p> Enum Value Description POSE PoseState: Cartesian pose target. JOINT JointStates: Joint space target. ROBOT_STATES RobotStates: Generic whole-body state."},{"location":"api_cpp_reference/#samplerconfig-struct","title":"SamplerConfig (struct)","text":"<p>Configuration parameters for sampling-based motion planners.This structure configures sampling-based planning algorithms (e.g., RRT, RRT*). It controls state space sampling resolution, interpolation settings, path simplification, and planning termination conditions.Sampling-based planners explore the configuration space by randomly sampling states and connecting them to build a motion plan graph.</p>"},{"location":"api_cpp_reference/#set_state_check_type","title":"set_state_check_type","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_state_check_type(StateCheckType type)\n</code></pre> Item Description Function Set the distance metric for state comparison. Parameters type: Distance metric type for evaluating state similarity Return None"},{"location":"api_cpp_reference/#set_state_check_resolution","title":"set_state_check_resolution","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_state_check_resolution(double resolution)\n</code></pre> Item Description Function Set state comparison resolution threshold. Parameters resolution: Minimum distance threshold to consider two states as distinct (units: rad or dimensionless) Return None"},{"location":"api_cpp_reference/#set_interpolate","title":"set_interpolate","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_interpolate(bool enable)\n</code></pre> Item Description Function Enable or disable path interpolation between sampled states. Parameters enable: true to enable interpolation, false to use only sampled waypoints Return None"},{"location":"api_cpp_reference/#set_interpolation_cnt","title":"set_interpolation_cnt","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_interpolation_cnt(int cnt)\n</code></pre> Item Description Function Set the number of interpolation waypoints between consecutive samples. Parameters cnt: Number of intermediate waypoints to insert (0 = use automatic calculation) Return None"},{"location":"api_cpp_reference/#set_simplify","title":"set_simplify","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_simplify(bool enable)\n</code></pre> Item Description Function Enable or disable path simplification post-processing. Parameters enable: true to enable path shortcutting and smoothing, false to use raw planned path Return None"},{"location":"api_cpp_reference/#set_max_simplification_time","title":"set_max_simplification_time","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_max_simplification_time(double time)\n</code></pre> Item Description Function Set maximum time budget for path simplification. Parameters time: Maximum simplification duration (units: s); negative values indicate no time limit Return None"},{"location":"api_cpp_reference/#set_termination_condition_type","title":"set_termination_condition_type","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_termination_condition_type(TerminationConditionType type)\n</code></pre> Item Description Function Set planning termination condition. Parameters type: Termination criterion (timeout only vs. timeout or exact solution) Return None"},{"location":"api_cpp_reference/#set_max_planning_time","title":"set_max_planning_time","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::set_max_planning_time(double time)\n</code></pre> Item Description Function Set maximum time budget for motion planning. Parameters time: Maximum planning duration (units: s) Return None"},{"location":"api_cpp_reference/#get_state_check_type","title":"get_state_check_type","text":"<pre><code>StateCheckType galbot::sdk::g1::SamplerConfig::get_state_check_type() const\n</code></pre> Item Description Function Get the configured distance metric for state comparison. Parameters None Return Current state check type"},{"location":"api_cpp_reference/#get_state_check_resolution","title":"get_state_check_resolution","text":"<pre><code>double galbot::sdk::g1::SamplerConfig::get_state_check_resolution() const\n</code></pre> Item Description Function Get state comparison resolution threshold. Parameters None Return Resolution value (units: rad or dimensionless, depending on state check type)"},{"location":"api_cpp_reference/#get_interpolate","title":"get_interpolate","text":"<pre><code>bool galbot::sdk::g1::SamplerConfig::get_interpolate() const\n</code></pre> Item Description Function Check if path interpolation is enabled. Parameters None Return true if interpolation is enabled, false otherwise"},{"location":"api_cpp_reference/#get_interpolation_cnt","title":"get_interpolation_cnt","text":"<pre><code>int galbot::sdk::g1::SamplerConfig::get_interpolation_cnt() const\n</code></pre> Item Description Function Get the number of interpolation waypoints. Parameters None Return Number of intermediate waypoints between samples"},{"location":"api_cpp_reference/#get_simplify","title":"get_simplify","text":"<pre><code>bool galbot::sdk::g1::SamplerConfig::get_simplify() const\n</code></pre> Item Description Function Check if path simplification is enabled. Parameters None Return true if path simplification is enabled, false otherwise"},{"location":"api_cpp_reference/#get_max_simplification_time","title":"get_max_simplification_time","text":"<pre><code>double galbot::sdk::g1::SamplerConfig::get_max_simplification_time() const\n</code></pre> Item Description Function Get maximum path simplification time budget. Parameters None Return Maximum simplification time (units: s); negative values indicate no limit"},{"location":"api_cpp_reference/#get_termination_condition_type","title":"get_termination_condition_type","text":"<pre><code>TerminationConditionType galbot::sdk::g1::SamplerConfig::get_termination_condition_type() const\n</code></pre> Item Description Function Get planning termination condition. Parameters None Return Current termination condition type"},{"location":"api_cpp_reference/#get_max_planning_time","title":"get_max_planning_time","text":"<pre><code>double galbot::sdk::g1::SamplerConfig::get_max_planning_time() const\n</code></pre> Item Description Function Get maximum planning time budget. Parameters None Return Maximum planning time (units: s)"},{"location":"api_cpp_reference/#print_5","title":"print","text":"<pre><code>void galbot::sdk::g1::SamplerConfig::print() const\n</code></pre> Item Description Function Print sampler configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#enums_5","title":"Enums","text":""},{"location":"api_cpp_reference/#statechecktype-enum","title":"StateCheckType","text":"<p>Distance metric for comparing states in configuration space.</p> Enum Value Description EUCLIDEAN_DISTANCE Cartesian Euclidean distance in joint space (treats joint angles as Cartesian coordinates) RADIAN_DISTANCE Angular distance metric accounting for joint angle wraparound and weighting"},{"location":"api_cpp_reference/#terminationconditiontype-enum","title":"TerminationConditionType","text":"<p>Planning termination criteria.</p> Enum Value Description TIMEOUT Terminate only when maximum planning time is exceeded TIMEOUT_AND_EXACT_SOLUTION Terminate when timeout occurs OR exact goal solution is found"},{"location":"api_cpp_reference/#suctioncupstate-struct","title":"SuctionCupState (struct)","text":"<p>Suction cup state.Contains the current state of a vacuum suction cup gripper, including activation status, pressure reading, and action state.</p>"},{"location":"api_cpp_reference/#member-variables_27","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t State timestamp (nanoseconds since epoch) activation bool Activation flag: true if vacuum is on, false if off pressure double Current vacuum pressure (Pascals), typically negative for suction action_state SUCTION_ACTION_STATE Current suction action state"},{"location":"api_cpp_reference/#timestamp-struct","title":"Timestamp (struct)","text":"<p>Timestamp structure.Represents high-precision time points with second and nanosecond components. Compatible with ROS 2 builtin_interfaces/Time and std_msgs/Header timestamp format.</p>"},{"location":"api_cpp_reference/#member-variables_28","title":"Member Variables","text":"Name Type Description sec int64_t Seconds component.Number of seconds since UNIX Epoch (1970-01-01 00:00:00 UTC). nanosec uint32_t Nanoseconds component.Nanosecond portion within the current second. Valid range: [0, 999,999,999] (&lt; 1 second)"},{"location":"api_cpp_reference/#trajectory-struct","title":"Trajectory (struct)","text":"<p>Trajectory result.Contains the complete planned trajectory with joint positions and timing information.</p>"},{"location":"api_cpp_reference/#member-variables_29","title":"Member Variables","text":"Name Type Description joint_positions std::vector&lt; std::vector&lt; double &gt; &gt; Joint positions at each waypoint.Each element is a vector of joint angles (radians) representing robot configuration at one waypoint. Inner vector size = number of joints, outer vector size = number of waypoints. timestamps std::vector&lt; double &gt; Timestamps for each waypoint (seconds)Cumulative time from trajectory start. Size must match joint_positions size."},{"location":"api_cpp_reference/#trajectory-struct","title":"Trajectory (struct)","text":"<p>Joint trajectory.Represents a complete robot trajectory consisting of multiple waypoints over time.</p>"},{"location":"api_cpp_reference/#member-variables_30","title":"Member Variables","text":"Name Type Description points std::vector&lt; TrajectoryPoint &gt; Ordered list of trajectory waypoints joint_groups std::vector&lt; std::string &gt; Names of joint groups involved in this trajectory joint_names std::vector&lt; std::string &gt; Names of individual joints controlled by this trajectory"},{"location":"api_cpp_reference/#trajectoryfeasibilitycheckoption-struct","title":"TrajectoryFeasibilityCheckOption (struct)","text":"<p>Trajectory validation and feasibility checking configuration.This structure provides fine-grained control over which feasibility constraints are enforced during trajectory validation. It supports independent toggling of collision detection, joint limit compliance, and velocity profile feasibility.Selectively disabling checks can improve computational performance for debugging, simulation, or scenarios where certain constraints are guaranteed to be satisfied.Disabling feasibility checks may produce trajectories that are unsafe or physically unrealizable. Use with caution and only when constraints are verified through other means.</p>"},{"location":"api_cpp_reference/#set_disable_collision_check","title":"set_disable_collision_check","text":"<pre><code>void galbot::sdk::g1::TrajectoryFeasibilityCheckOption::set_disable_collision_check(bool disable)\n</code></pre> Item Description Function Enable or disable collision detection during trajectory validation. Parameters disable: true to skip collision checking, false to enforce collision-free trajectories Return None"},{"location":"api_cpp_reference/#set_disable_joint_limit_check","title":"set_disable_joint_limit_check","text":"<pre><code>void galbot::sdk::g1::TrajectoryFeasibilityCheckOption::set_disable_joint_limit_check(bool disable)\n</code></pre> Item Description Function Enable or disable joint limit compliance checking. Parameters disable: true to skip joint limit validation, false to enforce position limits Return None"},{"location":"api_cpp_reference/#set_disable_velocity_feasibility_check","title":"set_disable_velocity_feasibility_check","text":"<pre><code>void galbot::sdk::g1::TrajectoryFeasibilityCheckOption::set_disable_velocity_feasibility_check(bool disable)\n</code></pre> Item Description Function Enable or disable velocity profile feasibility checking. Parameters disable: true to skip velocity limit validation, false to enforce velocity constraints Return None"},{"location":"api_cpp_reference/#get_disable_collision_check","title":"get_disable_collision_check","text":"<pre><code>bool galbot::sdk::g1::TrajectoryFeasibilityCheckOption::get_disable_collision_check() const\n</code></pre> Item Description Function Check if collision detection is disabled. Parameters None Return true if collision checking is currently disabled, false if enabled"},{"location":"api_cpp_reference/#get_disable_joint_limit_check","title":"get_disable_joint_limit_check","text":"<pre><code>bool galbot::sdk::g1::TrajectoryFeasibilityCheckOption::get_disable_joint_limit_check() const\n</code></pre> Item Description Function Check if joint limit checking is disabled. Parameters None Return true if joint limit validation is currently disabled, false if enabled"},{"location":"api_cpp_reference/#get_disable_velocity_feasibility_check","title":"get_disable_velocity_feasibility_check","text":"<pre><code>bool galbot::sdk::g1::TrajectoryFeasibilityCheckOption::get_disable_velocity_feasibility_check() const\n</code></pre> Item Description Function Check if velocity feasibility checking is disabled. Parameters None Return true if velocity validation is currently disabled, false if enabled"},{"location":"api_cpp_reference/#print_6","title":"print","text":"<pre><code>void galbot::sdk::g1::TrajectoryFeasibilityCheckOption::print() const\n</code></pre> Item Description Function Print trajectory feasibility check configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#trajectoryplanconfig-struct","title":"TrajectoryPlanConfig (struct)","text":"<p>Trajectory planning and parameterization configuration.This structure configures trajectory generation parameters for converting discrete motion plans into smooth, time-parameterized trajectories. It supports both single-segment and multi-waypoint trajectory planning.Trajectory planning involves computing velocity and acceleration profiles along a geometric path while respecting kinematic constraints.</p>"},{"location":"api_cpp_reference/#set_min_move_time","title":"set_min_move_time","text":"<pre><code>void galbot::sdk::g1::TrajectoryPlanConfig::set_min_move_time(double time)\n</code></pre> Item Description Function Set minimum duration for any motion segment. Parameters time: Minimum trajectory execution time (units: s) Return None"},{"location":"api_cpp_reference/#set_move_line_intermediate_point","title":"set_move_line_intermediate_point","text":"<pre><code>void galbot::sdk::g1::TrajectoryPlanConfig::set_move_line_intermediate_point(double value)\n</code></pre> Item Description Function Set waypoint density for Cartesian linear motion interpolation. Parameters value: Number of intermediate waypoints for linear path segments (dimensionless) Return None"},{"location":"api_cpp_reference/#set_way_point_plan_expected_time","title":"set_way_point_plan_expected_time","text":"<pre><code>void galbot::sdk::g1::TrajectoryPlanConfig::set_way_point_plan_expected_time(double time)\n</code></pre> Item Description Function Set expected total duration for multi-waypoint trajectory planning. Parameters time: Expected trajectory execution time for waypoint sequences (units: s) Return None"},{"location":"api_cpp_reference/#get_min_move_time","title":"get_min_move_time","text":"<pre><code>double galbot::sdk::g1::TrajectoryPlanConfig::get_min_move_time() const\n</code></pre> Item Description Function Get minimum motion segment duration. Parameters None Return Minimum movement time (units: s)"},{"location":"api_cpp_reference/#get_move_line_intermediate_point","title":"get_move_line_intermediate_point","text":"<pre><code>double galbot::sdk::g1::TrajectoryPlanConfig::get_move_line_intermediate_point() const\n</code></pre> Item Description Function Get waypoint density for linear motion interpolation. Parameters None Return Number of intermediate waypoints (dimensionless)"},{"location":"api_cpp_reference/#get_way_point_plan_expected_time","title":"get_way_point_plan_expected_time","text":"<pre><code>double galbot::sdk::g1::TrajectoryPlanConfig::get_way_point_plan_expected_time() const\n</code></pre> Item Description Function Get expected multi-waypoint trajectory duration. Parameters None Return Expected planning time (units: s)"},{"location":"api_cpp_reference/#print_7","title":"print","text":"<pre><code>void galbot::sdk::g1::TrajectoryPlanConfig::print() const\n</code></pre> Item Description Function Print trajectory planning configuration to standard output. Parameters None Return None"},{"location":"api_cpp_reference/#trajectorypoint-struct","title":"TrajectoryPoint (struct)","text":"<p>Single trajectory point.Represents a waypoint in a robot trajectory, specifying joint states at a particular time.</p>"},{"location":"api_cpp_reference/#member-variables_31","title":"Member Variables","text":"Name Type Description time_from_start_second double Time from trajectory start (seconds) joint_command_vec std::vector&lt; JointCommand &gt; List of joint commands for all joints at this waypoint"},{"location":"api_cpp_reference/#transformmessage-struct","title":"TransformMessage (struct)","text":"<p>Transform message structure.Represents a timestamped coordinate frame transformation, consisting of translation and rotation. Commonly used for TF (Transform) trees in robotics.</p>"},{"location":"api_cpp_reference/#member-variables_32","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Transform timestamp (nanoseconds since epoch) translation Point Translation vector (meters) rotation Quaternion Rotation as unit quaternion (x, y, z, w)"},{"location":"api_cpp_reference/#ultrasonicdata-struct","title":"UltrasonicData (struct)","text":"<p>Ultrasonic sensor data structure.Contains a single ultrasonic distance measurement with timestamp.</p>"},{"location":"api_cpp_reference/#member-variables_33","title":"Member Variables","text":"Name Type Description timestamp_ns int64_t Measurement timestamp in nanoseconds since epoch distance double Measured distance to nearest obstacle (meters)"},{"location":"api_cpp_reference/#vector3-struct","title":"Vector3 (struct)","text":"<p>3D vector structureRepresents a three-dimensional vector, used for forces, torques, velocities, accelerations, and other vectorial quantities.</p>"},{"location":"api_cpp_reference/#member-variables_34","title":"Member Variables","text":"Name Type Description x double X component y double Y component z double Z component"},{"location":"api_python_reference/","title":"Python API \u53c2\u8003","text":""},{"location":"api_python_reference/#g1","title":"g1","text":"<p>Motion Plan Configuration module</p>"},{"location":"api_python_reference/#g1-classes","title":"Classes","text":""},{"location":"api_python_reference/#g1.ControlStatus","title":"ControlStatus","text":"<pre><code>ControlStatus(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>SUCCESS : Execution successful</p> <p>TIMEOUT : Execution timeout</p> <p>FAULT : Fault occurred, cannot continue execution</p> <p>INVALID_INPUT : Input parameters do not meet requirements</p> <p>INIT_FAILED : Internal communication component creation failed</p> <p>IN_PROGRESS : Motion in progress but not reached target</p> <p>STOPPED_UNREACHED : Stopped but not reached target</p> <p>DATA_FETCH_FAILED : Data fetch failed</p> <p>PUBLISH_FAIL : Data sending failed</p> <p>COMM_DISCONNECTED : Connection failed</p>"},{"location":"api_python_reference/#g1.DepthData","title":"DepthData","text":"<pre><code>DepthData()\n</code></pre> <p>Depth image data</p>"},{"location":"api_python_reference/#g1.DepthData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.DepthData.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: list[int]\n</code></pre> <p>Compressed depth data</p>"},{"location":"api_python_reference/#g1.DepthData.depth_scale","title":"depth_scale  <code>property</code> <code>writable</code>","text":"<pre><code>depth_scale: int\n</code></pre> <p>Depth scale/quantization factor</p>"},{"location":"api_python_reference/#g1.DepthData.format","title":"format  <code>property</code> <code>writable</code>","text":"<pre><code>format: str\n</code></pre> <p>Image format</p>"},{"location":"api_python_reference/#g1.DepthData.header","title":"header  <code>property</code> <code>writable</code>","text":"<pre><code>header: Header\n</code></pre> <p>Message header</p>"},{"location":"api_python_reference/#g1.DepthData.height","title":"height  <code>property</code> <code>writable</code>","text":"<pre><code>height: int\n</code></pre> <p>Image height</p>"},{"location":"api_python_reference/#g1.DepthData.width","title":"width  <code>property</code> <code>writable</code>","text":"<pre><code>width: int\n</code></pre> <p>Image width</p>"},{"location":"api_python_reference/#g1.ForceData","title":"ForceData","text":"<pre><code>ForceData()\n</code></pre> <p>Force sensor data</p>"},{"location":"api_python_reference/#g1.ForceData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.ForceData.force","title":"force  <code>property</code> <code>writable</code>","text":"<pre><code>force: Vector3\n</code></pre> <p>Force vector Vector3</p>"},{"location":"api_python_reference/#g1.ForceData.timestamp_ns","title":"timestamp_ns  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp_ns: int\n</code></pre> <p>Timestamp (nanoseconds)</p>"},{"location":"api_python_reference/#g1.ForceData.torque","title":"torque  <code>property</code> <code>writable</code>","text":"<pre><code>torque: Vector3\n</code></pre> <p>Torque vector Vector3</p>"},{"location":"api_python_reference/#g1.GalbotMotion","title":"GalbotMotion","text":""},{"location":"api_python_reference/#g1.GalbotMotion-functions","title":"Functions","text":""},{"location":"api_python_reference/#g1.GalbotMotion.get_instance","title":"get_instance  <code>staticmethod</code>","text":"<pre><code>get_instance() -&gt; GalbotMotion\n</code></pre> <p>Get the singleton instance of GalbotMotion.</p> <p>Returns:</p> Name Type Description <code>GalbotMotion</code> <code>GalbotMotion</code> <p>The singleton instance of GalbotMotion.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.add_obstacle","title":"add_obstacle","text":"<pre><code>add_obstacle(obstacle_id: str, obstacle_type: str, pose: collections.abc.Sequence[typing.SupportsFloat], scale: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], 'FixedSize(3)'] = [0.0, 0.0, 0.0], key: str = '', target_frame: str = 'world', ee_frame: str = 'ee_base', reference_joint_positions: collections.abc.Sequence[typing.SupportsFloat] = [], reference_base_pose: collections.abc.Sequence[typing.SupportsFloat] = [], ignore_collision_link_names: collections.abc.Sequence[str] = [], safe_margin: typing.SupportsFloat = 0.0, resolution: typing.SupportsFloat = 0.01) -&gt; MotionStatus\n</code></pre> <p>Add an obstacle to the robot's collision detection system.</p> <p>Parameters:</p> Name Type Description Default <code>obstacle_id</code> <code>str</code> <p>Unique ID for the obstacle (cannot be duplicated)</p> required <code>obstacle_type</code> <code>str</code> <p>Obstacle type. Options: box / sphere / cylinder / mesh / point_cloud / depth_image</p> required <code>pose</code> <code>list[float]</code> <p>Position and orientation of the obstacle. Length 7: [x, y, z, qx, qy, qz, qw]</p> required <code>scale</code> <code>tuple[float]</code> <p>Geometric size of the obstacle     <code>box: length / width / height (l / w / h)</code> /      <code>sphere: radius / - / -</code> /     <code>cylinder: radius / height / -</code></p> <code>[0.0, 0.0, 0.0]</code> <code>key</code> <code>str</code> <p>key for the obstacle.      <code>mesh / point_cloud: file path</code> /     <code>depth_image: camera type (front_head / left_arm / right_arm)</code></p> <code>''</code> <code>target_frame</code> <code>str</code> <p>Target coordinate frame. Options: world / base_link / motion chain name</p> <code>'world'</code> <code>ee_frame</code> <code>str</code> <p>End-effector coordinate frame. Only effective when target_frame is a motion chain name</p> <code>'ee_base'</code> <code>reference_joint_positions</code> <code>list[float]</code> <p>Robot joint state when loading obstacle. If empty, current joint state is used</p> <code>[]</code> <code>reference_base_pose</code> <code>list[float]</code> <p>Robot base pose in map coordinate frame. If empty, current base pose is used</p> <code>[]</code> <code>ignore_collision_link_names</code> <code>list[str]</code> <p>List of robot link names to ignore in collision detection</p> <code>[]</code> <code>safe_margin</code> <code>float</code> <p>Safe distance to obstacle. Collision is detected when obstacle distance is less than this value</p> <code>0.0</code> <code>resolution</code> <code>float</code> <p>Loading precision for some obstacle types. Defaults to 0.01</p> <code>0.01</code> <p>Returns:</p> Name Type Description <code>MotionStatus</code> <code>MotionStatus</code> <p>Result of adding the obstacle</p>"},{"location":"api_python_reference/#g1.GalbotMotion.attach_target_object","title":"attach_target_object","text":"<pre><code>attach_target_object(obstacle_id: str, obstacle_type: str, pose: collections.abc.Sequence[typing.SupportsFloat], scale: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], 'FixedSize(3)'] = [0.0, 0.0, 0.0], key: str = '', target_frame: str = 'world', ee_frame: str = 'ee_base', reference_joint_positions: collections.abc.Sequence[typing.SupportsFloat] = [], reference_base_pose: collections.abc.Sequence[typing.SupportsFloat] = [], ignore_collision_link_names: collections.abc.Sequence[str] = [], safe_margin: typing.SupportsFloat = 0.0, resolution: typing.SupportsFloat = 0.01) -&gt; MotionStatus\n</code></pre> <p>Add an obstacle to the robot's collision detection system.</p> Notes <ul> <li>GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.</li> <li>Obstacle inputs here are treated as manual environment setup for collision checking.</li> <li>For obstacle_type == \"point_cloud\", <code>key</code> is typically a point cloud file path provided by the user.</li> <li>For obstacle_type == \"depth_image\", the camera type selects a depth source captured/loaded for the collision world; it is not a continuous real-time perception stream for motion planning.</li> </ul> <p>Parameters:      obstacle_id (str): Unique ID for the obstacle (cannot repeat)      obstacle_type (str): Type of obstacle (box/sphere/cylinder/mesh/point_cloud/depth_image)      pose (list[float]): Position and orientation of the obstacle (length 7: xyz+quat)      scale (tuple[float]): Geometry size (box: l/w/h; sphere: r/-/-; cylinder: r/h/-)      key (str): File path (mesh/point_cloud) or camera type (depth_image: front_head/left_arm/right_arm)      target_frame (str): Target coordinate frame (world/base_link/chain name)      ee_frame (str): End-effector frame (only valid if target_frame is a chain)      reference_joint_positions (list[float]): Robot joint state when loading obstacle (current if empty)      reference_base_pose (list[float]): Robot base pose in map frame (current if empty)      ignore_collision_link_names (list[str]): Links to ignore collision with      safe_margin (float): Safe distance (collision if &lt; this value)      resolution (float): Loading precision for some obstacle types</p> <p>Returns:      MotionStatus: Result of adding obstacle</p>"},{"location":"api_python_reference/#g1.GalbotMotion.attach_tool","title":"attach_tool","text":"<pre><code>attach_tool(chain: str, tool: str) -&gt; MotionStatus\n</code></pre> <p>Attach a tool to the specified robot motion chain (left_arm / right_arm).</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>str</code> <p>The robot motion chain.</p> required <code>tool</code> <code>str</code> <p>The tool to attach.</p> required <code>params</code> <code>dict</code> <p>Additional parameters for the tool attachment. Defaults to default_param.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>MotionStatus</code> <p>True if the tool attachment is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.check_collision","title":"check_collision","text":"<pre><code>check_collision(start: collections.abc.Sequence[RobotStates], enable_collision_check: bool = True, params: Parameter = ...) -&gt; tuple[MotionStatus, list[bool]]\n</code></pre> <p>Check collision between robot and environment.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>RobotStates</code> <p>The robot states.</p> required <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>params</code> <code>dict</code> <p>Additional parameters for the collision checking. Defaults to default_param.</p> <code>...</code> Notes <ul> <li>GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.</li> <li>The environment for collision checking is the set of obstacles you manually load via add_obstacle()   and attach_target_object().</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <code>tuple[MotionStatus, list[bool]]</code> <p>True if there is a collision, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.clear_obstacle","title":"clear_obstacle","text":"<pre><code>clear_obstacle() -&gt; MotionStatus\n</code></pre> <p>Remove all loaded obstacles</p>"},{"location":"api_python_reference/#g1.GalbotMotion.detach_target_object","title":"detach_target_object","text":"<pre><code>detach_target_object(obstacle_id: str) -&gt; MotionStatus\n</code></pre> <p>Remove the specified obstacle by ID</p>"},{"location":"api_python_reference/#g1.GalbotMotion.detach_tool","title":"detach_tool","text":"<pre><code>detach_tool(chain: str) -&gt; MotionStatus\n</code></pre> <p>Detach a tool from the specified robot motion chain (left_arm / right_arm).</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>str</code> <p>The robot motion chain.</p> required <code>params</code> <code>dict</code> <p>Additional parameters for the tool detachment. Defaults to default_param.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>MotionStatus</code> <p>True if the tool detachment is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.forward_kinematics","title":"forward_kinematics","text":"<pre><code>forward_kinematics(target_frame: str, reference_frame: str = 'base_link', joint_state: collections.abc.Mapping[str, collections.abc.Sequence[typing.SupportsFloat]] = {}, params: Parameter = ...) -&gt; tuple[MotionStatus, list[float]]\n</code></pre> <p>Perform forward kinematics to compute the pose of a target frame.</p> <p>Parameters:</p> Name Type Description Default <code>target_frame</code> <code>str</code> <p>The name of the target frame.</p> required <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <code>joint_state</code> <code>dict</code> <p>A dictionary mapping joint names to their positions. Defaults to an empty dictionary.</p> <code>{}</code> <code>params</code> <code>dict</code> <p>Additional parameters for the forward kinematics. Defaults to default_param.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>Pose</code> <code>tuple[MotionStatus, list[float]]</code> <p>The computed pose of the target frame.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.forward_kinematics_by_state","title":"forward_kinematics_by_state","text":"<pre><code>forward_kinematics_by_state(target_frame: str, reference_robot_states: RobotStates = None, reference_frame: str = 'base_link', params: Parameter = ...) -&gt; tuple[MotionStatus, list[float]]\n</code></pre> <p>Perform forward kinematics to compute the pose of a target frame.</p> <p>Parameters:</p> Name Type Description Default <code>target_frame</code> <code>str</code> <p>The name of the target frame.</p> required <code>reference_robot_states</code> <code>RobotStates</code> <p>The reference robot states. Defaults to nullptr.</p> <code>None</code> <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <code>params</code> <code>dict</code> <p>Additional parameters for the forward kinematics. Defaults to default_param.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>Pose</code> <code>tuple[MotionStatus, list[float]]</code> <p>The computed pose of the target frame.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_built_obstacles_list","title":"get_built_obstacles_list","text":"<pre><code>get_built_obstacles_list() -&gt; list[str]\n</code></pre> <p>Get the list of built obstacles.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_end_effector_pose","title":"get_end_effector_pose","text":"<pre><code>get_end_effector_pose(end_effector_frame: str, reference_frame: str = 'base_link') -&gt; tuple[MotionStatus, list[float]]\n</code></pre> <p>Get the pose of a specified end-effector frame.</p> <p>Parameters:</p> Name Type Description Default <code>end_effector_frame</code> <code>str</code> <p>The name of the end-effector frame.</p> required <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <p>Returns:</p> Name Type Description <code>Pose</code> <code>tuple[MotionStatus, list[float]]</code> <p>The computed pose of the end-effector frame.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_end_effector_pose_on_chain","title":"get_end_effector_pose_on_chain","text":"<pre><code>get_end_effector_pose_on_chain(chain_name: str, frame_id: str = 'EndEffector', reference_frame: str = 'base_link') -&gt; tuple[MotionStatus, list[float]]\n</code></pre> <p>Get the pose of a specified end-effector frame on a given chain.</p> <p>Parameters:</p> Name Type Description Default <code>chain_name</code> <code>str</code> <p>The name of the chain.</p> required <code>frame_id</code> <code>str</code> <p>The name of the end-effector frame. Defaults to \"EndEffector\".</p> <code>'EndEffector'</code> <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <p>Returns:</p> Name Type Description <code>Pose</code> <code>tuple[MotionStatus, list[float]]</code> <p>The computed pose of the end-effector frame on the specified chain.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_motion_plan_config","title":"get_motion_plan_config","text":"<pre><code>get_motion_plan_config() -&gt; tuple[MotionStatus, MotionPlanConfig]\n</code></pre> <p>get motion config</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_chains","title":"get_supported_chains","text":"<pre><code>get_supported_chains() -&gt; set[str]\n</code></pre> <p>Get the list of supported links.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_ee_frames","title":"get_supported_ee_frames","text":"<pre><code>get_supported_ee_frames() -&gt; set[str]\n</code></pre> <p>Get the list of supported end-effector frames.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_frames","title":"get_supported_frames","text":"<pre><code>get_supported_frames() -&gt; set[str]\n</code></pre> <p>Get the list of supported reference frames.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_links","title":"get_supported_links","text":"<pre><code>get_supported_links() -&gt; set[str]\n</code></pre> <p>Initialize system interface dependencies.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_obstacle_types","title":"get_supported_obstacle_types","text":"<pre><code>get_supported_obstacle_types() -&gt; set[str]\n</code></pre> <p>Get the list of supported obstacle types.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.get_supported_tool_list","title":"get_supported_tool_list","text":"<pre><code>get_supported_tool_list() -&gt; set[str]\n</code></pre> <p>Get the list of supported tools.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.init","title":"init","text":"<pre><code>init() -&gt; bool\n</code></pre> <p>Initialize the system interface dependencies.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialization is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.inverse_kinematics","title":"inverse_kinematics","text":"<pre><code>inverse_kinematics(target_pose: collections.abc.Sequence[typing.SupportsFloat], chain_names: collections.abc.Sequence[str], target_frame: str = 'EndEffector', reference_frame: str = 'base_link', initial_joint_positions: collections.abc.Mapping[str, collections.abc.Sequence[typing.SupportsFloat]] = {}, enable_collision_check: bool = True, params: Parameter = ...) -&gt; tuple[MotionStatus, dict[str, list[float]]]\n</code></pre> <p>Perform inverse kinematics to compute the joint positions for a target pose.</p> <p>Parameters:</p> Name Type Description Default <code>target_pose</code> <code>Pose</code> <p>The target pose.</p> required <code>chain_names</code> <code>list of str</code> <p>The list of chain names to consider.</p> required <code>target_frame</code> <code>str</code> <p>The name of the target frame. Defaults to \"EndEffector\".</p> <code>'EndEffector'</code> <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <code>initial_joint_positions</code> <code>dict</code> <p>A dictionary mapping joint names to their initial positions. Defaults to an empty dictionary.</p> <code>{}</code> <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>params</code> <code>dict</code> <p>Additional parameters for the inverse kinematics. Defaults to default_param.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>tuple[MotionStatus, dict[str, list[float]]]</code> <p>A dictionary mapping joint names to their computed positions.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.inverse_kinematics_by_state","title":"inverse_kinematics_by_state","text":"<pre><code>inverse_kinematics_by_state(target_pose: collections.abc.Sequence[typing.SupportsFloat], chain_names: collections.abc.Sequence[str], target_frame: str = 'EndEffector', reference_frame: str = 'base_link', reference_robot_states: RobotStates = None, enable_collision_check: bool = True, params: Parameter = ...) -&gt; tuple[MotionStatus, dict[str, list[float]]]\n</code></pre> <p>Perform inverse kinematics to compute the joint positions for a target pose.</p> <p>Parameters:</p> Name Type Description Default <code>target_pose</code> <code>Pose</code> <p>The target pose.</p> required <code>chain_names</code> <code>list of str</code> <p>The list of chain names to consider.</p> required <code>target_frame</code> <code>str</code> <p>The name of the target frame. Defaults to \"EndEffector\".</p> <code>'EndEffector'</code> <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <code>reference_robot_states</code> <code>RobotStates</code> <p>The reference robot states. Defaults to nullptr.</p> <code>None</code> <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>params</code> <code>dict</code> <p>Additional parameters for the inverse kinematics. Defaults to default_param.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>tuple[MotionStatus, dict[str, list[float]]]</code> <p>A dictionary mapping joint names to their computed positions.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.motion_plan","title":"motion_plan","text":"<pre><code>motion_plan(target: RobotStates, start: RobotStates = None, reference_robot_states: RobotStates = None, enable_collision_check: bool = True, params: Parameter = ...) -&gt; tuple[MotionStatus, dict[str, list[list[float]]]]\n</code></pre> <p>Plan a motion to a single waypoint.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Pose</code> <p>The target pose.</p> required <code>start</code> <code>RobotStates</code> <p>The initial robot states. Defaults to nullptr.</p> <code>None</code> <code>reference_robot_states</code> <code>RobotStates</code> <p>The reference robot states. Defaults to nullptr.</p> <code>None</code> <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>params</code> <code>dict</code> <p>Additional parameters for the motion planning. Defaults to default_param.</p> <code>...</code> Notes <ul> <li>GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.</li> <li>If collision checking is enabled, collisions are checked against self-collision and obstacles that you     manually load via add_obstacle()/attach_target_object().</li> <li>In contrast, the Navigation module (GalbotNavigation) may use real-time perception/avoidance depending     on deployment; this is not currently integrated into GalbotMotion.</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <code>tuple[MotionStatus, dict[str, list[list[float]]]]</code> <p>True if the motion planning is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.motion_plan_multi_waypoints","title":"motion_plan_multi_waypoints","text":"<pre><code>motion_plan_multi_waypoints(targets: collections.abc.Mapping[RobotStates, collections.abc.Sequence[collections.abc.Sequence[typing.SupportsFloat]]], start: collections.abc.Sequence[RobotStates] = [], reference_robot_states: RobotStates = None, enable_collision_check: bool = True, params: Parameter = ...) -&gt; tuple[MotionStatus, dict[str, list[list[float]]]]\n</code></pre> <p>Plan a motion to multiple waypoints.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>dict of Pose</code> <p>The target poses.</p> required <code>waypoint_poses</code> <code>list of list of float</code> <p>The waypoint poses.</p> required <code>start</code> <code>RobotStates</code> <p>The initial robot states. Defaults to nullptr.</p> <code>[]</code> <code>reference_robot_states</code> <code>RobotStates</code> <p>The reference robot states. Defaults to nullptr.</p> <code>None</code> <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>params</code> <code>dict</code> <p>Additional parameters for the motion planning. Defaults to default_param.</p> <code>...</code> Notes <ul> <li>GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.</li> <li>If collision checking is enabled, collisions are checked against self-collision and obstacles that you     manually load via add_obstacle()/attach_target_object().</li> <li>In contrast, the Navigation module (GalbotNavigation) may use real-time perception/avoidance depending     on deployment; this is not currently integrated into GalbotMotion.</li> </ul> <p>Returns:</p> Name Type Description <code>bool</code> <code>tuple[MotionStatus, dict[str, list[list[float]]]]</code> <p>True if the motion planning is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.remove_obstacle","title":"remove_obstacle","text":"<pre><code>remove_obstacle(obstacle_id: str) -&gt; MotionStatus\n</code></pre> <p>Remove an obstacle by its ID</p>"},{"location":"api_python_reference/#g1.GalbotMotion.set_end_effector_pose","title":"set_end_effector_pose","text":"<pre><code>set_end_effector_pose(target_pose: collections.abc.Sequence[typing.SupportsFloat], end_effector_frame: str, reference_frame: str = 'base_link', reference_robot_states: RobotStates = None, enable_collision_check: bool = True, is_blocking: bool = True, timeout: typing.SupportsFloat = -1.0, params: Parameter = ...) -&gt; MotionStatus\n</code></pre> <p>Set the pose of a specified end-effector frame.</p> <p>Parameters:</p> Name Type Description Default <code>target_pose</code> <code>Pose</code> <p>The target pose.</p> required <code>end_effector_frame</code> <code>str</code> <p>The name of the end-effector frame.</p> required <code>reference_frame</code> <code>str</code> <p>The name of the reference frame. Defaults to \"base_link\".</p> <code>'base_link'</code> <code>reference_robot_states</code> <code>RobotStates</code> <p>The reference robot states. Defaults to nullptr.</p> <code>None</code> <code>enable_collision_check</code> <code>bool</code> <p>Whether to enable collision checking. Defaults to true.</p> <code>True</code> <code>is_blocking</code> <code>bool</code> <p>Whether to block until the motion is completed. Defaults to true.</p> <code>True</code> <code>timeout</code> <code>float</code> <p>The maximum time to wait for the motion to complete. Defaults to -1.0.</p> <code>-1.0</code> <code>params</code> <code>dict</code> <p>Additional parameters for the motion planning. Defaults to default_param.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>MotionStatus</code> <p>True if the motion planning is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotMotion.set_motion_plan_config","title":"set_motion_plan_config","text":"<pre><code>set_motion_plan_config(config: MotionPlanConfig) -&gt; MotionStatus\n</code></pre> <p>set motion config</p>"},{"location":"api_python_reference/#g1.GalbotNavigation","title":"GalbotNavigation","text":""},{"location":"api_python_reference/#g1.GalbotNavigation-functions","title":"Functions","text":""},{"location":"api_python_reference/#g1.GalbotNavigation.get_instance","title":"get_instance  <code>staticmethod</code>","text":"<pre><code>get_instance() -&gt; GalbotNavigation\n</code></pre> <p>Get the GalbotNavigation singleton instance.</p> <p>Returns:</p> Name Type Description <code>GalbotNavigation</code> <code>GalbotNavigation</code> <p>The GalbotNavigation singleton instance.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.check_goal_arrival","title":"check_goal_arrival","text":"<pre><code>check_goal_arrival() -&gt; bool\n</code></pre> <p>Check whether the robot has reached the goal pose.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the robot has reached the goal pose.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.check_path_reachability","title":"check_path_reachability","text":"<pre><code>check_path_reachability(goal_pose: typing.Annotated[numpy.typing.ArrayLike, numpy.float64], start_pose: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -&gt; bool\n</code></pre> <p>Check whether there is a reachable path from the start pose to the goal pose in the map frame.</p> <p>Parameters:</p> Name Type Description Default <code>goal_pose</code> <code>array</code> <p>The goal pose [x, y, z, qx, qy, qz, qw], map frame.</p> required <code>start_pose</code> <code>array</code> <p>The start pose [x, y, z, qx, qy, qz, qw], map frame.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether there is a reachable path from the start pose to the goal pose.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.get_current_pose","title":"get_current_pose","text":"<pre><code>get_current_pose() -&gt; typing.Annotated[list[float], 'FixedSize(7)']\n</code></pre> <p>Get the current pose of the robot.</p> <p>Returns:</p> Name Type Description <code>array</code> <code>Annotated[list[float], 'FixedSize(7)']</code> <p>[x, y, z, qx, qy, qz, qw], map frame</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.init","title":"init","text":"<pre><code>init() -&gt; bool\n</code></pre> <pre><code> Initialize the GalbotNavigation object.\n</code></pre> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialization is successful, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.is_localized","title":"is_localized","text":"<pre><code>is_localized() -&gt; bool\n</code></pre> <p>Check if the robot is localized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the robot is localized, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.move_straight_to","title":"move_straight_to","text":"<pre><code>move_straight_to(goal_pose: typing.Annotated[numpy.typing.ArrayLike, numpy.float64], is_blocking: bool = True, timeout: typing.SupportsFloat = 8) -&gt; tuple\n</code></pre> <p>Navigate to the given pose in odom frame, disable collision check and enable omni-directional planning.</p> <p>Parameters:</p> Name Type Description Default <code>goal_pose</code> <code>array</code> <p>The goal pose [x, y, z, qx, qy, qz, qw], base_link frame.</p> required <code>is_blocking</code> <code>bool</code> <p>Whether to block the call until the goal is reached, default false.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds, default 8.</p> <code>8</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(success: bool, status_string: str) - success: Whether the navigation is successful. - status_string: Status string.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.navigate_to_goal","title":"navigate_to_goal","text":"<pre><code>navigate_to_goal(goal_pose: typing.Annotated[numpy.typing.ArrayLike, numpy.float64], enable_collision_check: bool = True, is_blocking: bool = False, timeout: typing.SupportsFloat = 8, omni_plan: bool = True) -&gt; tuple\n</code></pre> <p>Plan and navigate to the given pose.</p> <p>Parameters:</p> Name Type Description Default <code>goal_pose</code> <code>array</code> <p>The goal pose [x, y, z, qx, qy, qz, qw], map frame.</p> required <code>collision_check</code> <code>bool</code> <p>Whether to enable collision check, default true.</p> required <code>is_blocking</code> <code>bool</code> <p>Whether to block the call until the goal is reached, default false.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>The timeout in seconds, default 8.</p> <code>8</code> <code>omni_plan</code> <code>bool</code> <p>Whether to enable omni-directional planning, default true. when configure omni_plan option, the parameter <code>forbidden_modify_omni_item</code> in /data/galbot/config/aphropm_pns_config/local_plan_config.toml must be set to false.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(success: bool, status_string: str) - success: Whether the navigation is successful. - status_string: Status string.</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.relocalize","title":"relocalize","text":"<pre><code>relocalize(init_pose: typing.Annotated[numpy.typing.ArrayLike, numpy.float64]) -&gt; tuple\n</code></pre> <pre><code> Relocalize the robot to the given pose.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>init_pose</code> <code>array</code> <p>The initial pose [x, y, z, qx, qy, qz, qw].</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(success: bool, status_string: str) - success:\u662f\u5426\u91cd\u5b9a\u4f4d\u6210\u529f - status_string:\u72b6\u6001\u63cf\u8ff0\u5b57\u7b26\u4e32</p>"},{"location":"api_python_reference/#g1.GalbotNavigation.stop_navigation","title":"stop_navigation","text":"<pre><code>stop_navigation() -&gt; tuple\n</code></pre> <p>Stop the current navigation task.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>(success: bool, status_string: str) - success: Whether the navigation is successfully stopped. - status_string: Status string.</p>"},{"location":"api_python_reference/#g1.GalbotOneFoxtrotSensor","title":"GalbotOneFoxtrotSensor","text":"<pre><code>GalbotOneFoxtrotSensor(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>LEFT_WRIST_FORCE : Left wrist force sensor</p> <p>RIGHT_WRIST_FORCE : Right wrist force sensor</p>"},{"location":"api_python_reference/#g1.GalbotRobot","title":"GalbotRobot","text":""},{"location":"api_python_reference/#g1.GalbotRobot-functions","title":"Functions","text":""},{"location":"api_python_reference/#g1.GalbotRobot.get_instance","title":"get_instance  <code>staticmethod</code>","text":"<pre><code>get_instance() -&gt; GalbotRobot\n</code></pre> <p>Get the singleton instance of GalbotRobot.</p> <p>Returns:</p> Name Type Description <code>GalbotRobot</code> <code>GalbotRobot</code> <p>The singleton instance of GalbotRobot.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.check_trajectory_execution_status","title":"check_trajectory_execution_status","text":"<pre><code>check_trajectory_execution_status(joint_groups: collections.abc.Sequence[JointGroup] = []) -&gt; list[TrajectoryControlStatus]\n</code></pre> <p>Get trajectory execution status for specified joint groups.</p> <p>Parameters:</p> Name Type Description Default <code>joint_groups</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups to query, can use strings or JointGroup enums (optional).</p> <code>[]</code> <p>Returns:</p> Type Description <code>list[TrajectoryControlStatus]</code> <p>List[TrajectoryControlStatus]: List of trajectory execution statuses.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Clean up system and middleware resources.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api_python_reference/#g1.GalbotRobot.execute_joint_trajectory","title":"execute_joint_trajectory","text":"<pre><code>execute_joint_trajectory(trajectory: Trajectory, is_blocking: bool = True) -&gt; ControlStatus\n</code></pre> <p>Execute trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Trajectory</code> <p>Trajectory data to execute.</p> required <code>is_blocking</code> <code>bool</code> <p>Whether to block until trajectory execution completes (optional, default: True).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Trajectory execution/sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_depth_data","title":"get_depth_data","text":"<pre><code>get_depth_data(camera_id: SensorType) -&gt; dict\n</code></pre> <p>Get latest depth image data from specified camera.</p> <p>Parameters:</p> Name Type Description Default <code>camera_id</code> <code>SensorType</code> <p>Depth camera sensor ID to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'header': Message header with timestamp and frame information - 'format': Image format, e.g., 'depth16' or other - 'depth_scale': Depth scaling factor - 'height': Image height in pixels - 'width': Image width in pixels - 'data': Compressed depth image binary data (bytes).</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_force_sensor_data","title":"get_force_sensor_data","text":"<pre><code>get_force_sensor_data(sensor_type: GalbotOneFoxtrotSensor) -&gt; dict\n</code></pre> <p>Get data from specified force sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_type</code> <code>GalbotOneFoxtrotSensor</code> <p>Force sensor enum to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'timestamp_ns': Timestamp in nanoseconds - 'force': Force vector dictionary with 'x', 'y', 'z' keys - 'torque': Torque vector dictionary with 'x', 'y', 'z' keys</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_gripper_state","title":"get_gripper_state","text":"<pre><code>get_gripper_state(end_effector: JointGroup) -&gt; GripperState\n</code></pre> <p>Get gripper state.</p> <p>Parameters:</p> Name Type Description Default <code>end_effector</code> <code>JointGroup</code> <p>Gripper enum value.</p> required <p>Returns:</p> Name Type Description <code>GripperState</code> <code>GripperState</code> <p>Gripper state information.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_imu_data","title":"get_imu_data","text":"<pre><code>get_imu_data(sensor_id: SensorType) -&gt; dict\n</code></pre> <p>Get data from specified IMU sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_id</code> <code>SensorType</code> <p>IMU sensor enum to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'timestamp_ns': Timestamp in nanoseconds - 'accel': Acceleration Vector3 {'x': float, 'y': float, 'z': float} - 'gyro': Gyroscope Vector3 {'x': float, 'y': float, 'z': float} - 'magnet': Magnetometer Vector3 {'x': float, 'y': float, 'z': float}</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_joint_group_names","title":"get_joint_group_names","text":"<pre><code>get_joint_group_names() -&gt; list[str]\n</code></pre> <p>Get available joint group names for the robot.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Array of available joint group names, returns empty list on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_joint_names","title":"get_joint_names","text":"<pre><code>get_joint_names(only_active_joint: bool = True, joint_groups: collections.abc.Sequence[JointGroup] = []) -&gt; list[str]\n</code></pre> <p>Get robot joint names.</p> <p>Parameters:</p> Name Type Description Default <code>only_active_joint</code> <code>bool</code> <p>Whether to only get active joints (optional, default: True).</p> <code>True</code> <code>joint_groups</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups, can use strings or JointGroup enums (optional).</p> <code>[]</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Array of corresponding joint names.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_joint_positions","title":"get_joint_positions","text":"<pre><code>get_joint_positions(joint_groups: collections.abc.Sequence[JointGroup], joint_names: collections.abc.Sequence[str] = []) -&gt; list[float]\n</code></pre> <p>Get joint positions.</p> <p>Parameters:</p> Name Type Description Default <code>joint_groups</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups to query, can use strings or JointGroup enums.</p> required <code>joint_names</code> <code>List[str]</code> <p>Specific joint names, takes priority over joint_groups (optional).</p> <code>[]</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>List[float]: Array of corresponding joint angles in radians.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_joint_states","title":"get_joint_states","text":"<pre><code>get_joint_states(joint_group_vec: collections.abc.Sequence[JointGroup], joint_names_vec: collections.abc.Sequence[str] = []) -&gt; list[JointState]\n</code></pre> <p>Get real-time joint states.</p> <p>Parameters:</p> Name Type Description Default <code>joint_group_vec</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups to query, can use strings or JointGroup enums (optional).</p> required <code>joint_names_vec</code> <code>List[str]</code> <p>Specific joint names, takes priority over joint_group_vec (optional).</p> <code>[]</code> <p>Returns:</p> Type Description <code>list[JointState]</code> <p>List[JointState]: Real-time state data for corresponding joints.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_lidar_data","title":"get_lidar_data","text":"<pre><code>get_lidar_data(sensor_id: SensorType) -&gt; dict\n</code></pre> <p>Get latest point cloud data from specified LiDAR sensor.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_id</code> <code>SensorType</code> <p>LiDAR sensor enum to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing point cloud data fields and binary point data. Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_odom","title":"get_odom","text":"<pre><code>get_odom() -&gt; dict\n</code></pre> <p>Get odometry information.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'timestamp': Timestamp in seconds - 'position': Position array [x, y, z] in meters - 'orientation': Quaternion array [x, y, z, w]</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_rgb_data","title":"get_rgb_data","text":"<pre><code>get_rgb_data(camera_id: SensorType) -&gt; dict\n</code></pre> <p>Get latest RGB image data from specified camera.</p> <p>Parameters:</p> Name Type Description Default <code>camera_id</code> <code>SensorType</code> <p>Camera sensor ID to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'header': Message header with timestamp and frame information - 'format': Image format, e.g., 'jpeg' or 'png' - 'data': Compressed image binary data (bytes)</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_suction_cup_state","title":"get_suction_cup_state","text":"<pre><code>get_suction_cup_state(end_effector: JointGroup) -&gt; SuctionCupState\n</code></pre> <p>Get suction cup state.</p> <p>Parameters:</p> Name Type Description Default <code>end_effector</code> <code>JointGroup</code> <p>Suction cup enum value.</p> required <p>Returns:</p> Name Type Description <code>SuctionCupState</code> <code>SuctionCupState</code> <p>Suction cup state information.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_transform","title":"get_transform","text":"<pre><code>get_transform(target_frame: str, source_frame: str, timestamp_ns: typing.SupportsInt = 0, timeout_ms: typing.SupportsInt = 100) -&gt; tuple\n</code></pre> <p>Query coordinate frame transform (TF).</p> <p>Parameters:</p> Name Type Description Default <code>target_frame</code> <code>str</code> <p>Target coordinate frame.</p> required <code>source_frame</code> <code>str</code> <p>Source coordinate frame.</p> required <code>timestamp_ns</code> <code>int</code> <p>Desired transform timestamp in nanoseconds, 0 for latest (optional, default: 0).</p> <code>0</code> <code>timeout_ms</code> <code>int</code> <p>Query timeout in milliseconds (optional, default: 100).</p> <code>100</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>(List[float], int)</code> <p>Transform matrix list and timestamp. Returns empty list on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.get_ultrasonic_data","title":"get_ultrasonic_data","text":"<pre><code>get_ultrasonic_data(ultrasonic_type: UltrasonicType) -&gt; dict\n</code></pre> <p>Get data from specified ultrasonic sensor.</p> <p>Parameters:</p> Name Type Description Default <code>ultrasonic_type</code> <code>UltrasonicType</code> <p>Ultrasonic sensor enum to query.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary containing the following keys: - 'timestamp_ns': Timestamp in nanoseconds - 'distance': Distance value in meters</p> <code>dict</code> <p>Returns empty dictionary on failure.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.init","title":"init","text":"<pre><code>init(enable_sensor_set: collections.abc.Set[SensorType] = ...) -&gt; bool\n</code></pre> <p>Initialize the singleton object.</p> <p>Parameters:</p> Name Type Description Default <code>enable_sensor_set</code> <code>set[SensorType]</code> <p>Set of sensors to enable.</p> <code>...</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialization succeeded, False otherwise.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.is_running","title":"is_running","text":"<pre><code>is_running() -&gt; bool\n</code></pre> <p>Check if the system is running.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if system is running, False if shutdown signal captured and preparing to shutdown.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.request_shutdown","title":"request_shutdown","text":"<pre><code>request_shutdown() -&gt; None\n</code></pre> <p>Send SIGINT signal to request shutdown.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api_python_reference/#g1.GalbotRobot.set_base_velocity","title":"set_base_velocity","text":"<pre><code>set_base_velocity(linear_velocity: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], 'FixedSize(3)'], angular_velocity: typing.Annotated[collections.abc.Sequence[typing.SupportsFloat], 'FixedSize(3)']) -&gt; ControlStatus\n</code></pre> <p>Set base velocity command.</p> <p>Parameters:</p> Name Type Description Default <code>linear_velocity</code> <code>List[float]</code> <p>Linear velocity command [vx, vy, vz] in m/s.</p> required <code>angular_velocity</code> <code>List[float]</code> <p>Angular velocity command [wx, wy, wz] in rad/s.</p> required <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Command sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.set_gripper_command","title":"set_gripper_command","text":"<pre><code>set_gripper_command(end_effector: JointGroup, width_m: typing.SupportsFloat, velocity_mps: typing.SupportsFloat = 0.03, effort: typing.SupportsFloat = 30, is_blocking: bool = True) -&gt; ControlStatus\n</code></pre> <p>Set gripper command.</p> <p>Parameters:</p> Name Type Description Default <code>end_effector</code> <code>JointGroup</code> <p>Gripper enum value.</p> required <code>width_m</code> <code>float</code> <p>Target gripper width in meters.</p> required <code>velocity_mps</code> <code>float</code> <p>Gripper motion speed in m/s (optional, default: 0.03).</p> <code>0.03</code> <code>effort</code> <code>float</code> <p>Gripper effort in Nm (optional, default: 30).</p> <code>30</code> <code>is_blocking</code> <code>bool</code> <p>Whether to block until action completes (optional, default: True).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Command execution/sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.set_joint_commands","title":"set_joint_commands","text":"<pre><code>set_joint_commands(joint_commands: collections.abc.Sequence[JointCommand], joint_groups: collections.abc.Sequence[JointGroup] = [], joint_names: collections.abc.Sequence[str] = []) -&gt; ControlStatus\n</code></pre> <p>Set joint commands with JointGroup enums.</p> <p>Parameters:</p> Name Type Description Default <code>joint_commands</code> <code>List[JointCommand]</code> <p>List of joint commands to control.</p> required <code>joint_groups</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups to control, can use strings or enums (optional).</p> <code>[]</code> <code>joint_names</code> <code>List[str]</code> <p>Specific joint names, takes priority over joint_groups (optional).</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Result of command execution.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.set_joint_positions","title":"set_joint_positions","text":"<pre><code>set_joint_positions(joint_positions: collections.abc.Sequence[typing.SupportsFloat], joint_groups: collections.abc.Sequence[JointGroup] = [], joint_names: collections.abc.Sequence[str] = [], is_blocking: bool = True, speed_rad_s: typing.SupportsFloat = 0.2, timeout_s: typing.SupportsFloat = 15.0) -&gt; ControlStatus\n</code></pre> <p>Set target joint positions for specified joint groups.</p> <p>Parameters:</p> Name Type Description Default <code>joint_positions</code> <code>List[float]</code> <p>Array of joint angles in radians.</p> required <code>joint_groups</code> <code>List[str] or List[JointGroup]</code> <p>Joint groups to control, can use strings or enums (optional).</p> <code>[]</code> <code>joint_names</code> <code>List[str]</code> <p>Specific joint names, takes priority over joint_groups (optional).</p> <code>[]</code> <code>is_blocking</code> <code>bool</code> <p>Whether to block until command execution completes (optional, default: True).</p> <code>True</code> <code>speed_rad_s</code> <code>float</code> <p>Maximum joint speed in rad/s (optional, default: 0.2).</p> <code>0.2</code> <code>timeout_s</code> <code>float</code> <p>Maximum blocking wait time in seconds (optional, default: 15.0).</p> <code>15.0</code> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Execution result status.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.set_suction_cup_command","title":"set_suction_cup_command","text":"<pre><code>set_suction_cup_command(end_effector: JointGroup, activate: bool) -&gt; ControlStatus\n</code></pre> <p>Set suction cup command.</p> <p>Parameters:</p> Name Type Description Default <code>end_effector</code> <code>JointGroup</code> <p>Suction cup enum value.</p> required <code>activate</code> <code>bool</code> <p>Whether to activate the suction cup.</p> required <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Command sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.stop_base","title":"stop_base","text":"<pre><code>stop_base() -&gt; ControlStatus\n</code></pre> <p>Stop base motion.</p> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Command sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.stop_trajectory_execution","title":"stop_trajectory_execution","text":"<pre><code>stop_trajectory_execution() -&gt; ControlStatus\n</code></pre> <p>Stop all currently executing trajectories.</p> <p>Returns:</p> Name Type Description <code>ControlStatus</code> <code>ControlStatus</code> <p>Command sending result.</p>"},{"location":"api_python_reference/#g1.GalbotRobot.wait_for_shutdown","title":"wait_for_shutdown","text":"<pre><code>wait_for_shutdown() -&gt; None\n</code></pre> <p>Sleep continuously until shutdown signal is received.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api_python_reference/#g1.GripperState","title":"GripperState","text":"<pre><code>GripperState()\n</code></pre> <p>Gripper state information</p>"},{"location":"api_python_reference/#g1.GripperState-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.GripperState.effort","title":"effort  <code>property</code> <code>writable</code>","text":"<pre><code>effort: float\n</code></pre> <p>Gripper torque (newton-meters)</p>"},{"location":"api_python_reference/#g1.GripperState.is_moving","title":"is_moving  <code>property</code> <code>writable</code>","text":"<pre><code>is_moving: bool\n</code></pre> <p>Whether currently moving</p>"},{"location":"api_python_reference/#g1.GripperState.joint_positions","title":"joint_positions  <code>property</code> <code>writable</code>","text":"<pre><code>joint_positions: list[float]\n</code></pre> <p>Joint positions array</p>"},{"location":"api_python_reference/#g1.GripperState.timestamp_ns","title":"timestamp_ns  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp_ns: int\n</code></pre> <p>Timestamp (nanoseconds)</p>"},{"location":"api_python_reference/#g1.GripperState.velocity","title":"velocity  <code>property</code> <code>writable</code>","text":"<pre><code>velocity: float\n</code></pre> <p>Gripper velocity (meters/second)</p>"},{"location":"api_python_reference/#g1.GripperState.width","title":"width  <code>property</code> <code>writable</code>","text":"<pre><code>width: float\n</code></pre> <p>Gripper width (meters)</p>"},{"location":"api_python_reference/#g1.Header","title":"Header","text":"<pre><code>Header()\n</code></pre> <p>Message header</p>"},{"location":"api_python_reference/#g1.Header-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.Header.frame_id","title":"frame_id  <code>property</code> <code>writable</code>","text":"<pre><code>frame_id: str\n</code></pre> <p>Frame ID</p>"},{"location":"api_python_reference/#g1.Header.stamp","title":"stamp  <code>property</code> <code>writable</code>","text":"<pre><code>stamp: Timestamp\n</code></pre> <p>Timestamp</p>"},{"location":"api_python_reference/#g1.ImuData","title":"ImuData","text":"<pre><code>ImuData()\n</code></pre> <p>IMU data</p>"},{"location":"api_python_reference/#g1.ImuData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.ImuData.accel","title":"accel  <code>property</code> <code>writable</code>","text":"<pre><code>accel: Vector3\n</code></pre> <p>Acceleration Vector3</p>"},{"location":"api_python_reference/#g1.ImuData.gyro","title":"gyro  <code>property</code> <code>writable</code>","text":"<pre><code>gyro: Vector3\n</code></pre> <p>Gyroscope Vector3</p>"},{"location":"api_python_reference/#g1.ImuData.magnet","title":"magnet  <code>property</code> <code>writable</code>","text":"<pre><code>magnet: Vector3\n</code></pre> <p>Magnetometer Vector3</p>"},{"location":"api_python_reference/#g1.ImuData.timestamp_ns","title":"timestamp_ns  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp_ns: int\n</code></pre> <p>Timestamp (nanoseconds)</p>"},{"location":"api_python_reference/#g1.JointCommand","title":"JointCommand","text":"<pre><code>JointCommand()\n</code></pre> <p>Single joint command object</p>"},{"location":"api_python_reference/#g1.JointCommand-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.JointCommand.acceleration","title":"acceleration  <code>property</code> <code>writable</code>","text":"<pre><code>acceleration: float\n</code></pre> <ul> <li><code>acceleration</code> (<code>float</code>): Joint acceleration</li> </ul>"},{"location":"api_python_reference/#g1.JointCommand.effort","title":"effort  <code>property</code> <code>writable</code>","text":"<pre><code>effort: float\n</code></pre> <ul> <li><code>effort</code> (<code>float</code>): Joint torque (N\u00b7m)</li> </ul>"},{"location":"api_python_reference/#g1.JointCommand.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: float\n</code></pre> <ul> <li><code>position</code> (<code>float</code>): Joint target position (radians)</li> </ul>"},{"location":"api_python_reference/#g1.JointCommand.velocity","title":"velocity  <code>property</code> <code>writable</code>","text":"<pre><code>velocity: float\n</code></pre> <ul> <li><code>velocity</code> (<code>float</code>): Joint velocity (radians/second)</li> </ul>"},{"location":"api_python_reference/#g1.JointGroup","title":"JointGroup","text":"<pre><code>JointGroup(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>HEAD : Head joint group</p> <p>LEFT_ARM : Left arm joint group</p> <p>RIGHT_ARM : Right arm joint group</p> <p>LEG : Leg joint group</p> <p>CHASSIS : Chassis joint group</p> <p>LEFT_GRIPPER : Left gripper</p> <p>RIGHT_GRIPPER : Right gripper</p> <p>LEFT_SUCTION_CUP : Left suction cup</p> <p>RIGHT_SUCTION_CUP : Right suction cup</p>"},{"location":"api_python_reference/#g1.LidarData","title":"LidarData","text":"<pre><code>LidarData()\n</code></pre> <p>LiDAR point cloud data</p>"},{"location":"api_python_reference/#g1.LidarData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.LidarData.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: list[int]\n</code></pre> <p>Point cloud binary data</p>"},{"location":"api_python_reference/#g1.LidarData.fields","title":"fields  <code>property</code> <code>writable</code>","text":"<pre><code>fields: list[PointField]\n</code></pre> <p>Point field description list</p>"},{"location":"api_python_reference/#g1.LidarData.header","title":"header  <code>property</code> <code>writable</code>","text":"<pre><code>header: Header\n</code></pre> <p>Message header</p>"},{"location":"api_python_reference/#g1.LidarData.height","title":"height  <code>property</code> <code>writable</code>","text":"<pre><code>height: int\n</code></pre> <p>Point cloud height</p>"},{"location":"api_python_reference/#g1.LidarData.is_bigendian","title":"is_bigendian  <code>property</code> <code>writable</code>","text":"<pre><code>is_bigendian: bool\n</code></pre> <p>Whether big-endian</p>"},{"location":"api_python_reference/#g1.LidarData.is_dense","title":"is_dense  <code>property</code> <code>writable</code>","text":"<pre><code>is_dense: bool\n</code></pre> <p>Whether dense</p>"},{"location":"api_python_reference/#g1.LidarData.point_step","title":"point_step  <code>property</code> <code>writable</code>","text":"<pre><code>point_step: int\n</code></pre> <p>Bytes per point</p>"},{"location":"api_python_reference/#g1.LidarData.row_step","title":"row_step  <code>property</code> <code>writable</code>","text":"<pre><code>row_step: int\n</code></pre> <p>Bytes per row</p>"},{"location":"api_python_reference/#g1.LidarData.width","title":"width  <code>property</code> <code>writable</code>","text":"<pre><code>width: int\n</code></pre> <p>Point cloud width</p>"},{"location":"api_python_reference/#g1.MotionStatus","title":"MotionStatus","text":"<pre><code>MotionStatus(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>SUCCESS</p> <p>TIMEOUT</p> <p>FAULT</p> <p>INVALID_INPUT</p> <p>INIT_FAILED</p> <p>IN_PROGRESS</p> <p>STOPPED_UNREACHED</p> <p>DATA_FETCH_FAILED</p> <p>PUBLISH_FAIL</p> <p>COMM_DISCONNECTED</p> <p>STATUS_NUM</p> <p>UNSUPPORTED_FUNCRION</p>"},{"location":"api_python_reference/#g1.OdomData","title":"OdomData","text":"<pre><code>OdomData()\n</code></pre> <p>Odometry data</p>"},{"location":"api_python_reference/#g1.OdomData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.OdomData.orientation","title":"orientation  <code>property</code> <code>writable</code>","text":"<pre><code>orientation: Annotated[list[float], 'FixedSize(4)']\n</code></pre> <p>Orientation quaternion [x, y, z, w]</p>"},{"location":"api_python_reference/#g1.OdomData.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: Annotated[list[float], 'FixedSize(3)']\n</code></pre> <p>Position [x, y, z] (meters)</p>"},{"location":"api_python_reference/#g1.OdomData.timestamp","title":"timestamp  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp: int\n</code></pre> <p>Timestamp (seconds)</p>"},{"location":"api_python_reference/#g1.Parameter","title":"Parameter","text":"<pre><code>Parameter(direct_execute: bool, blocking: bool, timeout: typing.SupportsFloat, actuate: str, tool_pose: bool, check_collision: bool, frame: str = 'base_link')\n</code></pre>"},{"location":"api_python_reference/#g1.Parameter-functions","title":"Functions","text":""},{"location":"api_python_reference/#g1.Parameter.get_actuate_type","title":"get_actuate_type","text":"<pre><code>get_actuate_type() -&gt; str\n</code></pre> <p>Get the actuation type (only link, including torso, including legs).</p>"},{"location":"api_python_reference/#g1.Parameter.get_blocking","title":"get_blocking","text":"<pre><code>get_blocking() -&gt; bool\n</code></pre> <p>Get whether to wait synchronously for trajectory execution or planning completion.</p>"},{"location":"api_python_reference/#g1.Parameter.get_check_collision","title":"get_check_collision","text":"<pre><code>get_check_collision() -&gt; bool\n</code></pre> <p>Get whether to perform collision detection.</p>"},{"location":"api_python_reference/#g1.Parameter.get_direct_execute","title":"get_direct_execute","text":"<pre><code>get_direct_execute() -&gt; bool\n</code></pre> <p>Get whether to directly execute the trajectory after planning.</p>"},{"location":"api_python_reference/#g1.Parameter.get_reference_frame","title":"get_reference_frame","text":"<pre><code>get_reference_frame() -&gt; str\n</code></pre> <p>Get the reference coordinate frame for planning.</p>"},{"location":"api_python_reference/#g1.Parameter.get_timeout","title":"get_timeout","text":"<pre><code>get_timeout() -&gt; float\n</code></pre> <p>Get the maximum waiting time for trajectory execution or planning completion (in seconds).</p>"},{"location":"api_python_reference/#g1.Parameter.get_tool_pose","title":"get_tool_pose","text":"<pre><code>get_tool_pose() -&gt; bool\n</code></pre> <p>Get whether to use tool pose for actuation.</p>"},{"location":"api_python_reference/#g1.Parameter.set_actuate","title":"set_actuate","text":"<pre><code>set_actuate(actuate: str) -&gt; None\n</code></pre> <p>Set the actuation type (only link, including torso, including legs).</p>"},{"location":"api_python_reference/#g1.Parameter.set_blocking","title":"set_blocking","text":"<pre><code>set_blocking(blocking: bool) -&gt; None\n</code></pre> <p>Set whether to wait synchronously for trajectory execution or planning completion.</p>"},{"location":"api_python_reference/#g1.Parameter.set_check_collision","title":"set_check_collision","text":"<pre><code>set_check_collision(check_collision: bool) -&gt; None\n</code></pre> <p>Set whether to perform collision detection.</p>"},{"location":"api_python_reference/#g1.Parameter.set_direct_execute","title":"set_direct_execute","text":"<pre><code>set_direct_execute(direct_execute: bool) -&gt; None\n</code></pre> <p>Set whether to directly execute the trajectory after planning.</p>"},{"location":"api_python_reference/#g1.Parameter.set_move_line","title":"set_move_line","text":"<pre><code>set_move_line(move_line: bool) -&gt; None\n</code></pre> <p>Set whether to use linear movement for planning.</p>"},{"location":"api_python_reference/#g1.Parameter.set_reference_frame","title":"set_reference_frame","text":"<pre><code>set_reference_frame(frame: str) -&gt; None\n</code></pre> <p>Set the reference coordinate frame for planning.</p>"},{"location":"api_python_reference/#g1.Parameter.set_timeout","title":"set_timeout","text":"<pre><code>set_timeout(timeout: typing.SupportsFloat) -&gt; None\n</code></pre> <p>Set the maximum waiting time for trajectory execution or planning completion (in seconds).</p>"},{"location":"api_python_reference/#g1.Parameter.set_tool_pose","title":"set_tool_pose","text":"<pre><code>set_tool_pose(tool_pose: bool) -&gt; None\n</code></pre> <p>Set whether to use tool pose for actuation.</p>"},{"location":"api_python_reference/#g1.PointField","title":"PointField","text":"<pre><code>PointField()\n</code></pre> <p>Point cloud field description information</p>"},{"location":"api_python_reference/#g1.PointField-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.PointField.count","title":"count  <code>property</code> <code>writable</code>","text":"<pre><code>count: int\n</code></pre> <p>Number of field elements</p>"},{"location":"api_python_reference/#g1.PointField.datatype","title":"datatype  <code>property</code> <code>writable</code>","text":"<pre><code>datatype: ...\n</code></pre> <p>Data type (DataType enum)</p>"},{"location":"api_python_reference/#g1.PointField.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Field name, e.g., x, y, z, intensity, rgb</p>"},{"location":"api_python_reference/#g1.PointField.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: int\n</code></pre> <p>Byte offset of field in a single point</p>"},{"location":"api_python_reference/#g1.PointFieldDataType","title":"PointFieldDataType","text":"<pre><code>PointFieldDataType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>UNKNOWN</p> <p>INT8</p> <p>UINT8</p> <p>INT16</p> <p>UINT16</p> <p>INT32</p> <p>UINT32</p> <p>FLOAT32</p> <p>FLOAT64</p>"},{"location":"api_python_reference/#g1.PrimitiveType","title":"PrimitiveType","text":"<pre><code>PrimitiveType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>LINE</p> <p>CYLINDER</p>"},{"location":"api_python_reference/#g1.RgbData","title":"RgbData","text":"<pre><code>RgbData()\n</code></pre> <p>Compressed image data</p>"},{"location":"api_python_reference/#g1.RgbData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.RgbData.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: list[int]\n</code></pre> <p>Compressed binary data</p>"},{"location":"api_python_reference/#g1.RgbData.format","title":"format  <code>property</code> <code>writable</code>","text":"<pre><code>format: str\n</code></pre> <p>Image format</p>"},{"location":"api_python_reference/#g1.RgbData.header","title":"header  <code>property</code> <code>writable</code>","text":"<pre><code>header: Header\n</code></pre> <p>Message header</p>"},{"location":"api_python_reference/#g1.RobotStatesType","title":"RobotStatesType","text":"<pre><code>RobotStatesType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>POSE</p> <p>JOINT</p> <p>ROBOT_STATES</p>"},{"location":"api_python_reference/#g1.SUCTION_ACTION_STATE","title":"SUCTION_ACTION_STATE","text":"<pre><code>SUCTION_ACTION_STATE(value: typing.SupportsInt)\n</code></pre> <p>Suction cup action state enumeration</p> <p>Members:</p> <p>IDLE : Not sucking</p> <p>SUCKING : Currently sucking</p> <p>SUCCESS : Suction successful</p> <p>FAILED : Suction failed</p>"},{"location":"api_python_reference/#g1.SeedType","title":"SeedType","text":"<pre><code>SeedType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>RANDOM_SEED</p> <p>RANDOM_PROGRESSIVE_SEED</p> <p>USER_DEFINED_SEED</p>"},{"location":"api_python_reference/#g1.SensorType","title":"SensorType","text":"<pre><code>SensorType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>HEAD_LEFT_CAMERA : Head left camera</p> <p>HEAD_RIGHT_CAMERA : Head right camera</p> <p>LEFT_ARM_CAMERA : Left arm camera</p> <p>RIGHT_ARM_CAMERA : Right arm camera</p> <p>LEFT_ARM_DEPTH_CAMERA : Left arm depth camera</p> <p>RIGHT_ARM_DEPTH_CAMERA : Right arm depth camera</p> <p>BASE_LIDAR : Base LiDAR</p> <p>TORSO_IMU : Torso IMU</p> <p>BASE_ULTRASONIC : Base ultrasonic sensor</p>"},{"location":"api_python_reference/#g1.StateCheckType","title":"StateCheckType","text":"<pre><code>StateCheckType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>EUCLIDEAN_DISTANCE</p> <p>RADIAN_DISTANCE</p>"},{"location":"api_python_reference/#g1.SuctionCupState","title":"SuctionCupState","text":"<pre><code>SuctionCupState()\n</code></pre> <p>Suction cup state information</p>"},{"location":"api_python_reference/#g1.SuctionCupState-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.SuctionCupState.action_state","title":"action_state  <code>property</code> <code>writable</code>","text":"<pre><code>action_state: SUCTION_ACTION_STATE\n</code></pre> <p>Current suction cup action state (SUCTION_ACTION_STATE enum)</p>"},{"location":"api_python_reference/#g1.SuctionCupState.activation","title":"activation  <code>property</code> <code>writable</code>","text":"<pre><code>activation: bool\n</code></pre> <p>Whether currently sucking</p>"},{"location":"api_python_reference/#g1.SuctionCupState.pressure","title":"pressure  <code>property</code> <code>writable</code>","text":"<pre><code>pressure: float\n</code></pre> <p>Current pressure (Pa)</p>"},{"location":"api_python_reference/#g1.SuctionCupState.timestamp_ns","title":"timestamp_ns  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp_ns: int\n</code></pre> <p>Timestamp (nanoseconds)</p>"},{"location":"api_python_reference/#g1.TerminationConditionType","title":"TerminationConditionType","text":"<pre><code>TerminationConditionType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>TIMEOUT</p> <p>TIMEOUT_AND_EXACT_SOLUTION</p>"},{"location":"api_python_reference/#g1.Timestamp","title":"Timestamp","text":"<pre><code>Timestamp()\n</code></pre> <p>High-precision timestamp</p>"},{"location":"api_python_reference/#g1.Timestamp-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.Timestamp.nanosec","title":"nanosec  <code>property</code> <code>writable</code>","text":"<pre><code>nanosec: int\n</code></pre> <p>Nanoseconds</p>"},{"location":"api_python_reference/#g1.Timestamp.sec","title":"sec  <code>property</code> <code>writable</code>","text":"<pre><code>sec: int\n</code></pre> <p>Seconds</p>"},{"location":"api_python_reference/#g1.Trajectory","title":"Trajectory","text":"<pre><code>Trajectory()\n</code></pre> <p>Trajectory object</p>"},{"location":"api_python_reference/#g1.Trajectory-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.Trajectory.joint_groups","title":"joint_groups  <code>property</code> <code>writable</code>","text":"<pre><code>joint_groups: list[str]\n</code></pre> <p>List of joint group names</p>"},{"location":"api_python_reference/#g1.Trajectory.joint_names","title":"joint_names  <code>property</code> <code>writable</code>","text":"<pre><code>joint_names: list[str]\n</code></pre> <p>List of joint names</p>"},{"location":"api_python_reference/#g1.Trajectory.points","title":"points  <code>property</code> <code>writable</code>","text":"<pre><code>points: list[TrajectoryPoint]\n</code></pre> <p>List of trajectory points (TrajectoryPoint list)</p>"},{"location":"api_python_reference/#g1.TrajectoryControlStatus","title":"TrajectoryControlStatus","text":"<pre><code>TrajectoryControlStatus(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>INVALID_INPUT : Input parameters do not meet requirements</p> <p>RUNNING : Currently running</p> <p>COMPLETED : Reached target position</p> <p>STOPPED_UNREACHED : Stopped but not reached target</p> <p>ERROR : Error occurred, cannot continue execution</p> <p>DATA_FETCH_FAILED : Failed to fetch execution data</p>"},{"location":"api_python_reference/#g1.TrajectoryPoint","title":"TrajectoryPoint","text":"<pre><code>TrajectoryPoint()\n</code></pre> <p>Single trajectory point object</p>"},{"location":"api_python_reference/#g1.TrajectoryPoint-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.TrajectoryPoint.joint_command_vec","title":"joint_command_vec  <code>property</code> <code>writable</code>","text":"<pre><code>joint_command_vec: list[JointCommand]\n</code></pre> <ul> <li><code>joint_command_vec</code> (<code>List[JointCommand]</code>): List of specific joint commands to execute</li> </ul>"},{"location":"api_python_reference/#g1.TrajectoryPoint.time_from_start_second","title":"time_from_start_second  <code>property</code> <code>writable</code>","text":"<pre><code>time_from_start_second: float\n</code></pre> <ul> <li><code>time_from_start_second</code> (<code>float</code>): Time from trajectory start (seconds)</li> </ul>"},{"location":"api_python_reference/#g1.UltrasonicData","title":"UltrasonicData","text":"<pre><code>UltrasonicData()\n</code></pre> <p>Ultrasonic sensor data</p>"},{"location":"api_python_reference/#g1.UltrasonicData-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.UltrasonicData.distance","title":"distance  <code>property</code> <code>writable</code>","text":"<pre><code>distance: float\n</code></pre> <p>Distance (meters)</p>"},{"location":"api_python_reference/#g1.UltrasonicData.timestamp_ns","title":"timestamp_ns  <code>property</code> <code>writable</code>","text":"<pre><code>timestamp_ns: int\n</code></pre> <p>Timestamp (nanoseconds)</p>"},{"location":"api_python_reference/#g1.UltrasonicType","title":"UltrasonicType","text":"<pre><code>UltrasonicType(value: typing.SupportsInt)\n</code></pre> <p>Members:</p> <p>FRONT_LEFT : Front left</p> <p>FRONT_RIGHT : Front right</p> <p>RIGHT_LEFT : Right left</p> <p>RIGHT_RIGHT : Right right</p> <p>BACK_LEFT : Back left</p> <p>BACK_RIGHT : Back right</p> <p>LEFT_LEFT : Left left</p> <p>LEFT_RIGHT : Left right</p>"},{"location":"api_python_reference/#g1.Vector3","title":"Vector3","text":"<pre><code>Vector3()\n</code></pre> <p>Three-dimensional vector</p>"},{"location":"api_python_reference/#g1.Vector3-attributes","title":"Attributes","text":""},{"location":"api_python_reference/#g1.Vector3.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x: float\n</code></pre> <p>X coordinate</p>"},{"location":"api_python_reference/#g1.Vector3.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y: float\n</code></pre> <p>Y coordinate</p>"},{"location":"api_python_reference/#g1.Vector3.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z: float\n</code></pre> <p>Z coordinate</p>"},{"location":"api_python_reference/#g1-functions","title":"Functions","text":""},{"location":"api_python_reference/#g1.check_motion_status","title":"check_motion_status","text":"<pre><code>check_motion_status(arg0: MotionStatus) -&gt; str\n</code></pre> <p>Convert a MotionStatus enum value to a string.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>MotionStatus</code> <p>The motion status to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the motion status.</p>"},{"location":"api_python_reference/#g1.create_joint_state","title":"create_joint_state","text":"<pre><code>create_joint_state() -&gt; JointStates\n</code></pre> <p>Create a JointStates instance.</p> <p>Returns:</p> Name Type Description <code>JointStates</code> <code>JointStates</code> <p>A new JointStates instance.</p>"},{"location":"api_python_reference/#g1.create_parameter","title":"create_parameter","text":"<pre><code>create_parameter(direct_execute: bool, blocking: bool, timeout: typing.SupportsFloat, actuate: str, tool_pose: bool, check_collision: bool, frame: str = 'base_link') -&gt; Parameter\n</code></pre> <p>Create a Parameter instance.</p> Notes <ul> <li>GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.</li> <li>Attached objects are part of the manually-maintained collision world used by motion planning/checking.</li> <li>For obstacle_type == \"point_cloud\", <code>key</code> is typically a point cloud file path provided by the user.</li> <li>For obstacle_type == \"depth_image\", this is a manual input to construct collision obstacles; it is not a continuous real-time perception stream for motion planning.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>direct_execute</code> <code>bool</code> <p>Whether to execute the motion directly.</p> required <code>blocking</code> <code>bool</code> <p>Whether to block the execution until completion.</p> required <code>timeout</code> <code>float</code> <p>Maximum time to wait for the motion to complete.</p> required <code>actuate</code> <code>str</code> <p>Actuation type (position/velocity/torque).</p> required <code>tool_pose</code> <code>bool</code> <p>Whether the motion is for a tool pose.</p> required <code>check_collision</code> <code>bool</code> <p>Whether to check for collisions.</p> required <code>frame</code> <code>str</code> <p>Coordinate frame for the motion. Defaults to \"base_link\".</p> <code>'base_link'</code> <p>Returns:</p> Name Type Description <code>Parameter</code> <code>Parameter</code> <p>A new Parameter instance.</p>"},{"location":"api_python_reference/#g1.create_pose_state","title":"create_pose_state","text":"<pre><code>create_pose_state() -&gt; PoseState\n</code></pre> <p>Create a PoseState instance.</p> <p>Returns:</p> Name Type Description <code>PoseState</code> <code>PoseState</code> <p>A new PoseState instance.</p>"},{"location":"examples_cpp/","title":"C++ \u793a\u4f8b","text":"<p>\u672c\u6587\u4ef6\u4e3a API \u4e2d\u516c\u5f00\u7684\u51fd\u6570\u4e0e\u7c7b\u578b\u63d0\u4f9b\u7b80\u77ed\u793a\u4f8b\uff0c\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u63a5\u53e3\u3002</p>"},{"location":"examples_cpp/#g1-22","title":"\u673a\u5668\u4eba\u5173\u8282\u540d\u79f0\uff08G1 2.2\uff09","text":""},{"location":"examples_cpp/#_1","title":"\u5173\u8282\u7ec4\u5217\u8868","text":"<p>\u673a\u5668\u4eba\u5173\u8282\u7ec4\u540d\u79f0\u5305\u62ec\uff1a<code>[\"head\", \"left_arm\", \"right_arm\", \"leg\", \"left_gripper\", \"right_gripper\", \"left_suction_cup\", \"right_suction_cup\"]</code></p>"},{"location":"examples_cpp/#_2","title":"\u5404\u5173\u8282\u7ec4\u8be6\u7ec6\u4fe1\u606f","text":"\u5173\u8282\u7ec4\u540d\u79f0 \u5173\u8282\u7ec4\u82f1\u6587\u540d \u5173\u8282\u6570\u91cf \u5173\u8282\u540d\u79f0\u5217\u8868 \u5934\u90e8 head 2 <code>head_joint1</code>, <code>head_joint2</code> \u817f\u90e8 leg 5 <code>leg_joint1</code>, <code>leg_joint2</code>, <code>leg_joint3</code>, <code>leg_joint4</code>, <code>leg_joint5</code> \u5de6\u81c2 left_arm 7 <code>left_arm_joint1</code>, <code>left_arm_joint2</code>, <code>left_arm_joint3</code>, <code>left_arm_joint4</code>, <code>left_arm_joint5</code>, <code>left_arm_joint6</code>, <code>left_arm_joint7</code> \u53f3\u81c2 right_arm 7 <code>right_arm_joint1</code>, <code>right_arm_joint2</code>, <code>right_arm_joint3</code>, <code>right_arm_joint4</code>, <code>right_arm_joint5</code>, <code>right_arm_joint6</code>, <code>right_arm_joint7</code> \u5de6\u5939\u722a left_gripper 1 <code>left_gripper_joint1</code> \u53f3\u5939\u722a right_gripper 1 <code>right_gripper_joint1</code> \u5de6\u5438\u76d8 left_suction_cup 1 <code>left_suction_cup_joint1</code> \u53f3\u5438\u76d8 right_suction_cup 1 <code>right_suction_cup_joint1</code>"},{"location":"examples_cpp/#galbotrobot","title":"\u7c7b\uff1aGalbotRobot","text":"<p>tips\uff1a\u7a0b\u5e8f\u542f\u52a8\u540e\u7acb\u523b\u5c31get\uff0c\u6570\u636e\u53ef\u80fd\u4e0d\u4f1a\u7acb\u523b\u5c31\u7eea\uff0c\u53ef\u9002\u5f53sleep\u51e0\u79d2</p>"},{"location":"examples_cpp/#get_instance-init","title":"\u83b7\u53d6\u5b9e\u4f8b\u5e76\u521d\u59cb\u5316\uff08get_instance &amp;&amp; init\uff09","text":"examples/cpp/galbot_robot/src/get_instance_init_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;memory&gt;\n#include &lt;thread&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u5355\u4f8b\u5bf9\u8c61\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u5224\u65ad\u662f\u5426\u5904\u4e8e\u8fd0\u884c\u72b6\u6001\n    while (robot.is_running()) {\n        // do something\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u6b63\u5728\u8fd0\u884c\u3002\" &lt;&lt; std::endl;\n        break;\n    }\n\n    // \u6ce8\u518c\u9000\u51fa\u56de\u8c03(\u53ef\u9009\u9879\uff0c\u6536\u5230\u9000\u51fa\u4fe1\u53f7\u65f6\u4f1a\u81ea\u52a8\u89e6\u53d1)\n    robot.register_exit_callback([]() {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u6b63\u5728\u9000\u51fa...\" &lt;&lt; std::endl;\n    });\n    std::cout &lt;&lt; \"\u6210\u529f\u6ce8\u518c\u7cfb\u7edf\u9000\u51fa\u56de\u8c03\" &lt;&lt; std::endl;\n\n    // \u53d1\u51fa\u9000\u51fa\u4fe1\u53f7\n    robot.request_shutdown();\n    // \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\n    robot.wait_for_shutdown();\n    // \u91ca\u653eSDK\u76f8\u5173\u8d44\u6e90\n    robot.destroy();\n    std::cout &lt;&lt; \"\u7a0b\u5e8f\u7ed3\u675f\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#sdk","title":"\u91ca\u653eSDK\u76f8\u5173\u8d44\u6e90\u5e76\u9000\u51fa\u7a0b\u5e8f","text":"examples/cpp/galbot_robot/src/stop_base_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u505c\u6b62\u5e95\u76d8\u8fd0\u52a8\n    while (true) {\n        ControlStatus status = robot.stop_base();\n        if (status == ControlStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u5e95\u76d8\u5df2\u6210\u529f\u505c\u6b62\u8fd0\u52a8\uff01\" &lt;&lt; std::endl;\n            break;\n        } else {\n            std::cerr &lt;&lt; \"\u5e95\u76d8\u505c\u6b62\u8fd0\u52a8\u5931\u8d25\uff0c\u6b63\u5728\u91cd\u8bd5...\" &lt;&lt; std::endl;\n        }\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#set_joint_positions","title":"\u8bbe\u7f6e\u5173\u8282\u89d2\u5ea6\uff08set_joint_positions\uff09","text":"examples/cpp/galbot_robot/src/set_joint_positions_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u540d\u79f0\uff0c\u5173\u8282\u7ec4\u540d\u79f0\u5305\u62ec[\"leg\", \"head\", \"left_arm\", \"right_arm\"]\n    std::vector&lt;std::string&gt; joint_groups = {\"head\"};\n    bool only_active_joint = true;  // \u83b7\u53d6\u53ef\u6d3b\u52a8\u5173\u8282\n    auto head_joint_names_vec =\n        robot.get_joint_names(only_active_joint, joint_groups);\n    std::cout &lt;&lt; \"Head joint names:\" &lt;&lt; std::endl;\n    for (size_t i = 0; i &lt; head_joint_names_vec.size(); ++i) {\n        std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; head_joint_names_vec[i] &lt;&lt; std::endl;\n    }\n    // \u4f20\u5165\u7a7a\u6570\u7ec4\u9ed8\u8ba4\u83b7\u53d6\u6240\u6709\u5173\u8282\u7ec4\u4fe1\u606f\n    std::vector&lt;std::string&gt; null_vec = {};\n    auto all_joint_names_vec =\n        robot.get_joint_names(only_active_joint, null_vec);\n    std::cout &lt;&lt; \"All joint names:\" &lt;&lt; std::endl;\n    for (size_t i = 0; i &lt; all_joint_names_vec.size(); ++i) {\n        std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; all_joint_names_vec[i] &lt;&lt; std::endl;\n    }\n\n    // \u8981\u63a7\u5236\u7684\u5173\u8282\u7ec4\uff0c\u4f20\u5165\u7a7a\u6570\u7ec4\u9ed8\u8ba4\u63a7\u5236\u817f\u3001\u5934\u3001\u5de6\u81c2\u3001\u53f3\u81c2\u5173\u8282\n    joint_groups = {\"head\"};\n    // \u8981\u63a7\u5236\u7684\u6307\u5b9a\u5173\u8282\uff0c\u5982\u586b\u5145\u5c06\u8986\u76d6joint_groups\u53c2\u6570\n    std::vector&lt;std::string&gt; joint_names = {};\n    // \u5173\u8282\u4f4d\u7f6e\uff0c\u5934\u90e8\u5173\u8282\u7ec4\u5305\u542b\u4e24\u4e2a\u5173\u8282\n    std::vector&lt;double&gt; joint_pos = {0.2, 0.2};\n    // \u662f\u5426\u963b\u585e\u7b49\u5f85\u5173\u8282\u89d2\u5ea6\u6267\u884c\u5230\u4f4d\u6216\u8d85\u65f6\n    bool is_block = true;\n    // \u5173\u8282\u6700\u5927\u8fd0\u884c\u901f\u5ea6\uff08rad/s\uff09\n    double speed_rad_s = 0.1;\n    // \u6700\u5927\u7b49\u5f85\u65f6\u95f4\uff08\u79d2\uff09\n    double timeout_s = 10.0;\n\n    // \u8bbe\u7f6e\u5173\u8282\u4f4d\u7f6e\n    galbot::sdk::g1::ControlStatus joint_execution_status =\n        robot.set_joint_positions(joint_pos, joint_groups,joint_names, \n            is_block, speed_rad_s,timeout_s);\n\n    if (joint_execution_status == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5173\u8282\u547d\u4ee4\u8bbe\u7f6e\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u5173\u8282\u547d\u4ee4\u8bbe\u7f6e\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u6839\u636e\u5173\u8282\u7ec4\u67e5\u8be2\u5173\u8282\u4f4d\u7f6e\uff0c\u4f20\u5165\u7a7a\u6570\u7ec4\u9ed8\u8ba4\u586b\u5145\u817f\u3001\u5934\u3001\u53cc\u81c2\u5173\u8282\u7ec4\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e3a\u6307\u5b9a\u5173\u8282\u540d\u79f0\uff0c\u5982\u586b\u5199\u5c06\u8986\u76d6joint_groups\u53c2\u6570\u3002\n    auto ret_positions = robot.get_joint_positions(joint_groups, {});\n    for (auto position : ret_positions) {\n        std::cout &lt;&lt; \"joint positions is \" &lt;&lt; position &lt;&lt; std::endl;\n    }\n\n    // \u4f7f\u7528\u7279\u5b9a\u5173\u8282\u540d\u79f0\u8fdb\u884c\u63a7\u5236\uff0c\u8be5\u53c2\u6570\u5c06\u8986\u76d6joint_groups\u5173\u8282\u7ec4\u53c2\u6570\n    joint_names = {\"head_joint1\", \"head_joint2\"};\n    joint_pos = {0.0, 0.0};\n\n    // \u8bbe\u7f6e\u5173\u8282\u4f4d\u7f6e\n    joint_execution_status = robot.set_joint_positions(joint_pos, joint_groups,joint_names, \n            is_block, speed_rad_s,timeout_s);\n\n    if (joint_execution_status == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5173\u8282\u547d\u4ee4\u8bbe\u7f6e\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u5173\u8282\u547d\u4ee4\u8bbe\u7f6e\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u6839\u636e\u5173\u8282\u7ec4\u67e5\u8be2\u5173\u8282\u4f4d\u7f6e\uff0c\u4f20\u5165\u7a7a\u6570\u7ec4\u9ed8\u8ba4\u586b\u5145\u817f\u3001\u5934\u3001\u53cc\u81c2\u5173\u8282\u7ec4\u3002\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e3a\u6307\u5b9a\u5173\u8282\u540d\u79f0\uff0c\u5982\u586b\u5199\u5c06\u8986\u76d6joint_groups\u53c2\u6570\u3002\n    ret_positions = robot.get_joint_positions(joint_groups, {});\n    for (auto position : ret_positions) {\n        std::cout &lt;&lt; \"joint positions is \" &lt;&lt; position &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#set_gripper_command","title":"\u8bbe\u7f6e\u5939\u722a\u6307\u4ee4\uff08set_gripper_command\uff09","text":"examples/cpp/galbot_robot/src/set_gripper_command_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_gripper_state(\n    std::shared_ptr&lt;galbot::sdk::g1::GripperState&gt; gripper_state) {\n    std::cout &lt;&lt; \"Timestamp (ns): \" &lt;&lt; gripper_state-&gt;timestamp_ns &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \" width \"  &lt;&lt; gripper_state-&gt;width &lt;&lt; \" velocity \" &lt;&lt; gripper_state-&gt;velocity\n                &lt;&lt; \" effort \" &lt;&lt; gripper_state-&gt;effort &lt;&lt; \" is moving \"\n                &lt;&lt; gripper_state-&gt;is_moving &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u5939\u722a\u5bbd\u5ea6\uff08\u7c73\uff09\n    double width_m = 0.1;\n    // \u5939\u722a\u901f\u5ea6\uff08\u7c73/\u79d2\uff09\n    double velocity_mps = 0.05;\n    // \u5939\u722a\u529b\u77e9\uff08\u725b\u7c73\uff09\n    double effort = 10;\n    // \u662f\u5426\u963b\u585e\u7b49\u5f85\u6267\u884c\u5b8c\u6210\n    bool is_blocking = true;\n    // \u8bbe\u7f6e\u5de6\u5939\u722a\u5bbd\u5ea6\u4e3a0.1\u7c73\uff0c\u4ee50.05\u7c73\u901f\u5ea6\u6267\u884c\uff0c\u529b\u77e9\u4e3a10\uff0c\u5e76\u963b\u585e\u7b49\u5f85\u6267\u884c\u5b8c\u6210\n    galbot::sdk::g1::ControlStatus gripper_execution_status =\n        robot.set_gripper_command(JointGroup::LEFT_GRIPPER, width_m, velocity_mps,\n                                        effort, is_blocking);\n\n    if (gripper_execution_status == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5939\u722a\u547d\u4ee4\u8bbe\u7f6e\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u5939\u722a\u547d\u4ee4\u8bbe\u7f6e\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u83b7\u53d6\u5939\u722a\u72b6\u6001\n    galbot::sdk::g1::JointStateMessage joint_state;\n    auto gripper_state_ptr = robot.get_gripper_state(JointGroup::LEFT_GRIPPER);\n\n    if (gripper_state_ptr == nullptr) {\n        std::cerr &lt;&lt; \"get gripper state error\" &lt;&lt; std::endl;\n    } else {\n        print_gripper_state(gripper_state_ptr);\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#set_suction_cup_command","title":"\u8bbe\u7f6e\u5438\u76d8\u6307\u4ee4\uff08set_suction_cup_command\uff09","text":"examples/cpp/galbot_robot/src/set_suction_cup_command_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u6fc0\u6d3b\u5438\u76d8\n    if (robot.set_suction_cup_command(JointGroup::RIGHT_SUCTION_CUP, true) == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5438\u76d8\u6fc0\u6d3b\u6307\u4ee4\u53d1\u9001\u6210\u529f\" &lt;&lt; std::endl;\n\n    } else {\n        std::cerr &lt;&lt; \"\u5438\u76d8\u6fc0\u6d3b\u6307\u4ee4\u53d1\u9001\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n    // \u5173\u95ed\u5438\u76d8\n    if (robot.set_suction_cup_command(JointGroup::RIGHT_SUCTION_CUP, false) == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5438\u76d8\u5173\u95ed\u6307\u4ee4\u53d1\u9001\u6210\u529f\" &lt;&lt; std::endl;\n\n    } else {\n        std::cerr &lt;&lt; \"\u5438\u76d8\u5173\u95ed\u6307\u4ee4\u53d1\u9001\u5931\u8d25\" &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#stop_trajectory_execution","title":"\u505c\u6b62\u8f68\u8ff9\u6267\u884c\uff08stop_trajectory_execution\uff09","text":"examples/cpp/galbot_robot/src/stop_trajectory_execution_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u53d1\u9001\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u6307\u4ee4\n    while(true) {\n        galbot::sdk::g1::ControlStatus joint_execution_status =\n            robot.stop_trajectory_execution();\n\n        // \u68c0\u67e5\u6267\u884c\u7ed3\u679c\n        if (joint_execution_status == ControlStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u6307\u4ee4\u53d1\u9001\u6210\u529f\" &lt;&lt; std::endl;\n            break;\n        } else {\n            std::cerr &lt;&lt; \"\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u6307\u4ee4\u53d1\u9001\u5931\u8d25\uff0c\u91cd\u8bd5\u4e2d...\" &lt;&lt; std::endl;\n        }\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#execute_joint_trajectory","title":"\u8bbe\u7f6e\u8f68\u8ff9\uff08execute_joint_trajectory\uff09","text":"examples/cpp/galbot_robot/src/execute_joint_trajectory_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\ndouble g_target_time = 10;\ndouble g_start_time = 10;\n\nstd::string trajectory_status_to_string(\n    galbot::sdk::g1::TrajectoryControlStatus status) {\n  switch (status) {\n  case galbot::sdk::g1::TrajectoryControlStatus::INVALID_INPUT:\n    return \"INVALID_INPUT\";\n  case galbot::sdk::g1::TrajectoryControlStatus::RUNNING:\n    return \"RUNNING\";\n  case galbot::sdk::g1::TrajectoryControlStatus::COMPLETED:\n    return \"COMPLETED\";\n  case galbot::sdk::g1::TrajectoryControlStatus::STOPPED_UNREACHED:\n    return \"STOPPED_UNREACHED\";\n  case galbot::sdk::g1::TrajectoryControlStatus::ERROR:\n    return \"ERROR\";\n  case galbot::sdk::g1::TrajectoryControlStatus::DATA_FETCH_FAILED:\n    return \"DATA_FETCH_FAILED\";\n  case galbot::sdk::g1::TrajectoryControlStatus::STATUS_NUM:\n    return \"STATUS_NUM\";\n  default:\n    return \"UNKNOWN_STATUS\";\n  }\n}\n\nvoid wait_for_traj_reached(const std::vector&lt;std::string&gt; &amp;joint_groups) {\n    std::vector&lt;galbot::sdk::g1::TrajectoryControlStatus&gt; traj_exec_states;\n    int count = 0;\n    bool all_reached = false;\n    while (count++ &lt; 150) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        all_reached = true;\n        traj_exec_states = galbot::sdk::g1::GalbotRobot::get_instance()\n                            .check_trajectory_execution_status(joint_groups);\n        if (traj_exec_states.size() != joint_groups.size()) {\n        std::cout &lt;&lt; \"traj_exec_states size != joint_groups size\" &lt;&lt; std::endl;\n        }\n        for (int i = 0; i &lt; joint_groups.size(); ++i) {\n        std::cout &lt;&lt; joint_groups[i] &lt;&lt; \" exec state is \"\n                    &lt;&lt; trajectory_status_to_string(traj_exec_states[i])\n                    &lt;&lt; std::endl;\n        if (traj_exec_states[i] !=\n            galbot::sdk::g1::TrajectoryControlStatus::COMPLETED) {\n            all_reached = false;\n        }\n        }\n\n        if (all_reached) {\n            std::cout &lt;&lt; \"all reached\" &lt;&lt; std::endl;\n            break;\n        }\n    }\n    for (const auto &amp;status : traj_exec_states) {\n        std::cout &lt;&lt; \"done reached state is \" &lt;&lt; trajectory_status_to_string(status)\n                &lt;&lt; std::endl;\n    }\n}\n\nstd::vector&lt;galbot::sdk::g1::TrajectoryPoint&gt;\ngenerate_target_trajectory(int32_t joint_size, double ampl = 0.2,\n                           double cycle = 10) {\n  double amplitude = -ampl;\n  double frequency = 1.0 / cycle;\n  double phase = -M_PI / 2;\n  double offset = amplitude;\n  double dt = 0.004;\n  int step = g_target_time / dt;\n\n  std::vector&lt;galbot::sdk::g1::TrajectoryPoint&gt; trajectory_data_vec;\n  trajectory_data_vec.resize(step + 1);\n  // \u521b\u5efa RobotCommand \u8f68\u8ff9\n  for (int i = 0; i &lt;= step; ++i) {\n    double t = i * dt;\n    trajectory_data_vec[i].time_from_start_second = g_start_time + t;\n    trajectory_data_vec[i].joint_command_vec.resize(joint_size);\n    // \u6dfb\u52a0\u5173\u8282\u547d\u4ee4\n    for (int j = 0; j &lt; joint_size; ++j) {\n      trajectory_data_vec[i].joint_command_vec[j].position =\n          offset + amplitude * std::sin(2 * M_PI * frequency * t + phase);\n      trajectory_data_vec[i].joint_command_vec[j].velocity =\n          amplitude * 2 * M_PI * frequency *\n          std::cos(2 * M_PI * frequency * t + phase);\n    }\n  }\n\n  return trajectory_data_vec;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u6267\u884c\u5173\u8282\u8f68\u8ff9\n    Trajectory trajectory;\n    // \u586b\u5199\u8981\u63a7\u5236\u7684\u5173\u8282\u7ec4\u540d\u79f0\uff0c\u5173\u8282\u7ec4\u540d\u79f0\u5305\u62ec[\"leg\", \"head\", \"left_arm\", \"right_arm\"\uff0c\"left_gripper\", \"right_gripper\"]\n    trajectory.joint_groups = {\"head\"};\n    // \u5982\u9700\u63a7\u5236\u6307\u5b9a\u5173\u8282\u89d2\u5ea6\uff0c\u53ef\u586b\u5199\u8be5\u5b57\u6bb5\uff0c\u5982\u586b\u5199\u5c06\u8986\u76d6joint_groups\u5b57\u6bb5\n    trajectory.joint_names = {};\n    // \u751f\u6210\u8f68\u8ff9\n    trajectory.points = generate_target_trajectory(2);\n    // \u662f\u5426\u963b\u585e\u7b49\u5f85\u8f68\u8ff9\u6267\u884c\u5b8c\u6210\uff0cfalse\u65f6\u53ef\u4f7f\u7528\n    bool is_traj_block = false;\n\n    // \u7b49\u5f85\u8f68\u8ff9\u6267\u884c\u5b8c\u6210\uff0c\u6b64\u51fd\u6570\u5c01\u88c5\u4e86check_trajectory_execution_status\u51fd\u6570\uff0c\u7528\u4e8e\u68c0\u67e5\u8f68\u8ff9\u6267\u884c\u72b6\u6001\n    wait_for_traj_reached(trajectory.joint_groups);\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#stop_base","title":"\u505c\u6b62\u5e95\u76d8\u8fd0\u52a8\uff08stop_base\uff09","text":"examples/cpp/galbot_robot/src/stop_base_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u505c\u6b62\u5e95\u76d8\u8fd0\u52a8\n    while (true) {\n        ControlStatus status = robot.stop_base();\n        if (status == ControlStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u5e95\u76d8\u5df2\u6210\u529f\u505c\u6b62\u8fd0\u52a8\uff01\" &lt;&lt; std::endl;\n            break;\n        } else {\n            std::cerr &lt;&lt; \"\u5e95\u76d8\u505c\u6b62\u8fd0\u52a8\u5931\u8d25\uff0c\u6b63\u5728\u91cd\u8bd5...\" &lt;&lt; std::endl;\n        }\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#set_base_velocity","title":"\u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\uff08set_base_velocity\uff09","text":"examples/cpp/galbot_robot/src/set_base_velocity_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u8bf7\u786e\u8ba4\u5468\u8fb9\u73af\u5883\u518d\u8fdb\u884c\u5e95\u76d8\u6d4b\u8bd5\n    // \u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\uff0clinear_velocity\u524d\u4e24\u4e2a\u5b57\u6bb5\u4e3a\u5e95\u76d8x\u4e0ey\u65b9\u5411\u901f\u5ea6\uff0cangular_velocity\u7b2c\u4e09\u4e2a\u5b57\u6bb5\u4e3az\u65b9\u5411\u65cb\u8f6c\u901f\u5ea6\n    // \u6ce8\u610f\uff0c\u5728\u4e0b\u53d1\u505c\u6b62\u547d\u4ee4\u524d\u5e95\u76d8\u5c06\u4e00\u76f4\u4ee5\u6b64\u901f\u5ea6\u8fd0\u52a8\n    std::array&lt;double, 3&gt; linear_velocity = {0.1, 0.0, 0.0};    // \u524d\u8fdb 0.1 m/s\n    std::array&lt;double, 3&gt; angular_velocity = {0.0, 0.0, 0.1};   // \u65cb\u8f6c 0.1 rad/s\n\n    if (robot.set_base_velocity(linear_velocity, angular_velocity) == ControlStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u5e95\u76d8\u901f\u5ea6\u8bbe\u7f6e\u6210\u529f\u3002\" &lt;&lt; std::endl;\n\n    } else {\n        std::cerr &lt;&lt; \"\u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\u5931\u8d25\u3002\" &lt;&lt; std::endl;\n    }\n\n    // \u8ba9\u5e95\u76d8\u8fd0\u52a80.5\u79d2(\u73af\u5883\u7a7a\u65f7\u53ef\u4ee5\u8ba9\u5e95\u76d8\u8fd0\u52a83\uff5e5\u79d2\u4ee5\u89c2\u5bdf\u6548\u679c)\n    std::this_thread::sleep_for(std::chrono::milliseconds(500));\n\n    // \u505c\u6b62\u5e95\u76d8\u8fd0\u52a8\n    while (true) {\n        ControlStatus status = robot.stop_base();\n        if (status == ControlStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u5e95\u76d8\u5df2\u6210\u529f\u505c\u6b62\u8fd0\u52a8\uff01\" &lt;&lt; std::endl;\n            break;\n        } else {\n            std::cerr &lt;&lt; \"\u5e95\u76d8\u505c\u6b62\u8fd0\u52a8\u5931\u8d25\uff0c\u6b63\u5728\u91cd\u8bd5...\" &lt;&lt; std::endl;\n        }\n    }\n\n    // TODO: \u7a0b\u5e8f\u8fd0\u884c\u7ed3\u675f\u5c06\u5e95\u76d8\u63a7\u5236\u5668\u5207\u6362\u56de\u4f4d\u7f6e\u63a7\u5236\u5668\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_joint_states","title":"\u83b7\u53d6\u5173\u8282\u72b6\u6001\uff08get_joint_states\uff09","text":"examples/cpp/galbot_robot/src/get_joint_states_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_joint_states(const std::vector&lt;JointState&gt;&amp; joint_states) {\n    for (const auto&amp; states : joint_states) {\n        std::cout &lt;&lt; \"--- Joint State ---\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Position:     \" &lt;&lt; states.position     &lt;&lt; \" rad\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Velocity:     \" &lt;&lt; states.velocity     &lt;&lt; \" rad/s\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Acceleration: \" &lt;&lt; states.acceleration &lt;&lt; \" rad/s^2\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Effort:       \" &lt;&lt; states.effort       &lt;&lt; \" Nm\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"Current:      \" &lt;&lt; states.current      &lt;&lt; \" A\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; \"------------------\" &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u4f7f\u7528\u5173\u8282\u7ec4\u540d\u79f0\u83b7\u53d6\u5173\u8282\u72b6\u6001\uff0c\u4e3a\u7a7a\u9ed8\u8ba4\u8fd4\u56de\u6240\u6709\u5173\u8282\n    std::vector&lt;std::string&gt; joint_groups = {\"left_arm\"};\n    auto ret_states = robot.get_joint_states(joint_groups, {});\n    print_joint_states(ret_states);\n\n    // \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u72b6\u6001\uff0c\u5982\u679c\u586b\u5145\u5c06\u8986\u76d6\u5173\u8282\u7ec4\u8f93\u5165\n    std::vector&lt;std::string&gt; joint_names = {\"left_arm_joint1\", \"left_arm_joint2\"};\n    ret_states = robot.get_joint_states(joint_groups, joint_names);\n    print_joint_states(ret_states);\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_joint_positions","title":"\u83b7\u53d6\u5173\u8282\u4f4d\u7f6e\uff08get_joint_positions\uff09","text":"examples/cpp/galbot_robot/src/get_joint_positions_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_joint_positions(const std::vector&lt;double&gt;&amp; positions) {\n    for (const auto&amp; pos : positions) {\n        std::cout &lt;&lt; \"joint positions is \" &lt;&lt; pos &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u4f7f\u7528\u5173\u8282\u7ec4\u540d\u79f0\u83b7\u53d6\u5173\u8282\u4f4d\u7f6e\uff0c\u4e3a\u7a7a\u9ed8\u8ba4\u8fd4\u56de\u6240\u6709\u5173\u8282\n    std::vector&lt;std::string&gt; joint_groups = {\"left_arm\"};\n    auto ret_positions = robot.get_joint_positions(joint_groups, {});\n    std::cout &lt;&lt; \"\u5de6\u81c2\u5173\u8282\u4f4d\u7f6e\uff1a\" &lt;&lt; std::endl;\n    print_joint_positions(ret_positions);\n\n    // \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u4f4d\u7f6e\uff0c\u5982\u679c\u586b\u5145\u5c06\u8986\u76d6\u5173\u8282\u7ec4\u8f93\u5165\n    std::vector&lt;std::string&gt; joint_names = {\"left_arm_joint1\", \"left_arm_joint2\"};\n    ret_positions = robot.get_joint_positions({joint_groups}, joint_names);\n    std::cout &lt;&lt; \"\u5de6\u81c2\u5173\u82821\u53ca\u5173\u82822\u4f4d\u7f6e\uff1a\" &lt;&lt; std::endl;\n    print_joint_positions(ret_positions);\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_joint_names","title":"\u83b7\u53d6\u5173\u8282\u540d\u79f0\uff08get_joint_names\uff09","text":"examples/cpp/galbot_robot/src/get_joint_names_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u540d\u79f0\uff0c\u5173\u8282\u7ec4\u540d\u79f0\u5305\u62ec[\"leg\", \"head\", \"left_arm\", \"right_arm\"]\n    std::vector&lt;std::string&gt; joint_groups = {\"head\"};\n    bool only_active_joint = true;  // \u83b7\u53d6\u53ef\u6d3b\u52a8\u5173\u8282\n    auto head_joint_names_vec =\n        robot.get_joint_names(only_active_joint, joint_groups);\n    std::cout &lt;&lt; \"Head joint names:\" &lt;&lt; std::endl;\n    for (size_t i = 0; i &lt; head_joint_names_vec.size(); ++i) {\n        std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; head_joint_names_vec[i] &lt;&lt; std::endl;\n    }\n\n    // \u4f20\u5165\u7a7a\u6570\u7ec4\u9ed8\u8ba4\u83b7\u53d6\u6240\u6709\u5173\u8282\u7ec4\u4fe1\u606f\n    std::vector&lt;std::string&gt; null_vec = {};\n    auto all_joint_names_vec =\n        robot.get_joint_names(only_active_joint, null_vec);\n    std::cout &lt;&lt; \"All joint names:\" &lt;&lt; std::endl;\n    for (size_t i = 0; i &lt; all_joint_names_vec.size(); ++i) {\n        std::cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; all_joint_names_vec[i] &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_gripper_state","title":"\u83b7\u53d6\u5939\u722a\u72b6\u6001\uff08get_gripper_state\uff09","text":"examples/cpp/galbot_robot/src/get_gripper_state_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_gripper_state(\n    std::shared_ptr&lt;galbot::sdk::g1::GripperState&gt; gripper_state) {\n    std::cout &lt;&lt; \"Timestamp (ns): \" &lt;&lt; gripper_state-&gt;timestamp_ns &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \" width \"  &lt;&lt; gripper_state-&gt;width &lt;&lt; \" velocity \" &lt;&lt; gripper_state-&gt;velocity\n                &lt;&lt; \" effort \" &lt;&lt; gripper_state-&gt;effort &lt;&lt; \" is moving \"\n                &lt;&lt; gripper_state-&gt;is_moving &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u5939\u722a\u72b6\u6001\n    auto gripper_state_ptr = robot.get_gripper_state(JointGroup::LEFT_GRIPPER);\n\n    if (gripper_state_ptr == nullptr) {\n        std::cerr &lt;&lt; \"get gripper state error\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"\u5de6\u5939\u722a\u72b6\u6001\uff1a\" &lt;&lt; std::endl;\n        print_gripper_state(gripper_state_ptr);\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_suction_cup_state","title":"\u83b7\u53d6\u5438\u76d8\u72b6\u6001\uff08get_suction_cup_state\uff09","text":"examples/cpp/galbot_robot/src/get_suction_cup_state_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_suction_cup_state(\n    std::shared_ptr&lt;galbot::sdk::g1::SuctionCupState&gt; suction_cup_state) {\n    std::cout &lt;&lt; \"Timestamp (ns): \" &lt;&lt; suction_cup_state-&gt;timestamp_ns &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Activation: \" &lt;&lt; suction_cup_state-&gt;activation &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pressure: \" &lt;&lt; suction_cup_state-&gt;pressure &lt;&lt; \" Pa\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Action State: \" &lt;&lt; int(suction_cup_state-&gt;action_state) &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u5438\u76d8\u72b6\u6001\n    auto suction_cup_state_ptr = robot.get_suction_cup_state(JointGroup::RIGHT_SUCTION_CUP);\n\n    if (suction_cup_state_ptr == nullptr) {\n        std::cerr &lt;&lt; \"get suction cup state error\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"\u53f3\u5438\u76d8\u72b6\u6001\uff1a\" &lt;&lt; std::endl;\n        print_suction_cup_state(suction_cup_state_ptr);\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_transform","title":"\u83b7\u53d6\u5750\u6807\u53d8\u6362\uff08get_transform\uff09","text":"examples/cpp/galbot_robot/src/get_transform_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_pose_vec(const std::vector&lt;double&gt; &amp;pose_vec) {\n    // \u8f93\u51fa pose_vec\n    std::cout &lt;&lt; \"pose_vec = [\";\n    for (size_t i = 0; i &lt; pose_vec.size(); ++i) {\n        std::cout &lt;&lt; pose_vec[i];\n        if (i + 1 &lt; pose_vec.size())\n        std::cout &lt;&lt; \", \";\n    }\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u5750\u6807\u53d8\u6362\n    std::pair&lt;std::vector&lt;double&gt;, int64_t&gt; tf_ret = robot.get_transform(\"left_arm_link1\", \"left_arm_link7\", 0);\n\n    if (tf_ret.first.empty()) {\n        std::cout &lt;&lt; \"get_transform error\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"tf_timestamp_ns: \" &lt;&lt; tf_ret.second &lt;&lt; std::endl;\n        print_pose_vec(tf_ret.first);\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#imuget_imu_data","title":"\u83b7\u53d6imu\u6570\u636e\uff08get_imu_data\uff09","text":"examples/cpp/galbot_robot/src/get_imu_data_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_imu_data(const std::shared_ptr&lt;ImuData&gt;&amp; imu_data) {\n    if (!imu_data) {\n        std::cerr &lt;&lt; \"IMU data is empty\" &lt;&lt; std::endl;\n        return;\n    }\n\n    std::cout &lt;&lt; \"Timestamp (ns): \" &lt;&lt; imu_data-&gt;timestamp_ns &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Accelerometer: \"\n              &lt;&lt; \"x=\" &lt;&lt; imu_data-&gt;accel.x &lt;&lt; \", \"\n              &lt;&lt; \"y=\" &lt;&lt; imu_data-&gt;accel.y &lt;&lt; \", \"\n              &lt;&lt; \"z=\" &lt;&lt; imu_data-&gt;accel.z &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Gyroscope: \"\n              &lt;&lt; \"x=\" &lt;&lt; imu_data-&gt;gyro.x &lt;&lt; \", \"\n              &lt;&lt; \"y=\" &lt;&lt; imu_data-&gt;gyro.y &lt;&lt; \", \"\n              &lt;&lt; \"z=\" &lt;&lt; imu_data-&gt;gyro.z &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Magnetometer: \"\n              &lt;&lt; \"x=\" &lt;&lt; imu_data-&gt;magnet.x &lt;&lt; \", \"\n              &lt;&lt; \"y=\" &lt;&lt; imu_data-&gt;magnet.y &lt;&lt; \", \"\n              &lt;&lt; \"z=\" &lt;&lt; imu_data-&gt;magnet.z &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6imu\u6570\u636e\n    std::shared_ptr&lt;ImuData&gt; imu_data = robot.get_imu_data(SensorType::TORSO_IMU);\n    if (imu_data) {\n        std::cout &lt;&lt; \"IMU\u6570\u636e\u83b7\u53d6\u6210\u529f\uff01\" &lt;&lt; std::endl;\n        print_imu_data(imu_data);\n    } else {\n        std::cerr &lt;&lt; \"IMU\u6570\u636e\u83b7\u53d6\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_rgb_data-get_depth_dataget_camera_data","title":"\u83b7\u53d6\u76f8\u673a\u56fe\u50cf\u6570\u636e\uff08get_rgb_data &amp;&amp; get_depth_data\uff09(get_camera_data)","text":"examples/cpp/galbot_robot/src/get_camera_data_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_set&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\n#include \"galbot_robot.hpp\"\n#include \"opencv2/opencv.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nvoid print_rgb_data(\n  const std::shared_ptr&lt;galbot::sdk::g1::RgbData&gt; &amp;rgb_data) {\n  if (rgb_data == nullptr) {\n    std::cout &lt;&lt; \"rgb_data is nullptr\" &lt;&lt; std::endl;\n    return;\n  }\n\n  std::cout &lt;&lt; \"Camera image timestamp: \"\n            &lt;&lt; rgb_data-&gt;header.stamp.sec &lt;&lt; \".\" &lt;&lt; std::setw(9)\n            &lt;&lt; std::setfill('0') &lt;&lt; rgb_data-&gt;header.stamp.nanosec\n            &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"format is \" &lt;&lt; rgb_data-&gt;format &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"frame_id is \" &lt;&lt; rgb_data-&gt;header.frame_id &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"data size is \" &lt;&lt; rgb_data-&gt;data.size() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"show image:\";\n\n  std::shared_ptr&lt;cv::Mat&gt; img = rgb_data-&gt;convert_to_cv2_mat();\n\n  cv::imwrite(\"result_image.jpg\", *img);\n\n  std::cout &lt;&lt; \"\u56fe\u7247\u5df2\u4fdd\u5b58\u81f3 result_image.jpg\" &lt;&lt; std::endl;\n}\n\nvoid print_depth_data(\n    const std::shared_ptr&lt;galbot::sdk::g1::DepthData&gt;\n        depth_data_ptr) {\n  if (depth_data_ptr == nullptr) {\n    std::cout &lt;&lt; \"depth_data_ptr is nullptr\" &lt;&lt; std::endl;\n    return;\n  }\n\n  std::cout &lt;&lt; \"Camera image timestamp: \"\n            &lt;&lt; depth_data_ptr-&gt;header.stamp.sec &lt;&lt; \".\" &lt;&lt; std::setw(9)\n            &lt;&lt; std::setfill('0') &lt;&lt; depth_data_ptr-&gt;header.stamp.nanosec\n            &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"format is \" &lt;&lt; depth_data_ptr-&gt;format &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"frame_id is \" &lt;&lt; depth_data_ptr-&gt;header.frame_id &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"data size is \" &lt;&lt; depth_data_ptr-&gt;data.size() &lt;&lt; std::endl;\n\n  std::shared_ptr&lt;cv::Mat&gt; img = depth_data_ptr-&gt;convert_to_cv2_mat();\n\n  if (img &amp;&amp; !img-&gt;empty()) {\n    cv::Mat img_vis;\n\n    // \u56fe\u7247\u4fe1\u606f\u5f52\u4e00\u5316\n    cv::normalize(*img, img_vis, 0, 255, cv::NORM_MINMAX, CV_8UC1);\n\n    // \u4f2a\u5f69\u8272\u589e\u5f3a\n    cv::Mat img_color;\n    cv::applyColorMap(img_vis, img_color, cv::COLORMAP_JET);\n\n    // \u4fdd\u5b58\u56fe\u7247\n    cv::imwrite(\"check_raw_data.png\", *img); \n    cv::imwrite(\"check_visual_view.jpg\", img_color); \n\n    std::cout &lt;&lt; \"\u56fe\u7247\u4fdd\u5b58\u5b8c\u6bd5\uff1a\\n\"\n              &lt;&lt; \"1. check_raw_data.png -&gt; \u5305\u542b\u771f\u5b9e\u7269\u7406\u6df1\u5ea6\u7684\u5168\u9ed1\u56fe\\n\"\n              &lt;&lt; \"2. check_visual_view.jpg -&gt; \u80fd\u770b\u6e05\u7269\u4f53\u8f6e\u5ed3\u7684\u5f69\u8272\u56fe\" &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u4f20\u611f\u5668\uff0c\u4e3a\u8282\u7701\u8d44\u6e90\uff0c\u53ea\u6709\u521d\u59cb\u5316\u4e2d\u4f20\u5165\u7684\u76f8\u673a\u4e0e\u96f7\u8fbe\u4f20\u611f\u5668\u53ef\u83b7\u53d6\u6570\u636e\n    std::unordered_set&lt;SensorType&gt; sensor_types =  {\n        SensorType::HEAD_LEFT_CAMERA,       // \u5934\u90e8\u5de6\u76f8\u673a\n        SensorType::LEFT_ARM_DEPTH_CAMERA,  // \u5de6\u81c2\u6df1\u5ea6\u76f8\u673a\n    };\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init(sensor_types)) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    // \u7b49\u5f85\u76f8\u673a\u6570\u636e\u5c31\u7eea\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6 RGB \u56fe\u50cf\u6570\u636e\n    std::shared_ptr&lt;RgbData&gt; rgb_data = robot.get_rgb_data(SensorType::HEAD_LEFT_CAMERA);\n    if (rgb_data) {\n        std::cout &lt;&lt; \"RGB \u56fe\u50cf\u6570\u636e\u83b7\u53d6\u6210\u529f\uff01\" &lt;&lt; std::endl;\n        print_rgb_data(rgb_data);\n    } else {\n        std::cerr &lt;&lt; \"RGB \u56fe\u50cf\u6570\u636e\u83b7\u53d6\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u83b7\u53d6\u6df1\u5ea6\u56fe\u50cf\u6570\u636e\n    std::shared_ptr&lt;DepthData&gt; depth_data = robot.get_depth_data(SensorType::LEFT_ARM_DEPTH_CAMERA);\n    if (depth_data) {\n        std::cout &lt;&lt; \"\u6df1\u5ea6\u56fe\u50cf\u6570\u636e\u83b7\u53d6\u6210\u529f\uff01\" &lt;&lt; std::endl;\n        print_depth_data(depth_data);\n    } else {\n        std::cerr &lt;&lt; \"\u6df1\u5ea6\u56fe\u50cf\u6570\u636e\u83b7\u53d6\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_lidar_data","title":"\u83b7\u53d6\u96f7\u8fbe\u6570\u636e\uff08get_lidar_data\uff09","text":"examples/cpp/galbot_robot/src/get_lidar_data_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;fstream&gt;\n#include &lt;cmath&gt;\n#include &lt;chrono&gt;\n#include &lt;thread&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_set&gt;\n\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u5b9a\u4e49\u70b9\u7ed3\u6784\u4f53\nstruct Point3D {\n    float x, y, z;\n};\n\n/**\n * \u76f4\u63a5\u901a\u8fc7\u6307\u9488\u64cd\u4f5c\u4ece LidarData \u4e2d\u63d0\u53d6 XYZ \u6570\u7ec4\n */\nstd::vector&lt;Point3D&gt; get_xyz_points(const std::shared_ptr&lt;LidarData&gt;&amp; cloud, bool remove_nan = false) {\n    std::vector&lt;Point3D&gt; points;\n    if (!cloud || cloud-&gt;data.empty()) return points;\n\n    // 1. \u67e5\u627e x, y, z \u5b57\u6bb5\u7684\u504f\u79fb\u91cf (offset)\n    // Python \u7248\u4e2d\u901a\u8fc7 field name \u7d22\u5f15\uff0c\u8fd9\u91cc\u6211\u4eec\u9884\u5148\u627e\u5230\u504f\u79fb\u91cf\u4ee5\u63d0\u9ad8\u6548\u7387\n    int32_t off_x = -1, off_y = -1, off_z = -1;\n    for (const auto&amp; f : cloud-&gt;fields) {\n        if (f.name == \"x\") off_x = f.offset;\n        else if (f.name == \"y\") off_y = f.offset;\n        else if (f.name == \"z\") off_z = f.offset;\n    }\n\n    if (off_x == -1 || off_y == -1 || off_z == -1) {\n        std::cerr &lt;&lt; \"\u9519\u8bef: \u70b9\u4e91\u6570\u636e\u7f3a\u5c11\u5fc5\u8981\u7684 xyz \u5b57\u6bb5\" &lt;&lt; std::endl;\n        return points;\n    }\n\n    uint32_t num_points = cloud-&gt;width * cloud-&gt;height;\n    points.reserve(num_points);\n\n    const uint8_t* raw_data = cloud-&gt;data.data();\n    uint32_t point_step = cloud-&gt;point_step;\n\n    // 2. \u76f4\u63a5\u6307\u9488\u8bfb\u53d6\uff08\u96f6\u62f7\u8d1d\u6838\u5fc3\u903b\u8f91\uff09\n    for (uint32_t i = 0; i &lt; num_points; ++i) {\n        // \u8ba1\u7b97\u5f53\u524d\u70b9\u7684\u8d77\u59cb\u6307\u9488\n        const uint8_t* pt_ptr = raw_data + (i * point_step);\n\n        // \u4f7f\u7528 reinterpret_cast \u76f4\u63a5\u8f6c\u6362\u6307\u9488\u7c7b\u578b\u8bfb\u53d6\u5185\u5b58\n        // \u5047\u8bbe\u96f7\u8fbe\u6570\u636e\u662f float32 (F)\uff0c\u8fd9\u662f\u6700\u5e38\u89c1\u7684\u683c\u5f0f\n        float x = *reinterpret_cast&lt;const float*&gt;(pt_ptr + off_x);\n        float y = *reinterpret_cast&lt;const float*&gt;(pt_ptr + off_y);\n        float z = *reinterpret_cast&lt;const float*&gt;(pt_ptr + off_z);\n\n        // \u5904\u7406 NaN (\u5bf9\u5e94 Python \u7684 remove_nan \u903b\u8f91)\n        if (remove_nan) {\n            if (std::isnan(x) || std::isnan(y) || std::isnan(z)) {\n                continue;\n            }\n        }\n\n        points.push_back({x, y, z});\n    }\n\n    return points;\n}\n\n/**\n * \u4fdd\u5b58\u5230 PCD \u6587\u4ef6\n */\nvoid save_xyz_to_pcd(const std::vector&lt;Point3D&gt;&amp; points, const std::string&amp; filename) {\n    std::ofstream fs(filename);\n    if (!fs.is_open()) {\n        std::cerr &lt;&lt; \"\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6\u8fdb\u884c\u5199\u5165: \" &lt;&lt; filename &lt;&lt; std::endl;\n        return;\n    }\n\n    // PCD 0.7 Header\n    fs &lt;&lt; \"# .PCD v0.7 - Point Cloud Data file format\\n\"\n       &lt;&lt; \"VERSION 0.7\\n\"\n       &lt;&lt; \"FIELDS x y z\\n\"\n       &lt;&lt; \"SIZE 4 4 4\\n\"\n       &lt;&lt; \"TYPE F F F\\n\"\n       &lt;&lt; \"COUNT 1 1 1\\n\"\n       &lt;&lt; \"WIDTH \" &lt;&lt; points.size() &lt;&lt; \"\\n\"\n       &lt;&lt; \"HEIGHT 1\\n\"\n       &lt;&lt; \"VIEWPOINT 0 0 0 1 0 0 0\\n\"\n       &lt;&lt; \"POINTS \" &lt;&lt; points.size() &lt;&lt; \"\\n\"\n       &lt;&lt; \"DATA ascii\\n\";\n\n    // Data\n    for (const auto&amp; p : points) {\n        fs &lt;&lt; p.x &lt;&lt; \" \" &lt;&lt; p.y &lt;&lt; \" \" &lt;&lt; p.z &lt;&lt; \"\\n\";\n    }\n\n    fs.close();\n    std::cout &lt;&lt; \"\u5df2\u4fdd\u5b58 \" &lt;&lt; points.size() &lt;&lt; \" \u4e2a\u70b9\u5230 \" &lt;&lt; filename &lt;&lt; std::endl;\n}\n\nint main() {\n    // \u83b7\u53d6\u5bf9\u8c61\u5b9e\u4f8b\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u4f20\u611f\u5668\uff0c\u4e3a\u8282\u7701\u8d44\u6e90\uff0c\u53ea\u6709\u521d\u59cb\u5316\u4e2d\u4f20\u5165\u7684\u76f8\u673a\u4e0e\u96f7\u8fbe\u4f20\u611f\u5668\u53ef\u83b7\u53d6\u6570\u636e\n    std::unordered_set&lt;SensorType&gt; sensor_types =  {\n        SensorType::BASE_LIDAR              // \u5e95\u76d8\u6fc0\u5149\u96f7\u8fbe\n    };\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init(sensor_types)) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n    // \u83b7\u53d6\u6fc0\u5149\u96f7\u8fbe\u6570\u636e\n    std::shared_ptr&lt;LidarData&gt; lidar_data = robot.get_lidar_data(SensorType::BASE_LIDAR);\n    if (lidar_data) {\n        std::cout &lt;&lt; \"\u6fc0\u5149\u96f7\u8fbe\u6570\u636e\u83b7\u53d6\u6210\u529f\uff01\" &lt;&lt; std::endl;\n        std::vector&lt;Point3D&gt; xyz_points = get_xyz_points(lidar_data, false);\n        if (!xyz_points.empty()) {\n            save_xyz_to_pcd(xyz_points, \"output_xyz.pcd\");\n        }\n    } else {\n        std::cerr &lt;&lt; \"\u6fc0\u5149\u96f7\u8fbe\u6570\u636e\u83b7\u53d6\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n    // \u9000\u51fa\u7cfb\u7edf\u5e76\u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#galbotmotion","title":"\u7c7b\uff1aGalbotMotion","text":""},{"location":"examples_cpp/#get_instance-init_1","title":"\u83b7\u53d6\u5b9e\u4f8b\u5e76\u521d\u59cb\u5316\uff08get_instance &amp;&amp; init\uff09","text":"examples/cpp/galbot_motion/src/get_instance_init_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (planner.init()) {\n        std::cout &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 GalbotRobot \u7ba1\u7406\u673a\u5668\u4eba\u751f\u547d\u5468\u671f\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#robotstatesforward_kinematics","title":"\u6b63\u8fd0\u52a8\u5b66\uff08\u4f7f\u7528\u5f53\u524d\u72b6\u6001\u6216\u6307\u5b9a RobotStates\uff09\uff08forward_kinematics\uff09","text":"examples/cpp/galbot_motion/src/forward_kinematics_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u8f85\u52a9\u6253\u5370\u51fd\u6570\nvoid print_pose(const std::string&amp; label, \n                const std::tuple&lt;MotionStatus, std::vector&lt;double&gt;&gt;&amp; res, \n                GalbotMotion&amp; planner) \n{\n    std::cout &lt;&lt; \"[\" &lt;&lt; label &lt;&lt; \"] \u72b6\u6001: \" &lt;&lt; planner.status_to_string(std::get&lt;0&gt;(res)) &lt;&lt; std::endl;\n\n    if (std::get&lt;0&gt;(res) == MotionStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u672b\u7aef\u4f4d\u59ff: \";\n        for (double v : std::get&lt;1&gt;(res)) {\n            std::cout &lt;&lt; v &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; \"\\n\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"\u8ba1\u7b97\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (planner.init()) {\n        std::cout &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n\n    std::map&lt;std::string, std::vector&lt;double&gt;&gt; chain_joints = {\n        {\"leg\",       {0.4992, 1.4991, 1.0005, 0.0000, -0.0004}},\n        {\"head\",      {0.0000, 0.0}},\n        {\"left_arm\",  {1.9999, -1.6000, -0.5999, -1.6999, 0.0000, -0.7999, 0.0000}},\n        {\"right_arm\", {-2.0000, 1.6001, 0.6001, 1.7000, 0.0000, 0.8000, 0.0000}}\n    };\n\n    std::vector&lt;double&gt; whole_body_joint;\n    std::vector&lt;std::string&gt; keys = {\"leg\", \"head\", \"left_arm\", \"right_arm\"};\n    for (const auto&amp; key : keys) {\n        whole_body_joint.insert(whole_body_joint.end(), chain_joints[key].begin(), chain_joints[key].end());\n    }\n\n    std::vector&lt;double&gt; base_state = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};\n    std::string end_link = \"left_arm_end_effector_mount_link\";\n    std::string reference_frame = \"base_link\";\n\n    // --- \u6d4b\u8bd5\u7528\u4f8b 1: \u9ed8\u8ba4\u53c2\u6570 (\u4f7f\u7528\u5f53\u524d\u673a\u5668\u4eba\u72b6\u6001) ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6b63\u5728\u6267\u884c: \u57fa\u7840\u7248\u6b63\u8fd0\u52a8\u5b66...\" &lt;&lt; std::endl;\n        auto res1 = planner.forward_kinematics(end_link, reference_frame);\n        print_pose(\"\u57fa\u7840\u7248\", res1, planner);\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u57fa\u7840\u7248\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // --- \u6d4b\u8bd5\u7528\u4f8b 2: \u81ea\u5b9a\u4e49\u5173\u8282\u72b6\u6001 + \u53c2\u6570 ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6b63\u5728\u6267\u884c: \u81ea\u5b9a\u4e49\u5173\u8282\u6b63\u8fd0\u52a8\u5b66...\" &lt;&lt; std::endl;\n\n        std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; custom_joint_state = {\n            {\"left_arm\", chain_joints[\"left_arm\"]}\n        };\n        auto custom_param_ptr = std::make_shared&lt;Parameter&gt;(); \n        auto res2 = planner.forward_kinematics(end_link, reference_frame, custom_joint_state, custom_param_ptr);\n\n        print_pose(\"\u81ea\u5b9a\u4e49\u53c2\u6570\", res2, planner);\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u81ea\u5b9a\u4e49\u53c2\u6570\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // --- \u6d4b\u8bd5\u7528\u4f8b 3: \u57fa\u4e8e RobotStates \u7684\u6b63\u8fd0\u52a8\u5b66 ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6b63\u5728\u6267\u884c: \u57fa\u4e8e RobotStates \u6b63\u8fd0\u52a8\u5b66...\" &lt;&lt; std::endl;\n\n        auto ref_robot_state_ptr = std::make_shared&lt;RobotStates&gt;();\n        ref_robot_state_ptr-&gt;whole_body_joint = whole_body_joint;\n        ref_robot_state_ptr-&gt;base_state = base_state;\n\n        auto res3 = planner.forward_kinematics_by_state(end_link, ref_robot_state_ptr, reference_frame, std::make_shared&lt;Parameter&gt;());\n\n        print_pose(\"\u57fa\u4e8eRobotStates\", res3, planner);\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u57fa\u4e8eRobotStates\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#robotstatesinverse_kinematics","title":"\u9006\u8fd0\u52a8\u5b66\uff08\u57fa\u7840\u4e0e\u57fa\u4e8e RobotStates\uff09(inverse_kinematics)","text":"examples/cpp/galbot_motion/src/inverse_kinematics_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;algorithm&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u8f85\u52a9\u51fd\u6570\uff1a\u6253\u5370\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u7ed3\u679c\nvoid print_ik_result(const std::string&amp; label, \n                     const std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt;&gt;&amp; res, \n                     GalbotMotion&amp; planner) {\n    auto status = std::get&lt;0&gt;(res);\n    auto joint_map = std::get&lt;1&gt;(res);\n\n    std::cout &lt;&lt; \"[\" &lt;&lt; label &lt;&lt; \"] \u72b6\u6001\u53cd\u9988: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n    if (status == MotionStatus::SUCCESS) {\n        std::cout &lt;&lt; \"\u2705 \u9006\u89e3\u8ba1\u7b97\u6210\u529f\uff01\u5f97\u5230\u7684\u5173\u8282\u89d2\u5ea6\u5982\u4e0b:\" &lt;&lt; std::endl;\n        for (const auto&amp; [name, joints] : joint_map) {\n            std::cout &lt;&lt; \"  - \u94fe\u6761 [\" &lt;&lt; name &lt;&lt; \"]: \";\n            for (double v : joints) std::cout &lt;&lt; v &lt;&lt; \" \";\n            std::cout &lt;&lt; std::endl;\n        }\n    } else {\n        std::cout &lt;&lt; \"\u274c \u9006\u89e3\u8ba1\u7b97\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u8f93\u5165\u6216\u76ee\u6807\u4f4d\u59ff\u662f\u5426\u53ef\u8fbe\u3002\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"---------------------------------------------------\" &lt;&lt; std::endl;\n}\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (planner.init()) {\n        std::cout &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u89c4\u5212\u5668\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    if (robot.init()) {\n        std::cout &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"\u7cfb\u7edf\u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n\n    // \u5173\u8282\u72b6\u6001\u5b9a\u4e49\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_joints = {\n        {\"leg\",       {0.4992, 1.4991, 1.0005, 0.0000, -0.0004}},\n        {\"head\",      {0.0000, 0.0}},\n        {\"left_arm\",  {1.9999, -1.6000, -0.5999, -1.6999, 0.0000, -0.7999, 0.0000}},\n        {\"right_arm\", {-2.0000, 1.6001, 0.6001, 1.7000, 0.0000, 0.8000, 0.0000}}\n    };\n\n    // \u76ee\u6807\u4f4d\u59ff\u5b9a\u4e49 (x, y, z, qx, qy, qz, qw)\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_pose_baselink = {\n        {\"left_arm\",  {0.1267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991}},\n        {\"right_arm\", {0.1267, -0.2345, 0.7358, -0.0225, 0.0126, -0.0343, 0.9991}}\n    };\n\n    // \u5168\u8eab\u4f53\u5173\u8282\u5411\u91cf\u62fc\u63a5 (Leg -&gt; Head -&gt; Left Arm -&gt; Right Arm)\n    std::vector&lt;double&gt; whole_body_joint;\n    std::vector&lt;std::string&gt; key_order = {\"leg\", \"head\", \"left_arm\", \"right_arm\"};\n    for (const auto&amp; key : key_order) {\n        whole_body_joint.insert(whole_body_joint.end(), chain_joints[key].begin(), chain_joints[key].end());\n    }\n\n    // \u901a\u7528\u914d\u7f6e\n    std::string reference_frame = \"base_link\";\n    std::string target_frame = \"EndEffector\";\n    std::string target_chain = \"left_arm\";\n    auto params = std::make_shared&lt;Parameter&gt;();\n\n    // \u573a\u666f 1\uff1a\u5355\u94fe\u9006\u89e3\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 1\uff1a\u5355\u94fe\u9006\u89e3\u6d4b\u8bd5...\" &lt;&lt; std::endl;\n        std::vector&lt;std::string&gt; one_chain = {target_chain};\n\n        auto res = planner.inverse_kinematics(\n            chain_pose_baselink[target_chain], // 1. target_pose\n            one_chain                         // 2. chain_names\n            // target_frame,                      // 3. target_frame\n            // reference_frame,                   // 4. reference_frame\n            // {},                                // 5. initial_joint_positions (\u7a7a)\n            // false,                             // 6. enable_collision_check (bool)\n            // params                             // 7. params (shared_ptr)\n        );\n        print_ik_result(\"\u5355\u94fe\u9006\u89e3\", res, planner);\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u573a\u666f 1 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // \u573a\u666f 2\uff1a\u624b\u81c2\u94fe + \u8170\u90e8\u9006\u89e3\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 2\uff1a\u624b\u81c2\u94fe + \u8170\u90e8\u9006\u89e3\u6d4b\u8bd5...\" &lt;&lt; std::endl;\n        std::vector&lt;std::string&gt; chain_with_torso = {target_chain, \"torso\"};\n\n        auto res = planner.inverse_kinematics(\n            chain_pose_baselink[target_chain],\n            chain_with_torso,\n            target_frame,\n            reference_frame,\n            {},\n            false,\n            params\n        );\n        print_ik_result(\"\u624b\u81c2+\u8170\u90e8\u9006\u89e3\", res, planner);\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u573a\u666f 2 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // \u573a\u666f 3\uff1a\u975e\u6cd5\u94fe\u7ec4\u5408\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 3\uff1a\u975e\u6cd5\u94fe\u7ec4\u5408\u6d4b\u8bd5...\" &lt;&lt; std::endl;\n        std::vector&lt;std::string&gt; error_chains = {target_chain, \"torso\", \"head\"};\n\n        auto res = planner.inverse_kinematics(\n            chain_pose_baselink[target_chain],\n            error_chains,\n            target_frame,\n            reference_frame,\n            {},\n            false,\n            params\n        );\n        print_ik_result(\"\u975e\u6cd5\u94fe\u7ec4\u5408\u68c0\u6d4b\", res, planner);\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u573a\u666f 3 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // \u573a\u666f 4\uff1a\u4f7f\u7528\u53c2\u8003\u5173\u8282 (initial_joint_positions\u53ef\u6307\u5b9a\u94fe\u5173\u8282\u4f5c\u4e3a\u9006\u89e3\u53c2\u8003\u503c\uff0c\u672a\u6307\u5b9a\u94fe\u5173\u8282\u4f7f\u7528\u5168\u8eab\u5173\u8282\u8865\u5168)\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 4\uff1a\u5e26\u521d\u59cb\u53c2\u8003\u503c\u7684\u9006\u89e3\u6d4b\u8bd5...\" &lt;&lt; std::endl;\n        std::vector&lt;std::string&gt; one_chain = {target_chain};\n\n        auto res = planner.inverse_kinematics(\n            chain_pose_baselink[target_chain],\n            one_chain,\n            target_frame,\n            reference_frame,\n            chain_joints,\n            false,\n            params\n        );\n        print_ik_result(\"\u5e26\u53c2\u8003\u503c\u9006\u89e3\", res, planner);\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u573a\u666f 4 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // \u573a\u666f 5\uff1a\u57fa\u4e8e RobotStates \u7684\u9006\u89e3\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 5\uff1a\u57fa\u4e8e RobotStates \u7684\u9006\u89e3\u6d4b\u8bd5...\" &lt;&lt; std::endl;\n\n        // \u6784\u9020 RobotStates \u667a\u80fd\u6307\u9488\n        auto ref_state = std::make_shared&lt;RobotStates&gt;();\n        ref_state-&gt;chain_name = target_chain;\n        ref_state-&gt;whole_body_joint = whole_body_joint;\n        ref_state-&gt;base_state = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};\n\n        std::vector&lt;std::string&gt; one_chain = {target_chain};\n\n        auto res = planner.inverse_kinematics_by_state(\n            chain_pose_baselink[target_chain], // 1. target_pose\n            one_chain,                         // 2. chain_names\n            target_frame,                      // 3. target_frame\n            reference_frame,                   // 4. reference_frame\n            ref_state,                         // 5. reference_robot_states (shared_ptr)\n            false,                             // 6. enable_collision_check (bool)\n            params                             // 7. params (shared_ptr)\n        );\n        print_ik_result(\"RobotStates\u9006\u89e3\", res, planner);\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u573a\u666f 5 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    std::cout &lt;&lt; \"\u8d44\u6e90\u5df2\u91ca\u653e\u3002\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#get_set_end_effort_pos","title":"\u83b7\u53d6\u4e0e\u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff(get_set_end_effort_pos)","text":"examples/cpp/galbot_motion/src/get_set_end_effort_pos_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u8f85\u52a9\u51fd\u6570\uff1a\u6253\u5370\u4f4d\u59ff\u4fe1\u606f\nvoid print_pose_info(const std::string&amp; label, const std::vector&lt;double&gt;&amp; pose) {\n    if (pose.size() == 7) {\n        std::cout &lt;&lt; \"[\" &lt;&lt; label &lt;&lt; \"] \u4f4d\u59ff: \"\n                  &lt;&lt; \"pos(\" &lt;&lt; pose[0] &lt;&lt; \", \" &lt;&lt; pose[1] &lt;&lt; \", \" &lt;&lt; pose[2] &lt;&lt; \"), \"\n                  &lt;&lt; \"ori(\" &lt;&lt; pose[3] &lt;&lt; \", \" &lt;&lt; pose[4] &lt;&lt; \", \" &lt;&lt; pose[5] &lt;&lt; \", \" &lt;&lt; pose[6] &lt;&lt; \")\" \n                  &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_pose_baselink = {\n        {\"leg\",       {0.0596, -0.0000, 1.0327, 0.5000, 0.5003, 0.4997, 0.5000}},\n        {\"head\",      {0.0599, 0.0002, 1.4098, -0.7072, 0.0037, 0.0037, 0.7069}},\n        {\"left_arm\",  {0.1267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991}},\n        {\"right_arm\", {0.097768, -0.226021, 0.8, -0.0117403, -0.0098713, 0.0157502, 0.999758}}\n    };\n\n    std::string reference_frame = \"base_link\";\n    std::string target_frame = \"EndEffector\";\n    std::string target_chain = \"right_arm\";\n    auto custom_param = std::make_shared&lt;Parameter&gt;();\n\n    // --- \u573a\u666f 1\uff1a\u57fa\u7840\u7248\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u573a\u666f 1\uff1a\u6b63\u5728\u83b7\u53d6\u57fa\u7840\u672b\u7aef\u4f4d\u59ff...\" &lt;&lt; std::endl;\n        std::string end_ee_link = \"right_arm_end_effector_mount_link\";\n\n        auto res = planner.get_end_effector_pose(end_ee_link, reference_frame);\n\n        MotionStatus status = std::get&lt;0&gt;(res);\n        std::vector&lt;double&gt; pose = std::get&lt;1&gt;(res);\n\n        std::cout &lt;&lt; \"\u6267\u884c\u72b6\u6001: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n        if (status == MotionStatus::SUCCESS) {\n            print_pose_info(\"\u57fa\u7840\u7248\", pose);\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u573a\u666f 1 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // --- \u573a\u666f 2\uff1a\u6307\u5b9a\u94fe\u540d + \u81ea\u5b9a\u4e49frame\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u573a\u666f 2\uff1a\u6b63\u5728\u6307\u5b9a\u94fe\u540d\u83b7\u53d6\u4f4d\u59ff...\" &lt;&lt; std::endl;\n\n        auto res = planner.get_end_effector_pose_on_chain(target_chain, target_frame, reference_frame);\n\n        MotionStatus status = std::get&lt;0&gt;(res);\n        std::vector&lt;double&gt; pose = std::get&lt;1&gt;(res);\n\n        std::cout &lt;&lt; \"\u6267\u884c\u72b6\u6001: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n        if (status == MotionStatus::SUCCESS) {\n            print_pose_info(\"\u6307\u5b9a\u94fe\u540d\u7248\", pose);\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u573a\u666f 2 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // --- \u573a\u666f 3\uff1a\u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u573a\u666f 3\uff1a\u6b63\u5728\u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff...\" &lt;&lt; std::endl;\n\n        std::string ee_frame = \"right_arm\"; \n        std::vector&lt;double&gt; target_pose = chain_pose_baselink[ee_frame];\n\n        MotionStatus status = planner.set_end_effector_pose(\n            target_pose,        // 1\n            ee_frame,           // 2\n            reference_frame,    // 3\n            nullptr,            // 4. \u91cd\u8981\uff1a\u5982\u679c\u4e0d\u53c2\u8003\u7279\u5b9a\u72b6\u6001\uff0c\u4f20\u5165 nullptr\n            false,              // 5. enable_collision_check\n            true,               // 6. is_blocking\n            5.0,                // 7. timeout\n            custom_param        // 8. params\n        );\n\n        std::cout &lt;&lt; \"\u8bbe\u7f6e\u72b6\u6001: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n        if (status == MotionStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u2705 \u6307\u4ee4\u53d1\u9001\u6210\u529f (\u963b\u585e\u7b49\u5f85\u6a21\u5f0f)\" &lt;&lt; std::endl;\n        }\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u8bbe\u7f6e\u4f4d\u59ff\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // --- \u573a\u666f 4\uff1a\u6267\u884c\u7ed3\u675f\u518d\u6b21\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u573a\u666f 4\uff1a\u6b63\u5728\u83b7\u53d6\u57fa\u7840\u672b\u7aef\u4f4d\u59ff...\" &lt;&lt; std::endl;\n        std::string end_ee_link = \"right_arm_end_effector_mount_link\";\n\n        auto res = planner.get_end_effector_pose(end_ee_link, reference_frame);\n\n        MotionStatus status = std::get&lt;0&gt;(res);\n        std::vector&lt;double&gt; pose = std::get&lt;1&gt;(res);\n\n        std::cout &lt;&lt; \"\u6267\u884c\u72b6\u6001: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n        if (status == MotionStatus::SUCCESS) {\n            print_pose_info(\"\u57fa\u7840\u7248\", pose);\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u573a\u666f 4 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#single_point_planning","title":"\u5355\u70b9\u8fd0\u52a8\u89c4\u5212\uff08\u5173\u8282\u7a7a\u95f4\u4e0e\u7b1b\u5361\u5c14\u7a7a\u95f4\uff09\uff08single_point_planning\uff09","text":"examples/cpp/galbot_motion/src/single_point_planning_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u5b9a\u4e49\u8f68\u8ff9\u8fd4\u56de\u7c7b\u578b\u4ee5\u7b80\u5316\u4ee3\u7801\nusing TrajResult = std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&gt;;\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff1a\u6253\u5370\u89c4\u5212\u7ed3\u679c\n */\nvoid print_plan_info(const std::string&amp; label, const TrajResult&amp; res, const std::string&amp; chain_name, GalbotMotion&amp; planner) {\n    auto status = std::get&lt;0&gt;(res);\n    auto traj_map = std::get&lt;1&gt;(res);\n\n    std::cout &lt;&lt; \"[\" &lt;&lt; label &lt;&lt; \"] \u72b6\u6001: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n    if (status == MotionStatus::SUCCESS) {\n        if (traj_map.count(chain_name) &amp;&amp; !traj_map[chain_name].empty()) {\n            std::cout &lt;&lt; \"\u2705 \u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u70b9\u6570 = \" &lt;&lt; traj_map[chain_name].size() &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \"\u26a0\ufe0f \u72b6\u6001\u4e3a SUCCESS \u4f46\u8f68\u8ff9\u4e3a\u7a7a\uff08\u53ef\u80fd\u5df2\u5728\u76ee\u6807\u70b9\uff09\" &lt;&lt; std::endl;\n        }\n    } else {\n        std::cout &lt;&lt; \"\u274c \u89c4\u5212\u5931\u8d25\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"---------------------------------------\" &lt;&lt; std::endl;\n}\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_joints = {\n        {\"leg\",       {0.4992, 1.4991, 1.0005, 0.0000, -0.0004}},\n        {\"head\",      {0.0000, 0.0}},\n        {\"left_arm\",  {1.9999, -1.6000, -0.5999, -1.6999, 0.0000, -0.7999, 0.0000}},\n        {\"right_arm\", {-2.0000, 1.6001, 0.6001, 1.7000, 0.0000, 0.8000, 0.0000}}\n    };\n\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_pose_baselink = {\n        {\"leg\",       {0.0596, -0.0000, 1.0327, 0.5000, 0.5003, 0.4997, 0.5000}},\n        {\"head\",      {0.0599, 0.0002, 1.4098, -0.7072, 0.0037, 0.0037, 0.7069}},\n        {\"left_arm\",  {0.1267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991}},\n        {\"right_arm\", {0.1267, -0.2345, 0.7358, -0.0225, 0.0126, -0.0343, 0.9991}}\n    };\n\n    auto params = std::make_shared&lt;Parameter&gt;();\n    std::string target_chain = \"left_arm\";\n\n    // NOTE:\n    // - GalbotMotion does NOT provide real-time obstacle perception / automatic environment updates today.\n    // - When enable_collision_check=true, collision checking uses self-collision + objects you load manually via\n    //   add_obstacle/attach_target_object (including point clouds if you load them explicitly).\n\n    // Scenario 1: joint-space planning, target type = joint state\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; Scenario 1: joint-space planning (joint target)...\" &lt;&lt; std::endl;\n\n        // \u6784\u9020\u76ee\u6807\u5173\u8282\u72b6\u6001\n        auto target_joint = std::make_shared&lt;JointStates&gt;();\n        target_joint-&gt;chain_name = target_chain;\n        target_joint-&gt;joint_positions = chain_joints[target_chain];\n\n        auto res = planner.motion_plan(\n            target_joint,   // 1. target\n            nullptr,        // 2. start (nullptr\u8868\u793a\u4ece\u5f53\u524d\u5f00\u59cb)\n            nullptr,        // 3. reference_robot_states\n            false,          // 4. enable_collision_check\n            params          // 5. params\n        );\n\n        print_plan_info(\"Joint-space planning (joint target)\", res, target_chain, planner);\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    // Scenario 2: joint-space planning, target type = end-effector pose (Cartesian)\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; Scenario 2: joint-space planning (pose target)...\" &lt;&lt; std::endl;\n\n        // \u6784\u9020\u76ee\u6807\u4f4d\u59ff\u72b6\u6001\n        auto target_pose = std::make_shared&lt;PoseState&gt;();\n        target_pose-&gt;chain_name = target_chain;\n        target_pose-&gt;frame_id = \"EndEffector\";\n        target_pose-&gt;reference_frame = \"base_link\";\n        target_pose-&gt;pose = chain_pose_baselink[target_chain];\n\n        auto res = planner.motion_plan(\n            target_pose,    // 1. target\n            nullptr,        // 2. start\n            nullptr,        // 3. reference_robot_states\n            false,          // 4. enable_collision_check\n            params          // 5. params\n        );\n\n        print_plan_info(\"Joint-space planning (pose target)\", res, target_chain, planner);\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    // Scenario 3: joint-space planning with an explicit start state\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; Scenario 3: joint-space planning (explicit start)...\" &lt;&lt; std::endl;\n\n        auto target_joint = std::make_shared&lt;JointStates&gt;();\n        target_joint-&gt;chain_name = target_chain;\n        target_joint-&gt;joint_positions = chain_joints[target_chain];\n\n        auto start_joint = std::make_shared&lt;JointStates&gt;();\n        start_joint-&gt;chain_name = target_chain;\n        start_joint-&gt;joint_positions = std::vector&lt;double&gt;(7, 0.0); // 7\u4e2a0\u4f5c\u4e3a\u8d77\u70b9\n\n        auto res = planner.motion_plan(\n            target_joint, \n            start_joint,    // 2. \u6307\u5b9a\u8d77\u59cb\u70b9\n            nullptr, \n            false, \n            params\n        );\n\n        print_plan_info(\"Joint-space planning (explicit start)\", res, target_chain, planner);\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#multi_point_planning","title":"\u591a\u70b9\u8f68\u8ff9\u89c4\u5212(multi_point_planning)","text":"examples/cpp/galbot_motion/src/multi_point_planning_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;algorithm&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n// \u8f68\u8ff9\u8fd4\u56de\u7c7b\u578b\u5b9a\u4e49\nusing TrajResult = std::tuple&lt;MotionStatus, std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;double&gt;&gt;&gt;&gt;;\n\n/**\n * \u8f85\u52a9\u51fd\u6570\uff1a\u6253\u5370\u89c4\u5212\u7ed3\u679c\n */\nvoid print_multi_plan_result(const std::string&amp; label, const TrajResult&amp; res, const std::string&amp; chain_name, GalbotMotion&amp; planner) {\n    auto status = std::get&lt;0&gt;(res);\n    auto traj_map = std::get&lt;1&gt;(res);\n\n    std::cout &lt;&lt; \"[\" &lt;&lt; label &lt;&lt; \"] \u72b6\u6001\u53cd\u9988: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n    if (status == MotionStatus::SUCCESS) {\n        if (traj_map.count(chain_name) &amp;&amp; !traj_map[chain_name].empty()) {\n            std::cout &lt;&lt; \"\u2705 \u591a\u70b9\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u603b\u70b9\u6570 = \" &lt;&lt; traj_map[chain_name].size() &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; \"\u26a0\ufe0f \u72b6\u6001 SUCCESS \u4f46\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u7531\u4e8e\u76ee\u6807\u4e0e\u5f53\u524d\u4f4d\u59ff\u91cd\u5408\u3002\" &lt;&lt; std::endl;\n        }\n    } else {\n        std::cout &lt;&lt; \"\u274c \u591a\u70b9\u89c4\u5212\u5931\u8d25\u3002\" &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; \"---------------------------------------------------\" &lt;&lt; std::endl;\n}\n\nint main() {\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_joints = {\n        {\"leg\",       {0.4992, 1.4991, 1.0005, 0.0000, -0.0004}},\n        {\"head\",      {0.0000, 0.0}},\n        {\"left_arm\",  {1.9999, -1.6000, -0.5999, -1.6999, 0.0000, -0.7999, 0.0000}},\n        {\"right_arm\", {-2.0000, 1.6001, 0.6001, 1.7000, 0.0000, 0.8000, 0.0000}}\n    };\n\n    std::vector&lt;double&gt; whole_body_joint;\n    std::vector&lt;std::string&gt; keys = {\"leg\", \"head\", \"left_arm\", \"right_arm\"};\n    for (const auto&amp; key : keys) {\n        whole_body_joint.insert(whole_body_joint.end(), chain_joints[key].begin(), chain_joints[key].end());\n    }\n\n    auto params = std::make_shared&lt;Parameter&gt;();\n    std::string target_chain = \"left_arm\";\n\n    // --- \u573a\u666f 1\uff1a\u7b1b\u5361\u5c14\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212 (PoseState \u76ee\u6807) ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 1\uff1a\u7b1b\u5361\u5c14\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212...\" &lt;&lt; std::endl;\n\n        auto target_pose_state = std::make_shared&lt;PoseState&gt;();\n        target_pose_state-&gt;chain_name = target_chain;\n\n        // \u6784\u9020\u8def\u70b9\uff083\u4e2a\u4e2d\u95f4\u4f4d\u59ff\uff09\n        std::vector&lt;std::vector&lt;double&gt;&gt; waypoint_poses = {\n            {0.1267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.2267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.3267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.4267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991}\n        };\n\n        auto res = planner.motion_plan_multi_waypoints(\n            target_pose_state,\n            waypoint_poses,\n            nullptr,  // start\n            nullptr,  // reference_robot_states\n            false,    // enable_collision_check\n            params    // params\n        );\n\n        print_multi_plan_result(\"\u7b1b\u5361\u5c14\u591a\u70b9\u5355\u94fe\u89c4\u5212\", res, target_chain, planner);\n        std::this_thread::sleep_for(std::chrono::milliseconds(800));\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; \"\u573a\u666f 1 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    // --- \u573a\u666f 2\uff1a\u5173\u8282\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212 (JointStates \u76ee\u6807) ---\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; \u6267\u884c\u573a\u666f 2\uff1a\u5173\u8282\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212...\" &lt;&lt; std::endl;\n\n        auto target_joint = std::make_shared&lt;JointStates&gt;();\n        target_joint-&gt;chain_name = target_chain;\n\n        // \u6784\u9020\u8def\u70b9\uff083\u4e2a\u4e2d\u95f4\u4f4d\u59ff\uff09\n        std::vector&lt;std::vector&lt;double&gt;&gt; waypoints = {\n            {0.1267, 0.2342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.2267, 0.4342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.3267, 0.6342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991},\n            {0.4267, 0.8342, 0.7356, 0.0220, 0.0127, 0.0343, 0.9991}\n        };\n\n        auto res = planner.motion_plan_multi_waypoints(\n            target_joint,\n            waypoints,\n            nullptr,\n            nullptr,\n            false,\n            params\n        );\n\n        print_multi_plan_result(\"\u5173\u8282\u7a7a\u95f4\u591a\u70b9\", res, target_chain, planner);\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; \"\u573a\u666f 2 \u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    // 4. \u6e05\u7406\u8d44\u6e90\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#collision_detection","title":"\u78b0\u649e\u68c0\u6d4b(collision_detection)","text":"examples/cpp/galbot_motion/src/collision_detection_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;tuple&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n#include &lt;algorithm&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n#include \"galbot_navigation.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n    auto&amp; navigation = GalbotNavigation::get_instance();\n\n    // NOTE:\n    // - GalbotNavigation (galbotNav) may use real-time obstacle perception/avoidance during navigation (deployment dependent).\n    // - GalbotMotion does NOT provide real-time obstacle perception today; Motion collision uses self-collision +\n    //   manually loaded obstacles (add_obstacle/attach_target_object).\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!navigation.init()) {\n        std::cerr &lt;&lt; \"GalbotNavigation init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::unordered_map&lt;std::string, std::vector&lt;double&gt;&gt; chain_joints = {\n        {\"leg\",       {0.4992, 1.4991, 1.0005, 0.0000, -0.0004}},\n        {\"head\",      {0.0000, 0.0}},\n        {\"left_arm\",  {1.9999, -1.6000, -0.5999, -1.6999, 0.0000, -0.7999, 0.0000}},\n        {\"right_arm\", {-2.0000, 1.6001, 0.6001, 1.7000, 0.0000, 0.8000, 0.0000}}\n    };\n\n    std::vector&lt;double&gt; whole_body_joint;\n    std::vector&lt;std::string&gt; keys = {\"leg\", \"head\", \"left_arm\", \"right_arm\"};\n    for (const auto&amp; key : keys) {\n        whole_body_joint.insert(whole_body_joint.end(), chain_joints[key].begin(), chain_joints[key].end());\n    }\n\n    std::vector&lt;double&gt; base_state = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0};\n    std::vector&lt;double&gt; bad_left_arm_joint = {1.99995, -1.60004, 0.599905, -1.69994, 0, -0.799924, 0};\n    auto custom_param = std::make_shared&lt;Parameter&gt;();\n\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; Running collision check...\" &lt;&lt; std::endl;\n\n        // \u6784\u9020\u5f85\u68c0\u6d4b\u7684RobotStates\u72b6\u6001\u5217\u8868\n        std::vector&lt;std::shared_ptr&lt;RobotStates&gt;&gt; check_states;\n\n        // \u72b6\u6001 0: \u5168\u8eab\u4f53\u72b6\u6001 (RobotStates)\n        auto state0 = std::make_shared&lt;RobotStates&gt;();\n        state0-&gt;whole_body_joint = whole_body_joint;\n        state0-&gt;base_state = base_state;\n        check_states.push_back(state0);\n\n        // \u72b6\u6001 1: \u7279\u5b9a\u94fe\u72b6\u6001 (JointStates \u662f RobotStates \u7684\u5b50\u7c7b)\n        auto state1 = std::make_shared&lt;JointStates&gt;();\n        state1-&gt;chain_name = \"left_arm\";\n        state1-&gt;joint_positions = bad_left_arm_joint;\n        check_states.push_back(state1);\n\n        // \u8c03\u7528\u78b0\u649e\u68c0\u6d4b\u63a5\u53e3\n        auto res = planner.check_collision(check_states, true, custom_param);\n\n        MotionStatus status = std::get&lt;0&gt;(res);\n        std::vector&lt;bool&gt; collision_results = std::get&lt;1&gt;(res);\n\n        std::cout &lt;&lt; \"Status: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n        if (status == MotionStatus::SUCCESS) {\n            std::cout &lt;&lt; \"OK: collision check finished (false=no collision, true=collision):\" &lt;&lt; std::endl;\n            for (size_t i = 0; i &lt; collision_results.size(); ++i) {\n                std::cout &lt;&lt; \"  - \u72b6\u6001 [\" &lt;&lt; i &lt;&lt; \"]: \" \n                          &lt;&lt; (collision_results[i] ? \"COLLISION\" : \"NO COLLISION\") \n                          &lt;&lt; std::endl;\n            }\n        } else {\n            std::cerr &lt;&lt; \"ERROR: collision check returned failure.\" &lt;&lt; std::endl;\n        }\n\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"ERROR: collision check exception: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#attach_tool","title":"\u9644\u52a0\u5de5\u5177(attach_tool)","text":"examples/cpp/galbot_motion/src/attach_tool_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    // --- \u6267\u884c\u9644\u52a0\u5de5\u5177\u64cd\u4f5c ---\n    try {\n        std::string chain_name = \"left_arm\";\n        std::string tool_name = \"suction_cup\";\n\n        MotionStatus status = planner.attach_tool(chain_name, tool_name);\n\n        std::cout &lt;&lt; \"\u6267\u884c\u72b6\u6001\u53cd\u9988: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n        if (status == MotionStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u2705 \u6210\u529f\u52a0\u8f7d\u5de5\u5177: \" &lt;&lt; tool_name &lt;&lt; std::endl;\n        } else {\n            std::cerr &lt;&lt; \"\u274c \u52a0\u8f7d\u5de5\u5177\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u5de5\u5177\u540d\u79f0\u662f\u5426\u5728\u914d\u7f6e\u6587\u4ef6\u4e2d\u5b9a\u4e49\u3002\" &lt;&lt; std::endl;\n        }\n\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u8fd0\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#detach_tool","title":"\u5378\u8f7d\u5de5\u5177(detach_tool)","text":"examples/cpp/galbot_motion/src/detach_tool_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;stdexcept&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    // \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    // --- \u6267\u884c\u5378\u8f7d\u5de5\u5177\u64cd\u4f5c ---\n    try {\n        std::string chain_name = \"left_arm\";\n        MotionStatus status = planner.detach_tool(chain_name);\n\n        std::cout &lt;&lt; \"\u6267\u884c\u72b6\u6001\u53cd\u9988: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n        if (status == MotionStatus::SUCCESS) {\n            std::cout &lt;&lt; \"\u2705 \u6210\u529f\u5378\u8f7d\u5de5\u5177\u3002\" &lt;&lt; std::endl;\n        } else {\n            std::cerr &lt;&lt; \"\u274c \u5378\u8f7d\u5de5\u5177\u5931\u8d25\u3002\" &lt;&lt; std::endl;\n        }\n\n    } catch (const std::exception&amp; e) {\n        std::cerr &lt;&lt; \"\u274c \u8fd0\u884c\u8fc7\u7a0b\u4e2d\u53d1\u751f\u5f02\u5e38: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#env_collider_operation","title":"\u52a0\u8f7d/\u79fb\u9664\u73af\u5883\u78b0\u649e\u4f53(env_collider_operation)","text":"examples/cpp/galbot_motion/src/env_collider_operation_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;memory&gt;\n#include &lt;stdexcept&gt;\n\n#include \"galbot_motion.hpp\"\n#include \"galbot_robot.hpp\"\n\nusing namespace galbot::sdk::g1;\n\n/*\n    NOTE:\n    - GalbotMotion does NOT provide real-time obstacle perception / automatic environment updates today.\n    - To make Motion collision checking consider environmental obstacles, you must load them manually\n        (e.g., box/mesh/point_cloud via add_obstacle/attach_target_object).\n    - Real-time perception / navigation-style obstacle updates in Motion is a planned future feature.\n*/\n\nint main() {\n    auto&amp; planner = GalbotMotion::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    if (!planner.init()) {\n        std::cerr &lt;&lt; \"GalbotMotion init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"GalbotRobot init FAILED\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n\n    // Scenario 1: add a Box collision object into Motion environment.\n    try {\n        std::cout &lt;&lt; \"&gt;&gt; Scenario 1: add obstacle...\" &lt;&lt; std::endl;\n\n        std::string obstacle_id = \"box_test_1\";\n        std::string obj_type = \"box\";\n        std::vector&lt;double&gt; obj_pose = {1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};\n        std::array&lt;double, 3&gt; obj_scale = {1.0, 1.0, 1.0};\n        std::string target_frame = \"world\";\n\n        MotionStatus status = planner.add_obstacle(\n            obstacle_id,      // 1. ID\n            obj_type,         // 2. \u7c7b\u578b\n            obj_pose,         // 3. \u4f4d\u59ff\n            obj_scale,        // 4. \u7f29\u653e (array)\n            \"\",               // 5. key\n            target_frame,     // 6. target_frame\n            \"\",               // 7. ee_frame\n            {},               // 8. ref_joints\n            {},               // 9. ref_base\n            {},               // 10. ignore_links\n            0.0,              // 11. safe_margin\n            0.0               // 12. resolution\n        );\n\n        std::cout &lt;&lt; \"Status: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n        planner.clear_obstacle();\n\n        if (status == MotionStatus::SUCCESS) {\n            std::cout &lt;&lt; \"OK: obstacle added\" &lt;&lt; std::endl;\n        }\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    // Scenario 2: add a duplicate ID (expected to fail).\n    try {\n        std::cout &lt;&lt; \"\\n&gt;&gt; Scenario 2: test duplicate ID...\" &lt;&lt; std::endl;\n\n        std::string obstacle_id = \"box_test_2\";\n        std::string obj_type = \"box\";\n        std::vector&lt;double&gt; obj_pose = {1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0};\n        std::array&lt;double, 3&gt; obj_scale = {1.0, 1.0, 1.0};\n        std::string target_frame = \"world\";\n\n        // \u7b2c\u4e00\u6b21\u6dfb\u52a0\n        planner.add_obstacle(obstacle_id, obj_type, obj_pose, obj_scale, \"\", target_frame, \"\", {}, {}, {}, 0.0, 0.0);\n\n        // \u7b2c\u4e8c\u6b21\u6dfb\u52a0\u76f8\u540c ID\n        MotionStatus status = planner.add_obstacle(obstacle_id, obj_type, obj_pose, obj_scale, \"\", target_frame, \"\", {}, {}, {}, 0.0, 0.0);\n\n        std::cout &lt;&lt; \"Status: \" &lt;&lt; planner.status_to_string(status) &lt;&lt; std::endl;\n\n        planner.clear_obstacle();\n\n        if (status == MotionStatus::FAULT) {\n            std::cout &lt;&lt; \"OK: duplicate ID rejected (expected)\" &lt;&lt; std::endl;\n        }\n    } catch (const std::exception&amp; e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#galbotnavigation","title":"\u7c7b\uff1aGalbotNavigation","text":""},{"location":"examples_cpp/#get_instance_init","title":"\u83b7\u53d6\u5b9e\u4f8b / \u521d\u59cb\u5316(get_instance_init)","text":"examples/cpp/galbot_navigation/src/get_instance_init_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;thread&gt;\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!navigation.init()) {\n        std::cerr &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; \"\u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#relocation","title":"\u91cd\u5b9a\u4f4d / \u662f\u5426\u5df2\u5b9a\u4f4d / \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff(relocation)","text":"examples/cpp/galbot_navigation/src/relocation_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;thread&gt;\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"Base instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (navigation.init()) {\n        std::cout &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    Pose init_pose(std::vector&lt;double&gt;{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n\n    // \u68c0\u67e5\u91cd\u5b9a\u4f4d\u662f\u5426\u6210\u529f\n    int count_relocalize = 0;\n    while (!navigation.is_localized() &amp;&amp; count_relocalize &lt; 20) {\n        navigation.relocalize(init_pose);\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n        std::cout &lt;&lt; \"is relocalizing\" &lt;&lt; std::endl;\n        count_relocalize++;\n    }\n\n    if (navigation.is_localized()) {\n        std::cout &lt;&lt; \"relocalization success.\" &lt;&lt; std::endl;\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        Pose current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                  &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                  &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                  &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                  &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n        robot.request_shutdown();\n        robot.wait_for_shutdown();\n    } else {\n        std::cout &lt;&lt; \"relocalization failed, cannot proceed with navigation.\" &lt;&lt; std::endl;\n    }\n\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#blocked_navigation","title":"\u68c0\u67e5\u8def\u5f84\u53ef\u8fbe\u6027\u5e76\u963b\u585e\u5bfc\u822a\u5230\u76ee\u6807(blocked_navigation)","text":"examples/cpp/galbot_navigation/src/blocked_navigation_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;thread&gt;\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"Base instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (navigation.init()) {\n        std::cout &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    Pose init_pose(std::vector&lt;double&gt;{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n    Pose goal_pose(std::vector&lt;double&gt;{0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n\n    // \u68c0\u67e5\u91cd\u5b9a\u4f4d\u662f\u5426\u6210\u529f\n    int count_relocalize = 0;\n    while (!navigation.is_localized() &amp;&amp; count_relocalize &lt; 20) {\n        navigation.relocalize(init_pose);\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n        std::cout &lt;&lt; \"is relocalizing\" &lt;&lt; std::endl;\n        count_relocalize++;\n    }\n\n    if (navigation.is_localized()) {\n        std::cout &lt;&lt; \"relocalization success.\" &lt;&lt; std::endl;\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        Pose current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n        // \u662f\u5426\u5f00\u542f\u969c\u788d\u7269\u68c0\u67e5\uff08\u73af\u5883\u7a7a\u65f7\u53ef\u8bbe\u7f6e\u4e3atrue\uff09\n        bool enable_collision_check = false;\n        // \u662f\u5426\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n        bool is_blocking = true;\n        // \u6700\u5927\u7b49\u5f85\u5230\u4f4d\u65f6\u95f4\n        float timeout_s = 20;\n\n        // \u5faa\u73af\u53cd\u590d3\u6b21\u5bfc\u822a\n        int count = 0;\n        while (count++ &lt; 3) {\n            std::cout &lt;&lt; \"\u7b2c \" &lt;&lt; count &lt;&lt; \" \u6b21\u5bfc\u822a\" &lt;&lt; std::endl;\n            // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u5bfc\u822a\u5230\u76ee\u6807\n            if (navigation.check_path_reachability(goal_pose, init_pose)) {\n                std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                NavigationStatus status = navigation.navigate_to_goal(\n                    goal_pose, enable_collision_check, is_blocking, timeout_s);\n                if (status == NavigationStatus::SUCCESS) {\n                    std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                } else {\n                    std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u72b6\u6001\u7801: \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; std::endl;\n                }\n            } else {\n                std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            }\n            // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u56de\u5230\u8d77\u70b9\n            if (navigation.check_path_reachability(init_pose, goal_pose)) {\n                std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n                NavigationStatus status = navigation.navigate_to_goal(\n                    init_pose, enable_collision_check, is_blocking, timeout_s);\n                if (status == NavigationStatus::SUCCESS) {\n                    std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u8d77\u70b9\" &lt;&lt; std::endl;\n                } else {\n                    std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u72b6\u6001\u7801: \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; std::endl;\n                }\n            } else {\n                std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n            }\n        }\n\n        // \u505c\u6b62\u5bfc\u822a\n        navigation.stop_navigation();\n\n        // \u518d\u6b21\u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n    } else {\n        std::cout &lt;&lt; \"relocalization failed.\" &lt;&lt; std::endl;\n    }\n\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#non_blocking_navigation","title":"\u975e\u963b\u585e\u5bfc\u822a + \u8f6e\u8be2\u5224\u65ad\u5230\u8fbe(non_blocking_navigation)","text":"examples/cpp/galbot_navigation/src/non_blocking_navigation_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;thread&gt;\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (robot.init()) {\n        std::cout &lt;&lt; \"Base instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (navigation.init()) {\n        std::cout &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    Pose init_pose(std::vector&lt;double&gt;{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n    Pose goal_pose(std::vector&lt;double&gt;{0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n\n    // \u68c0\u67e5\u91cd\u5b9a\u4f4d\u662f\u5426\u6210\u529f\n    int count_relocalize = 0;\n    while (!navigation.is_localized() &amp;&amp; count_relocalize &lt; 20) {\n        navigation.relocalize(init_pose);\n        std::this_thread::sleep_for(std::chrono::milliseconds(5000));\n        std::cout &lt;&lt; \"is relocalizing\" &lt;&lt; std::endl;\n        count_relocalize++;\n    }\n    if (navigation.is_localized()) {\n        std::cout &lt;&lt; \"relocalization success.\" &lt;&lt; std::endl;\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        Pose current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n        std::this_thread::sleep_for(std::chrono::milliseconds(2000));\n\n        // \u662f\u5426\u5f00\u542f\u969c\u788d\u7269\u68c0\u67e5\uff08\u73af\u5883\u7a7a\u65f7\u53ef\u8bbe\u7f6e\u4e3atrue\uff09\n        bool enable_collision_check = false;\n        // \u662f\u5426\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n        bool is_blocking = false;\n\n        // \u5faa\u73af\u53cd\u590d2\u6b21\u5bfc\u822a,\u975e\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n        int count = 0;\n        while (count++ &lt; 2) {\n            std::cout &lt;&lt; \"\u7b2c \" &lt;&lt; count &lt;&lt; \" \u6b21\u5bfc\u822a\" &lt;&lt; std::endl;\n            // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u5bfc\u822a\u5230\u76ee\u6807\n            if (navigation.check_path_reachability(goal_pose, init_pose)) {\n                std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                NavigationStatus status = navigation.navigate_to_goal(\n                    goal_pose, enable_collision_check, is_blocking);\n                // \u7b49\u5f85\u5230\u8fbe\n                int count_arrival = 0;\n                while (!navigation.check_goal_arrival()) {\n                    std::cout &lt;&lt; \"navigate has not arrived\" &lt;&lt; std::endl;\n                    std::this_thread::sleep_for(std::chrono::milliseconds(500));\n                    if (++count_arrival &gt; 10) {\n                        break;\n                    }\n                }\n                if (navigation.check_goal_arrival()) {\n                    std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                } else {\n                    std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u672a\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                }\n            } else {\n                std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            }\n            // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u56de\u5230\u8d77\u70b9\n            if (navigation.check_path_reachability(init_pose, goal_pose)) {\n                std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n                NavigationStatus status = navigation.navigate_to_goal(\n                    init_pose, enable_collision_check, is_blocking);\n                // \u7b49\u5f85\u5230\u8fbe\n                int count_arrival = 0;\n                while (!navigation.check_goal_arrival()) {\n                    std::cout &lt;&lt; \"navigate has not arrived\" &lt;&lt; std::endl;\n                    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n                    if (++count_arrival &gt; 10) {\n                        break;\n                    }\n                }\n                if (navigation.check_goal_arrival()) {\n                    std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                } else {\n                    std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u672a\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n                }\n            } else {\n                std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n            }\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n        }\n\n        // \u505c\u6b62\u5bfc\u822a\n        navigation.stop_navigation();\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"relocalization failed, cannot proceed with navigation.\" &lt;&lt; std::endl;\n    }\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#linear_movement","title":"\u76f4\u7ebf\u79fb\u52a8\u5230\u76ee\u6807 / \u505c\u6b62\u5bfc\u822a(linear_movement)","text":"examples/cpp/galbot_navigation/src/linear_movement_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n\nusing namespace galbot::sdk::g1;\n\n// \u8f85\u52a9\u51fd\u6570: \u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u5b57\u7b26\u4e32 [HH:MM:SS.ms]\nstd::string get_timestamp() {\n    auto now = std::chrono::system_clock::now();\n    auto ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(now.time_since_epoch()) % 1000;\n    std::time_t t = std::chrono::system_clock::to_time_t(now);\n    std::tm tm = *std::localtime(&amp;t);\n\n    std::stringstream ss;\n    ss &lt;&lt; \"[\" &lt;&lt; std::put_time(&amp;tm, \"%H:%M:%S\") &lt;&lt; \".\" \n       &lt;&lt; std::setfill('0') &lt;&lt; std::setw(3) &lt;&lt; ms.count() &lt;&lt; \"] \";\n    return ss.str();\n}\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5f00\u59cb\u8c03\u7528 robot.init()...\" &lt;&lt; std::endl;\n    if (robot.init()) {\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"Base instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; get_timestamp() &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5f00\u59cb\u8c03\u7528 navigation.init()...\" &lt;&lt; std::endl;\n    if (navigation.init()) {\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u6210\u529f\uff01\" &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; get_timestamp() &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    Pose init_pose(std::vector&lt;double&gt;{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n    Pose goal_pose(std::vector&lt;double&gt;{0.3, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n\n    // \u68c0\u67e5\u91cd\u5b9a\u4f4d\u662f\u5426\u6210\u529f\n    std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u8fdb\u5165\u91cd\u5b9a\u4f4d\u68c0\u67e5\u5faa\u73af...\" &lt;&lt; std::endl;\n    int count_relocalize = 0;\n    while (!navigation.is_localized() &amp;&amp; count_relocalize &lt; 20) {\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u8c03\u7528 navigation.relocalize()...\" &lt;&lt; std::endl;\n        navigation.relocalize(init_pose);\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"is relocalizing\" &lt;&lt; std::endl;\n        count_relocalize++;\n    }\n\n    if (navigation.is_localized()) {\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"relocalization success.\" &lt;&lt; std::endl;\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u8c03\u7528 navigation.get_current_pose()...\" &lt;&lt; std::endl;\n        Pose current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n        // \u662f\u5426\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n        bool is_blocking = true;\n        // \u6700\u5927\u7b49\u5f85\u5230\u4f4d\u65f6\u95f4\n        float timeout_s = 20;\n\n        // --- \u76f4\u7ebf\u79fb\u52a8\u5e76\u8ba1\u65f6 ---\n        std::cout &lt;&lt; \"--------------------------------------------------\" &lt;&lt; std::endl;\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u51c6\u5907\u6267\u884c move_straight_to (\u76f4\u7ebf\u79fb\u52a8)...\" &lt;&lt; std::endl;\n\n        // \u8bb0\u5f55\u5f00\u59cb\u65f6\u95f4\n        auto start_move = std::chrono::system_clock::now();\n\n        // \u6267\u884c\u79fb\u52a8\n        NavigationStatus status = navigation.move_straight_to(goal_pose, is_blocking, timeout_s);\n\n        // \u8bb0\u5f55\u7ed3\u675f\u65f6\u95f4\u5e76\u8ba1\u7b97\u8017\u65f6\n        auto end_move = std::chrono::system_clock::now();\n        auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end_move - start_move).count();\n\n        if (status == NavigationStatus::SUCCESS) {\n            std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d (\u8017\u65f6: \" &lt;&lt; duration &lt;&lt; \"ms)\" &lt;&lt; std::endl;\n        } else {\n            std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u72b6\u6001\u7801: \" &lt;&lt; static_cast&lt;int&gt;(status) \n                    &lt;&lt; \" (\u8017\u65f6: \" &lt;&lt; duration &lt;&lt; \"ms)\" &lt;&lt; std::endl;\n        }\n        std::cout &lt;&lt; \"--------------------------------------------------\" &lt;&lt; std::endl;\n\n        // \u505c\u6b62\u5bfc\u822a\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u8c03\u7528 navigation.stop_navigation()...\" &lt;&lt; std::endl;\n        navigation.stop_navigation();\n\n        // \u518d\u6b21\u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u8c03\u7528 navigation.get_current_pose()...\" &lt;&lt; std::endl;\n        current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u91cd\u5b9a\u4f4d\u5931\u8d25\uff0c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\u5bfc\u822a\u3002\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u6267\u884c shutdown...\" &lt;&lt; std::endl;\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n    std::cout &lt;&lt; get_timestamp() &lt;&lt; \"\u7a0b\u5e8f\u7ed3\u675f\u3002\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#complete_running_example","title":"\u5b8c\u6574\u8fd0\u884c\u793a\u4f8b\uff08\u7b80\u5355\u6d41\u7a0b\uff09(complete_running_example)","text":"examples/cpp/galbot_navigation/src/complete_running_example.cpp<pre><code>#include \"galbot_navigation.hpp\"\n#include \"galbot_robot.hpp\"\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;thread&gt;\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    auto&amp; navigation = GalbotNavigation::get_instance();\n    auto&amp; robot = GalbotRobot::get_instance();\n\n    // \u521d\u59cb\u5316\u7cfb\u7edf\n    if (!robot.init()) {\n        std::cerr &lt;&lt; \"Base instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n    if (!navigation.init()) {\n        std::cerr &lt;&lt; \"Navigation instance \u521d\u59cb\u5316\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    Pose init_pose(std::vector&lt;double&gt;{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n    Pose goal_pose(std::vector&lt;double&gt;{0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n\n    // \u68c0\u67e5\u91cd\u5b9a\u4f4d\u662f\u5426\u6210\u529f\n    int count_relocalize = 0;\n    while (!navigation.is_localized() &amp;&amp; count_relocalize &lt; 20) {\n        navigation.relocalize(init_pose);\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n        std::cout &lt;&lt; \"is relocalizing\" &lt;&lt; std::endl;\n        count_relocalize++;\n    }\n\n    if (navigation.is_localized()) {\n        std::cout &lt;&lt; \"\u91cd\u5b9a\u4f4d\u6210\u529f\uff01\" &lt;&lt; std::endl;\n\n        // \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff\n        Pose current_pose = navigation.get_current_pose();\n        std::cout &lt;&lt; \"\u5f53\u524d\u4f4d\u59ff: \u4f4d\u7f6e(\" &lt;&lt; current_pose.position.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.position.y &lt;&lt; \", \" &lt;&lt; current_pose.position.z\n                &lt;&lt; \"), \u59ff\u6001(\" &lt;&lt; current_pose.orientation.x &lt;&lt; \", \"\n                &lt;&lt; current_pose.orientation.y &lt;&lt; \", \" &lt;&lt; current_pose.orientation.z\n                &lt;&lt; \", \" &lt;&lt; current_pose.orientation.w &lt;&lt; \")\" &lt;&lt; std::endl;\n\n        // \u662f\u5426\u5f00\u542f\u969c\u788d\u7269\u68c0\u67e5\uff08\u73af\u5883\u7a7a\u65f7\u53ef\u8bbe\u7f6e\u4e3atrue\uff09\n        bool enable_collision_check = false;\n        // \u662f\u5426\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n        bool is_blocking = true;\n        // \u6700\u5927\u7b49\u5f85\u5230\u4f4d\u65f6\u95f4\n        float timeout_s = 20;\n\n        // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u5bfc\u822a\u5230\u76ee\u6807\n        if (navigation.check_path_reachability(goal_pose, init_pose)) {\n            std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            // \u5bfc\u822a\u5230\u6307\u5b9a\u70b9\u4f4d\uff0c\u5173\u95ed\u969c\u788d\u7269\u68c0\u67e5\uff0c\u963b\u585e\u7b49\u5f85\u5230\u8fbe\uff0c\u6700\u5927\u7b49\u5f85\u65f6\u95f4\u4e3a20\u79d2\n            NavigationStatus status = navigation.navigate_to_goal(\n                goal_pose, enable_collision_check, is_blocking, timeout_s);\n            if (status == NavigationStatus::SUCCESS) {\n                std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u72b6\u6001\u7801: \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; std::endl;\n            }\n        } else {\n            std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n        }\n\n        // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u56de\u5230\u8d77\u70b9\n        if (navigation.check_path_reachability(init_pose, goal_pose)) {\n            std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n            // \u5bfc\u822a\u5230\u6307\u5b9a\u70b9\u4f4d\uff0c\u5173\u95ed\u969c\u788d\u7269\u68c0\u67e5\uff0c\u975e\u963b\u585e\u7b49\u5f85\u5230\u8fbe\n            is_blocking = false;\n            NavigationStatus status = navigation.navigate_to_goal(\n                init_pose, enable_collision_check, is_blocking);\n            // \u7b49\u5f85\u5230\u8fbe\n            int count_arrival = 0;\n            while (!navigation.check_goal_arrival()) {\n                std::cout &lt;&lt; \"navigate has not arrived\" &lt;&lt; std::endl;\n                std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n                if (++count_arrival &gt; 10) {\n                    break;\n                }\n            }\n            if (navigation.check_goal_arrival()) {\n                std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u672a\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            }\n        } else {\n            std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u8d77\u70b9\" &lt;&lt; std::endl;\n        }\n\n        // \u68c0\u67e5\u8def\u5f84\u662f\u5426\u53ef\u8fbe\u5e76\u5bfc\u822a\u5230\u76ee\u6807\n        if (navigation.check_path_reachability(goal_pose, init_pose)) {\n            std::cout &lt;&lt; \"\u8def\u5f84\u53ef\u8fbe\uff0c\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            // \u76f4\u7ebf\u79fb\u52a8\u5230\u76ee\u6807\u70b9\u4f4d,\u963b\u585e\u7b49\u5f85\u5230\u8fbe\uff0c\u6700\u5927\u7b49\u5f85\u65f6\u95f4\u4e3a10\u79d2\n            is_blocking = true;\n            NavigationStatus status = navigation.move_straight_to(\n                goal_pose, is_blocking, timeout_s);\n\n            if (status == NavigationStatus::SUCCESS) {\n                std::cout &lt;&lt; \"\u5df2\u5230\u8fbe\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n            } else {\n                std::cout &lt;&lt; \"\u5bfc\u822a\u5931\u8d25\uff0c\u72b6\u6001\u7801: \" &lt;&lt; static_cast&lt;int&gt;(status) &lt;&lt; std::endl;\n            }\n        } else {\n            std::cout &lt;&lt; \"\u8def\u5f84\u4e0d\u53ef\u8fbe\uff0c\u65e0\u6cd5\u5bfc\u822a\u81f3\u76ee\u6807\u70b9\u4f4d\" &lt;&lt; std::endl;\n        }\n\n        // \u505c\u6b62\u5bfc\u822a\n        navigation.stop_navigation();\n\n    } else {\n        std::cout &lt;&lt; \"\u91cd\u5b9a\u4f4d\u5931\u8d25\uff01\" &lt;&lt; std::endl;\n    }\n\n\n    robot.request_shutdown();\n    robot.wait_for_shutdown();\n    robot.destroy();\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#parameter","title":"\u7c7b\uff1aParameter","text":""},{"location":"examples_cpp/#parameterparameter_use","title":"\u521b\u5efa\u5e76\u4f7f\u7528 <code>Parameter</code>(parameter_use)","text":"examples/cpp/galbot_motion/src/parameter_use_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n#include \"galbot_motion.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n    // \u901a\u8fc7\u6784\u9020\u51fd\u6570\u521b\u5efa Parameter \u5e76\u8bbe\u7f6e\u9009\u9879\n    auto p = std::make_shared&lt;Parameter&gt;();\n\n    p-&gt;setBlocking(true);            // \u8bbe\u7f6e\u662f\u5426\u963b\u585e\u6267\u884c\n    p-&gt;setCheckCollision(false);     // \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\n    p-&gt;setTimeout(5.0);              // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff08\u79d2\uff09\n    p-&gt;setActuate(\"with_chain_only\");// \u8bbe\u7f6e\u9a71\u52a8\u6a21\u5f0f\n    p-&gt;setToolPose(false);           // \u662f\u5426\u8003\u8651\u5de5\u5177\u4f4d\u59ff\n    p-&gt;setReferenceFrame(\"base_link\");\n\n    std::cout &lt;&lt; \"--- Parameter p ---\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"blocking: \" &lt;&lt; (p-&gt;getBlocking() ? \"True\" : \"False\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"collision check: \" &lt;&lt; (p-&gt;getCheckCollision() ? \"True\" : \"False\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"timeout: \" &lt;&lt; p-&gt;getTimeout() &lt;&lt; \"s\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_cpp/#_3","title":"\u8f85\u52a9\u51fd\u6570","text":""},{"location":"examples_cpp/#status_to_string-jointstates-posestate-auxi_fun_use","title":"status_to_string / JointStates / PoseState (auxi_fun_use)","text":"examples/cpp/galbot_motion/src/function_use_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n#include \"galbot_motion.hpp\"\n\nusing namespace galbot::sdk::g1;\n\nint main() {\n\n    auto&amp; planner = GalbotMotion::get_instance();\n\n    MotionStatus status = MotionStatus::SUCCESS;\n    std::string status_str = planner.status_to_string(status);\n\n    std::cout &lt;&lt; \"MotionStatus \u5b57\u7b26\u4e32: \" &lt;&lt; status_str &lt;&lt; std::endl;\n\n    auto js = std::make_shared&lt;JointStates&gt;();\n    auto ps = std::make_shared&lt;PoseState&gt;();\n\n    js-&gt;chain_name = \"left_arm\";\n    js-&gt;joint_positions = std::vector&lt;double&gt;(7, 0.0); \n\n    ps-&gt;chain_name = \"left_arm\";\n    ps-&gt;pose = Pose(std::vector&lt;double&gt;{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0});\n    ps-&gt;reference_frame = \"base_link\"; \n    ps-&gt;frame_id = \"EndEffector\";\n\n    std::cout &lt;&lt; \"--- JointStates ---\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(*js).name() &lt;&lt; std::endl; // \u6253\u5370\u7c7b\u540d\n    std::cout &lt;&lt; \"Chain Name: \" &lt;&lt; js-&gt;chain_name &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Joints size: \" &lt;&lt; js-&gt;joint_positions.size() &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n--- PoseState ---\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Type: \" &lt;&lt; typeid(*ps).name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Chain Name: \" &lt;&lt; ps-&gt;chain_name &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pose Z: \" &lt;&lt; ps-&gt;pose.position.z &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"examples_python/","title":"Python \u793a\u4f8b","text":"<p>\u672c\u6587\u4ef6\u4e3a API \u4e2d\u516c\u5f00\u7684\u51fd\u6570\u4e0e\u7c7b\u578b\u63d0\u4f9b\u7b80\u77ed\u793a\u4f8b\uff0c\u6f14\u793a\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u63a5\u53e3\u3002</p>"},{"location":"examples_python/#g1-22","title":"\u673a\u5668\u4eba\u5173\u8282\u540d\u79f0\uff08G1 2.2\uff09","text":""},{"location":"examples_python/#_1","title":"\u5173\u8282\u7ec4\u5217\u8868","text":"<p>\u673a\u5668\u4eba\u5173\u8282\u7ec4\u540d\u79f0\u5305\u62ec\uff1a<code>[\"head\", \"left_arm\", \"right_arm\", \"leg\", \"left_gripper\", \"right_gripper\", \"left_suction_cup\", \"right_suction_cup\"]</code></p>"},{"location":"examples_python/#_2","title":"\u5404\u5173\u8282\u7ec4\u8be6\u7ec6\u4fe1\u606f","text":"\u5173\u8282\u7ec4\u540d\u79f0 \u5173\u8282\u7ec4\u82f1\u6587\u540d \u5173\u8282\u6570\u91cf \u5173\u8282\u540d\u79f0\u5217\u8868 \u5934\u90e8 head 2 <code>head_joint1</code>, <code>head_joint2</code> \u817f\u90e8 leg 5 <code>leg_joint1</code>, <code>leg_joint2</code>, <code>leg_joint3</code>, <code>leg_joint4</code>, <code>leg_joint5</code> \u5de6\u81c2 left_arm 7 <code>left_arm_joint1</code>, <code>left_arm_joint2</code>, <code>left_arm_joint3</code>, <code>left_arm_joint4</code>, <code>left_arm_joint5</code>, <code>left_arm_joint6</code>, <code>left_arm_joint7</code> \u53f3\u81c2 right_arm 7 <code>right_arm_joint1</code>, <code>right_arm_joint2</code>, <code>right_arm_joint3</code>, <code>right_arm_joint4</code>, <code>right_arm_joint5</code>, <code>right_arm_joint6</code>, <code>right_arm_joint7</code> \u5de6\u5939\u722a left_gripper 1 <code>left_gripper_joint1</code> \u53f3\u5939\u722a right_gripper 1 <code>right_gripper_joint1</code> \u5de6\u5438\u76d8 left_suction_cup 1 <code>left_suction_cup_joint1</code> \u53f3\u5438\u76d8 right_suction_cup 1 <code>right_suction_cup_joint1</code>"},{"location":"examples_python/#galbotrobot","title":"\u7c7b\uff1aGalbotRobot","text":"<p>tips\uff1a\u7a0b\u5e8f\u542f\u52a8\u540e\u7acb\u523b\u5c31get\uff0c\u6570\u636e\u53ef\u80fd\u4e0d\u4f1a\u7acb\u523b\u5c31\u7eea\uff0c\u53ef\u9002\u5f53sleep\u51e0\u79d2</p>"},{"location":"examples_python/#get_instance-init","title":"\u83b7\u53d6\u5b9e\u4f8b\u5e76\u521d\u59cb\u5316\uff08get_instance &amp;&amp; init\uff09","text":"examples/python/galbot_robot/get_instance.py<pre><code>from galbot_sdk.g1 import GalbotRobot\nimport time\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\nrobot = GalbotRobot.get_instance()\n\nstate = robot.init()\nif not state:\n    print(\"\u521d\u59cb\u5316\u5931\u8d25\")\nelse:\n    print(\"\u521d\u59cb\u5316\u6210\u529f\")\n\nwhile robot.is_running():\n    # \u4e1a\u52a1\u903b\u8f91\n    time.sleep(1)\n    break\n\n# \u53d1\u51fa\u9000\u51fa\u4fe1\u53f7\u9000\u51fa\u7a0b\u5e8f\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165\u9000\u51fa\u72b6\u6001\nrobot.wait_for_shutdown()\n# SDK\u76f8\u5173\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#set_joint_positions","title":"\u8bbe\u7f6e\u5173\u8282\u89d2\u5ea6\uff08set_joint_positions\uff09","text":"examples/python/galbot_robot/set_joint_positions.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot, ControlStatus\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\nprint('\u521d\u59cb\u5316\u6210\u529f')\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\n# \u8bbe\u7f6e\u5934\u90e8\u4e24\u4e2a\u5173\u8282\u89d2\u5ea6\u4e3a0.2\uff0c0.2\uff0c\u963b\u585e\u7b49\u5f85\u52a8\u4f5c\u6267\u884c\u5230\u4f4d\uff0c\u6700\u5927\u8d85\u65f6\u65f6\u95f4\u4e3a10s\njoint_pos = [0.2, 0.2]\n# \u8bbe\u7f6e\u5934\u90e8\u5173\u8282\u7ec4\uff0c\u5982\u4e3a\u7a7a\u5c06\u9ed8\u8ba4\u586b\u5199\u5168\u8eab\u5173\u8282\njoint_groups = [\"head\"]\n# \u662f\u5426\u963b\u585e\u7b49\u5f85\u5173\u8282\u8fd0\u884c\u5230\u4f4d\nis_blocking = True\n# \u9650\u5236\u5173\u8282\u6700\u5927\u8fd0\u884c\u901f\u5ea6\u4e3a0.1rad/s\nmax_speed = 0.1\n# \u963b\u585e\u7b49\u5f85\u6700\u5927\u65f6\u95f4\ntimeout_s = 10\n\nstatus = robot.set_joint_positions(\n    joint_pos, joint_groups, [], is_blocking, max_speed, timeout_s\n)\n\nif status != ControlStatus.SUCCESS:\n    print(\"\u5173\u8282\u89d2\u8bbe\u7f6e\u5931\u8d25\")\nelse:\n    print('\u5173\u8282\u89d2\u8bbe\u7f6e\u6210\u529f')\n\ntime.sleep(1)\n\n# \u4f7f\u7528\u7279\u5b9a\u5173\u8282\u540d\u79f0\u8fdb\u884c\u63a7\u5236\uff0c\u8be5\u53c2\u6570\u5c06\u8986\u76d6joint_groups\u5173\u8282\u7ec4\u53c2\u6570\njoint_names = [\"head_joint1\", \"head_joint2\"]\njoint_pos = [0.0, 0.0]\n\nstatus = robot.set_joint_positions(\n    joint_pos, [], joint_names, is_blocking, max_speed, timeout_s\n)\n\nif status != ControlStatus.SUCCESS:\n    print(\"\u5173\u8282\u89d2\u8bbe\u7f6e\u5931\u8d25\")\nelse:\n    print('\u5173\u8282\u89d2\u8bbe\u7f6e\u6210\u529f')\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#set_gripper_command","title":"\u8bbe\u7f6e\u5939\u722a\u6307\u4ee4\uff08set_gripper_command\uff09","text":"examples/python/galbot_robot/set_gripper_command.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot, JointGroup, ControlStatus\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\nprint('\u521d\u59cb\u5316\u6210\u529f')\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\n# \u8bbe\u7f6e\u5de6\u5939\u722a\u5bbd\u5ea6\u4e3a0.1m\uff0c\u8fd0\u884c\u901f\u5ea6\u4e3a0.05m\uff0c\u529b\u77e9\u4e3a10N\uff0c\u5c06\u963b\u585e\u7b49\u5f85\u5939\u722a\u8fd0\u884c\u5230\u4f4d\nstatus = robot.set_gripper_command(\n    JointGroup.LEFT_GRIPPER, 0.1, 0.05, 10, True\n)\n\nif status != ControlStatus.SUCCESS:\n    print(\"\u8bbe\u7f6e\u5939\u722a\u5931\u8d25\")\nelse:\n    print('\u8bbe\u7f6e\u5939\u722a\u6210\u529f')\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#set_suction_cup_command","title":"\u8bbe\u7f6e\u5438\u76d8\u6307\u4ee4\uff08set_suction_cup_command\uff09","text":"examples/python/galbot_robot/set_suction_cup_command.py<pre><code>from galbot_sdk.g1 import GalbotRobot, JointGroup, ControlStatus\nimport time\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\ntime.sleep(1)\nprint('\u521d\u59cb\u5316\u6210\u529f')\n\n# \u8bbe\u7f6e\u5438\u76d8\u6240\u5c5e\u7684\u5173\u8282\u7ec4\uff08\u53f3\u5438\u76d8\uff09\njoint_group = JointGroup.RIGHT_SUCTION_CUP\n\n# \u662f\u5426\u6fc0\u6d3b\u5438\u76d8\nactivate = True  # True\uff1a\u6fc0\u6d3b\u5438\u76d8\uff0cFalse\uff1a\u5173\u95ed\u5438\u76d8\n\n# \u53d1\u9001\u5438\u76d8\u63a7\u5236\u6307\u4ee4\nstatus = robot.set_suction_cup_command(\n    joint_group,\n    activate\n)\n\n# \u68c0\u67e5\u6267\u884c\u7ed3\u679c\nif status != ControlStatus.SUCCESS:\n    print(\"\u8bbe\u7f6e\u5438\u76d8\u5931\u8d25\")\nelse:\n    print(\"\u8bbe\u7f6e\u5438\u76d8\u6210\u529f\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#stop_trajectory_execution","title":"\u505c\u6b62\u8f68\u8ff9\u6267\u884c\uff08stop_trajectory_execution\uff09","text":"examples/python/galbot_robot/stop_trajectory_execution.py<pre><code>from galbot_sdk.g1 import GalbotRobot, ControlStatus\nimport time\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\ntime.sleep(2)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u53d1\u9001\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u6307\u4ee4\nwhile True:\n    status = robot.stop_trajectory_execution()\n\n    # \u68c0\u67e5\u6267\u884c\u7ed3\u679c\n    if status == ControlStatus.SUCCESS:\n        print('\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u6210\u529f')\n        break\n\n    print(\"\u505c\u6b62\u8f68\u8ff9\u6267\u884c\u5931\u8d25\uff0c\u91cd\u8bd5\u4e2d...\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#execute_joint_trajectory","title":"\u8bbe\u7f6e\u8f68\u8ff9\uff08execute_joint_trajectory\uff09","text":"examples/python/galbot_robot/execute_joint_trajectory.py<pre><code>from galbot_sdk.g1 import GalbotRobot, JointGroup, ControlStatus, Trajectory, TrajectoryPoint,JointCommand\nimport time\nimport numpy as np\nfrom typing import List\n\n# \u751f\u6210\u8f68\u8ff9\u5355\u70b9\uff0c\u5305\u542b\u4f4d\u7f6e\u4e0e\u65f6\u95f4\u4fe1\u606f\ndef generate_target_point(q: List[float], target_time: float = 10):\n    \"\"\"Generate target for joints\"\"\"\n    joint_position = TrajectoryPoint()\n    joint_position.time_from_start_second = target_time\n    joint_command_vec = []\n    for joint in q:\n        joint_cmd = JointCommand()\n        joint_cmd.position = joint\n        joint_command_vec.append(joint_cmd)\n    joint_position.joint_command_vec = joint_command_vec\n    return joint_position\n\ndef generate_target_trajectory(trajectory, joint_groups=[], joint_names=[], dt=0.008):\n    \"\"\"Generate trajectory for joints\"\"\"\n    if trajectory is None or np.ndim(trajectory) != 2 or len(trajectory) == 0:\n        return None\n\n    # \u521b\u5efa Trajectory\n    traj = Trajectory()\n    traj.joint_groups = joint_groups\n    traj.joint_names = joint_names\n\n    time = 0.0\n    points = []\n    for state in trajectory:\n        time += dt\n        # \u521b\u5efa\u5355\u4e2a\u8f68\u8ff9\u70b9\n        traj_point = generate_target_point(state, time)\n        points.append(traj_point)\n\n    traj.points = points\n    return traj\n\n# \u8f68\u8ff9\u6267\u884c\u51fd\u6570\ndef traj_exec():\n    # \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\uff0c\u4ec5\u9700\u521d\u59cb\u5316\u4e00\u6b21\n    robot = GalbotRobot.get_instance()\n    robot.init()\n    time.sleep(1)\n    print(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n    head_traj = np.linspace(\n        [0.0, 0.0],\n        [0.5, 0.0],\n        num=200,\n    )\n    # \u662f\u5426\u963b\u585e\u7b49\u5f85\u8f68\u8ff9\u6267\u884c\u5b8c\u6bd5\n    is_block = True\n    # \u6307\u5b9a\u6267\u884c\u54ea\u4e2a\u5173\u8282\u7ec4\u8f68\u8ff9\n    joint_groups = [\"head\"]\n    # \u6267\u884c\u6307\u5b9a\u5173\u8282\u8f68\u8ff9\uff0c\u5982\u586b\u5145\u5c06\u8986\u76d6joint_groups\u5173\u8282\u7ec4\u53c2\u6570\n    joint_names = []\n    status = robot.execute_joint_trajectory(generate_target_trajectory(head_traj.tolist(), joint_groups, joint_names), is_block)\n\n    # \u68c0\u67e5\u6267\u884c\u7ed3\u679c\n    if status != ControlStatus.SUCCESS:\n        print(\"\u8f68\u8ff9\u6267\u884c\u5931\u8d25\")\n    else:\n        print(\"\u8f68\u8ff9\u6267\u884c\u6210\u529f\")\n\n    # \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\n    robot.request_shutdown()\n    # \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\n    robot.wait_for_shutdown()\n    # \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.destroy()\n    print('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n\ntraj_exec()\n</code></pre>"},{"location":"examples_python/#set_base_velocity","title":"\u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\uff08set_base_velocity\uff09","text":"examples/python/galbot_robot/set_base_velocity.py<pre><code>from galbot_sdk.g1 import GalbotRobot, ControlStatus\nimport time\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\nrobot = GalbotRobot.get_instance()\nrobot.init()\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\nlinear_velocity = [0.1, 0.0, 0.0]  # \u524d\u8fdb 0.5 m/s\nangular_velocity = [0.0, 0.0, 0.1]  # \u65cb\u8f6c 0.1 rad/s\n# \u6ce8\u610f\uff1a\u5c06\u4ee5\u6307\u5b9a\u901f\u5ea6\u8fd0\u884c\uff0c\u76f4\u5230\u4e0b\u53d1\u505c\u6b62\u8fd0\u52a8\u6307\u4ee4\nstatus = robot.set_base_velocity(linear_velocity, angular_velocity)\n\nif status == ControlStatus.SUCCESS:\n    print(\"\u5e95\u76d8\u901f\u5ea6\u8bbe\u7f6e\u6210\u529f\u3002\")\nelse:\n    print(\"\u8bbe\u7f6e\u5e95\u76d8\u901f\u5ea6\u5931\u8d25\u3002\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_joint_states","title":"\u83b7\u53d6\u5173\u8282\u72b6\u6001\uff08get_joint_states\uff09","text":"examples/python/galbot_robot/get_joint_states.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot\n\ndef print_joint_states(joint_states):\n    \"\"\"\n    joint_state_vec: List of JointState, \u6bcf\u4e2a\u5bf9\u8c61\u5177\u6709 position, velocity, acceleration, effort, current\n    \"\"\"\n    for js in joint_states:\n        print(f\" : position = {js.position} , velocity = {js.velocity} \"\n            f\", acceleration = {js.acceleration} , effort = {js.effort} , current = {js.current}\")\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n# \u4f7f\u7528\u5173\u8282\u7ec4\u540d\u79f0\u83b7\u53d6\u5173\u8282\u72b6\u6001\uff0c\u4e3a\u7a7a\u9ed8\u8ba4\u8fd4\u56de\u6240\u6709\u5173\u8282\njoint_group_names = [\"left_arm\"]\nret = robot.get_joint_states(joint_group_names, [])\nprint_joint_states(ret)\n\n# \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u72b6\u6001\uff0c\u5982\u679c\u586b\u5145\u5c06\u8986\u76d6\u5173\u8282\u7ec4\u8f93\u5165\njoint_names = [\"left_arm_joint1\", \"left_arm_joint2\"]\nstate_ret = robot.get_joint_states([], joint_names)\nprint_joint_states(state_ret)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_joint_positions","title":"\u83b7\u53d6\u5173\u8282\u4f4d\u7f6e\uff08get_joint_positions\uff09","text":"examples/python/galbot_robot/get_joint_positions.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot\n\ndef print_joint_positions(joint_positions):\n    print(f\"pos count is {len(joint_positions)}\")\n    for pos in joint_positions:\n        print(pos)\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u4f7f\u7528\u5173\u8282\u7ec4\u540d\u79f0\u83b7\u53d6\u5173\u8282\u4f4d\u7f6e\uff0c\u4e3a\u7a7a\u9ed8\u8ba4\u8fd4\u56de\u6240\u6709\u5173\u8282\njoint_group_names = [\"left_arm\"]\nret = robot.get_joint_positions(joint_group_names, [])\nprint(\"\u5de6\u81c2\u5173\u8282\u4f4d\u7f6e\uff1a\")\nprint_joint_positions(ret)\n# \u83b7\u53d6\u6307\u5b9a\u5173\u8282\u4f4d\u7f6e\uff0c\u5982\u679c\u586b\u5145\u5c06\u8986\u76d6\u5173\u8282\u7ec4\u8f93\u5165\njoint_names = [\"left_arm_joint1\", \"left_arm_joint2\"]\nstate_ret = robot.get_joint_positions([], joint_names)\nprint(\"\u5de6\u81c21\u30012\u5173\u8282\u4f4d\u7f6e:\")\nprint_joint_positions(state_ret)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_joint_names","title":"\u83b7\u53d6\u5173\u8282\u540d\u79f0\uff08get_joint_names\uff09","text":"examples/python/galbot_robot/get_joint_names.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u4f7f\u7528\u5173\u8282\u7ec4\u540d\u79f0\u83b7\u53d6\u5173\u8282\u4f4d\u7f6e\uff0c\u4e3a\u7a7a\u9ed8\u8ba4\u8fd4\u56de\u6240\u6709\u5173\u8282\njoint_group_names = [\"left_arm\"]\n# \u4ec5\u83b7\u53d6\u53ef\u6d3b\u52a8\u5173\u8282\nonly_active_joint = True\nret = robot.get_joint_names(only_active_joint, joint_group_names)\nprint(\"Left joint names:\")\nfor i, name in enumerate(ret):\n    print(f\"{i + 1}: {name}\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_gripper_state","title":"\u83b7\u53d6\u5939\u722a\u72b6\u6001\uff08get_gripper_state\uff09","text":"examples/python/galbot_robot/get_gripper_state.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot, JointGroup\n\ndef print_gripper_state(joint_group, gripper_state):\n    \"\"\"\n    joint_group: JointGroup \u679a\u4e3e\n    gripper_state: \u5bf9\u8c61\uff0c\u5305\u542b timestamp_ns, width, velocity, effort, is_moving\n    \"\"\"\n    print(f\"Timestamp (ns): {gripper_state.timestamp_ns}\")\n    print(\n        f\"width {gripper_state.width} \"\n        f\"velocity {gripper_state.velocity} \"\n        f\"effort {gripper_state.effort} \"\n        f\"is moving {gripper_state.is_moving}\"\n    )\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u8bbe\u7f6e\u5939\u722a\u5173\u8282\u7ec4\uff08\u5de6\u5939\u722a\uff09\njoint_group = JointGroup.LEFT_GRIPPER\n\n# \u83b7\u53d6\u5939\u722a\u72b6\u6001\ngripper_state = robot.get_gripper_state(joint_group)\n\nif gripper_state is None:\n    print(\"get gripper state error\")\nelse:\n    print(\"\u5de6\u5939\u722a\u72b6\u6001\u5982\u4e0b\uff1a\")\n    print_gripper_state(joint_group, gripper_state)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_suction_cup_state","title":"\u83b7\u53d6\u5438\u76d8\u72b6\u6001\uff08get_suction_cup_state\uff09","text":"examples/python/galbot_robot/get_suction_cup_state.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot, JointGroup\n\ndef print_suction_cup_state(suction_cup_state):\n    \"\"\"\n    suction_cup_state: \u5bf9\u8c61\uff0c\u5305\u542b timestamp_ns, pressure, activation, action_state\n    \"\"\"\n    group_name = joint_group.name\n    print(f\"Timestamp (ns): {suction_cup_state.timestamp_ns}\")\n    print(\n        f\"pressure {suction_cup_state.pressure} \"\n        f\"activation {suction_cup_state.activation} \"\n        f\"action state {int(suction_cup_state.action_state)}\"\n    )\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u8bbe\u7f6e\u5438\u76d8\u6240\u5c5e\u7684\u5173\u8282\u7ec4\uff08\u53f3\u5438\u76d8\uff09\njoint_group = JointGroup.RIGHT_SUCTION_CUP\n\n# \u83b7\u53d6\u5438\u76d8\u72b6\u6001\nsuction_cup_state = robot.get_suction_cup_state(joint_group)\n\nif suction_cup_state is None:\n    print(\"get suction cup error\")\nelse:\n    print(\"\u53f3\u5438\u76d8\u72b6\u6001\uff1a\")\n    print_suction_cup_state(suction_cup_state)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_transform","title":"\u83b7\u53d6\u5750\u6807\u53d8\u6362\uff08get_transform\uff09","text":"examples/python/galbot_robot/get_transform.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot\n\ndef print_pose(pose_vec):\n    \"\"\"\n    pose_vec: list of floats\n    \"\"\"\n    print(\"pose_vec = [\" + \", \".join(str(p) for p in pose_vec) + \"]\")\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\n# \u8bbe\u7f6e\u76ee\u6807\u5e27\u548c\u6e90\u5e27\ntarget_frame = \"base_link\"\nsource_frame = \"left_arm_link1\"\ntimestamp_ns = 0    # 0\u4e3a\u83b7\u53d6\u6700\u65b0tf\u53d8\u6362\u503c\n\n# \u83b7\u53d6\u5750\u6807\u53d8\u6362\nret_val = robot.get_transform(target_frame, source_frame)\n\nif not ret_val[0]:\n    print(\"get_transform error\")\nelse:\n    print(\"tf_timestamp_ns:\", ret_val[1])\n    print_pose(ret_val[0])\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#imuget_imu_data","title":"\u83b7\u53d6imu\u6570\u636e\uff08get_imu_data\uff09","text":"examples/python/galbot_robot/get_imu_data.py<pre><code>import time\nfrom galbot_sdk.g1 import GalbotRobot, SensorType\nfrom typing import Dict\n\ndef print_imu_data(imu_data: dict):\n    \"\"\"\n    imu_data: dict\uff0c\u5305\u542b:\n        - 'timestamp_ns'\n        - 'accel'   : {'x', 'y', 'z'}\n        - 'gyro'    : {'x', 'y', 'z'}\n        - 'magnet'  : {'x', 'y', 'z'}\n    \"\"\"\n    if not imu_data:\n        print(\"IMU data is empty\")\n        return\n\n    print(f\"Timestamp (ns): {imu_data.get('timestamp_ns')}\")\n\n    accel = imu_data.get(\"accel\", {})\n    gyro = imu_data.get(\"gyro\", {})\n    magnet = imu_data.get(\"magnet\", {})\n\n    print(\n        f\"Accelerometer: x={accel.get('x')}, \"\n        f\"y={accel.get('y')}, \"\n        f\"z={accel.get('z')}\"\n    )\n    print(\n        f\"Gyroscope:     x={gyro.get('x')}, \"\n        f\"y={gyro.get('y')}, \"\n        f\"z={gyro.get('z')}\"\n    )\n    print(\n        f\"Magnetometer:  x={magnet.get('x')}, \"\n        f\"y={magnet.get('y')}, \"\n        f\"z={magnet.get('z')}\"\n    )\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nrobot.init({SensorType.TORSO_IMU})\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n\nimu_data = robot.get_imu_data(SensorType.TORSO_IMU)\nif not imu_data:\n    print(\"No imu data!\")\nelse:\n    print(\"imu\u6570\u636e\uff1a\")\n    print_imu_data(imu_data)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#get_rgb_data-get_depth_data","title":"\u83b7\u53d6\u76f8\u673a\u56fe\u50cf\u6570\u636e\uff08get_rgb_data &amp;&amp; get_depth_data\uff09","text":"examples/python/galbot_robot/get_camera_data.py<pre><code>try:\n    from galbot_sdk.g1  import GalbotRobot, SensorType\nexcept ImportError:\n    print(\"import galbot_sdk failed, please install it first or check if it is in the PYTHONPATH\")\n    exit(1)\n\nimport os\n\ntry:\n    import cv2\nexcept ImportError:\n    os.system(\"pip install opencv-python\")\n    import cv2\n\ntry:\n    import numpy as np\nexcept ImportError:\n    os.system(\"pip install numpy\")\n    import numpy as np\n\nimport time\nfrom typing import Dict\n\ndef decode_compressed_image(compressed_image):\n    \"\"\"\n    decode CompressedImage image\n\n    Parameters:\n        compressed_image (dict): image dict, keys:[header, format, data, \"depth_scale\"]\n\n    Returns:\n        numpy.ndarray: decoded image\n    \"\"\"\n    image_data = compressed_image[\"data\"]\n    if compressed_image[\"format\"] == \"rgb8\":\n        return decode_rgb_image(image_data)\n    elif compressed_image[\"format\"] == \"16UC1\":\n        return decode_depth_image(compressed_image)\n    else:\n        raise ValueError(f\"Unsupport data format: {compressed_image['format']}\")\n\ndef decode_rgb_image(image_data):\n    \"\"\"decode rgb image\"\"\"\n    nparr = np.frombuffer(image_data, np.uint8)\n    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n    if img is None:\n        raise ValueError(\"Fail to Decode RGB Image\")\n    return img\n\ndef decode_depth_image(image_data):\n    \"\"\"decode depth image\"\"\"\n    depth_img = np.frombuffer(image_data[\"data\"], dtype=np.uint16).copy()\n\n    # \u68c0\u67e5\u662f\u5426\u5b58\u5728 height \u548c width\n    if \"height\" not in image_data or \"width\" not in image_data:\n        raise ValueError(\"Missing 'height' or 'width' in depth image metadata.\")\n    if image_data[\"height\"] == 0 or image_data[\"width\"] == 0:\n        raise ValueError(f\"Invalid 'height' ({image_data['height']}) or 'width' ({image_data['width']}) in depth image metadata.\")\n\n    # \u89e3\u6790\u6df1\u5ea6\u56fe\u50cf\n    depth_img = depth_img.reshape((image_data[\"height\"], image_data[\"width\"]))\n    depth_img = depth_img.astype(np.float32) / image_data[\"depth_scale\"]\n\n    return depth_img\n\ndef main():\n    robot = GalbotRobot.get_instance()\n\n    # \u83b7\u53d6\u5de6\u81c2\u7684RGB\u56fe\u50cf\u548c\u6df1\u5ea6\u56fe\u50cf\uff0c\u53f3\u81c2\u7684\u6df1\u5ea6\u56fe\u50cf\uff0c\u5e95\u5ea7\u7684\u6fc0\u5149\u96f7\u8fbe\u6570\u636e\uff0c\u8eaf\u5e72\u7684IMU\u6570\u636e\n    enable_sensor_set = {SensorType.LEFT_ARM_CAMERA, # \u5de6\u81c2\u6df1\u5ea6\u76f8\u673a\n                        SensorType.LEFT_ARM_DEPTH_CAMERA,} # \u5de6\u81c2RGB\u76f8\u673a\n    robot.init(enable_sensor_set)\n    print(\"\u521d\u59cb\u5316\u6210\u529f\")\n    # \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\n    time.sleep(5)\n    # \u83b7\u53d6\u5de6\u81c2\u7684RGB\u56fe\u50cf\n    rgb_image_data = robot.get_rgb_data(SensorType.LEFT_ARM_CAMERA)\n    if not rgb_image_data:\n        print(\"No rgb image data!\")\n    else:\n        print(\"get rgb image suceess\")\n        print(rgb_image_data['header'])\n        img = decode_compressed_image(rgb_image_data)\n\n        # \u4fdd\u5b58RGB\u56fe\u50cf\n        cv2.imwrite(\"rgb_image_data.jpg\", img)\n        # \u53ef\u89c6\u5316RGB\u56fe\u50cf\n        cv2.namedWindow(\"rgb image\", cv2.WINDOW_NORMAL)\n        cv2.imshow(\"rgb image\", img)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n\n    # \u83b7\u53d6\u5de6\u81c2\u7684\u6df1\u5ea6\u56fe\u50cf\n    depth_data = robot.get_depth_data(SensorType.LEFT_ARM_DEPTH_CAMERA)\n    if not depth_data or \"data\" not in depth_data:\n        print(\"Depth camera not ready\")\n    else:\n        print(\"get depth data suceess\")\n        print(depth_data['header'])\n        depth_img_raw = decode_compressed_image(depth_data)\n        depth_img = cv2.normalize(depth_img_raw, None, 0, 255, cv2.NORM_MINMAX) # \u5f52\u4e00\u5316\uff0c\u5c06\u6df1\u5ea6\u503c\u6620\u5c04\u52300-1\u8303\u56f4\n        depth_img = depth_img.astype(np.uint8)\n\n        # \u4fdd\u5b58\u6df1\u5ea6\u56fe\n        cv2.imwrite(\"depth_data.jpg\", depth_img)\n        # \u53ef\u89c6\u5316\u6df1\u5ea6\u56fe\n        cv2.namedWindow(\"depth image\", cv2.WINDOW_NORMAL)\n        cv2.imshow(\"depth image\", depth_img)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n\n    # \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\n    robot.request_shutdown()\n    # \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\n    robot.wait_for_shutdown()\n    # \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\n    robot.destroy()\n    print('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n\nif __name__==\"__main__\":\n    main()\n</code></pre>"},{"location":"examples_python/#get_lidar_data","title":"\u83b7\u53d6\u96f7\u8fbe\u6570\u636e\uff08get_lidar_data\uff09","text":"examples/python/galbot_robot/get_lidar_data.py<pre><code>from galbot_sdk.g1 import GalbotRobot, SensorType\nfrom typing import Dict\nimport time\nimport numpy as np\n\ndef convert_pointcloud(cloud):\n    \"\"\"\n    Convert cloud dict to NumPy array dictionary\n\n    Args:\n        pointcloud_msg: PointCloud2 protobuf message object\n\n    Returns:\n        Dictionary: {field_name: NumPy array}\n        - Single-element fields: shape (N,)\n        - Multi-element fields: shape (N, count) or (N,)\n        - N = width * height (total number of points)\n    \"\"\"\n\n    if not cloud:\n        return {}\n\n    num_points = cloud[\"height\"] * cloud[\"width\"]\n    if num_points == 0:\n        return {}\n\n    DTYPE_MAP = {\n        1: np.int8,\n        2: np.uint8,\n        3: np.int16,\n        4: np.uint16,\n        5: np.int32,\n        6: np.uint32,\n        7: np.float32,\n        8: np.float64\n    }\n    dtype_list = []\n    for field in cloud[\"fields\"]:\n        # Get base data type\n        np_dtype_class = DTYPE_MAP.get(field[\"datatype\"])\n        if np_dtype_class is None:\n            raise ValueError(f\"Unsupported data type: {field['datatype']}\")\n\n        dtype_inst = np.dtype(np_dtype_class)\n\n        # Handle byte order (endianness)\n        if dtype_inst.itemsize &gt; 1:\n            byteorder = '&gt;' if cloud[\"is_bigendian\"] else '&lt;'\n            dtype_inst = dtype_inst.newbyteorder(byteorder)\n\n        # Add to dtype list\n        if field[\"count\"] == 1:\n            dtype_list.append((field[\"name\"], dtype_inst))\n        else:\n            # Multi-element fields (e.g., rgb)\n            dtype_list.append((field[\"name\"], dtype_inst, field[\"count\"]))\n\n    # Create structured dtype\n    dtype = np.dtype(dtype_list)\n\n    # Data integrity check\n    expected_size = num_points * cloud[\"point_step\"]\n    if len(cloud[\"data\"]) &lt; expected_size:\n        raise ValueError(\n            f\"Insufficient data length: expected {expected_size} bytes, \"\n            f\"actual {len(cloud['data'])} bytes\"\n        )\n\n    # Create NumPy structured array from binary data\n    # count parameter ensures only expected number of points are read\n    arr = np.frombuffer(cloud[\"data\"], dtype=dtype, count=num_points)\n\n    # Convert to regular dictionary (copy data to avoid modifying original)\n    result = {}\n    for field in cloud[\"fields\"]:\n        field_data = arr[field[\"name\"]]\n\n        # Handle shape of multi-element fields\n        if field[\"count\"] == 1:\n            result[field[\"name\"]] = field_data.copy()\n        else:\n            # Keep original shape or flatten, choose according to needs\n            result[field[\"name\"]] = field_data.copy()\n\n    return result\n\n\ndef get_xyz_array(pointcloud_dict: Dict[str, np.ndarray], \n                remove_nan: bool = False) -&gt; np.ndarray:\n    \"\"\"\n    Extract XYZ coordinate array from converted point cloud dictionary\n\n    Args:\n        pointcloud_dict: Dictionary returned by pointcloud2_to_numpy()\n        remove_nan: Whether to remove points containing NaN (for FLOAT32/FLOAT64 types)\n\n    Returns:\n        Nx3 point coordinate array\n    \"\"\"\n    required = ['x', 'y', 'z']\n    if not all(k in pointcloud_dict for k in required):\n        raise ValueError(\"Point cloud data missing required xyz fields\")\n\n    points = np.stack([pointcloud_dict['x'], \n                    pointcloud_dict['y'], \n                    pointcloud_dict['z']], axis=1)\n\n    if remove_nan:\n        mask = ~np.isnan(points).any(axis=1)\n        points = points[mask]\n\n    return points\n\ndef save_xyz_to_pcd(xyz_array: np.ndarray, filename: str, binary: bool = False) -&gt; None:\n    \"\"\"\n    Save XYZ coordinates to PCD file format (simplest option for coordinate-only data)\n\n    Args:\n        xyz_array: Nx3 array of XYZ coordinates\n        filename: Output PCD file path\n        binary: If True, saves in binary format; otherwise ASCII\n    \"\"\"\n    if xyz_array.ndim != 2 or xyz_array.shape[1] != 3:\n        raise ValueError(f\"xyz_array must have shape (N, 3), got {xyz_array.shape}\")\n\n    num_points = xyz_array.shape[0]\n    header = [\n        \"# .PCD v0.7 - Point Cloud Data file format\",\n        \"VERSION 0.7\",\n        \"FIELDS x y z\",\n        \"SIZE 4 4 4\",\n        \"TYPE F F F\",  # F = float32\n        \"COUNT 1 1 1\",\n        f\"WIDTH {num_points}\",\n        \"HEIGHT 1\",\n        \"VIEWPOINT 0 0 0 1 0 0 0\",\n        f\"POINTS {num_points}\",\n        f\"DATA {'binary' if binary else 'ascii'}\"\n    ]\n\n    if binary:\n        with open(filename, 'wb') as f:\n            f.write(('\\n'.join(header) + '\\n').encode('ascii'))\n            f.write(xyz_array.astype(np.float32).tobytes())\n    else:\n        with open(filename, 'w') as f:\n            f.write('\\n'.join(header) + '\\n')\n            np.savetxt(f, xyz_array, fmt='%f')\n\n# \u83b7\u53d6 GalbotRobot \u7684\u5355\u4f8b\u5e76\u521d\u59cb\u5316\nrobot = GalbotRobot.get_instance()\nenable_sensor_set = {SensorType.BASE_LIDAR}\n# \u4e3a\u8282\u7701\u8d44\u6e90\u5f00\u9500\uff0c\u53ea\u6709\u521d\u59cb\u5316\u4e2d\u4f20\u5165\u7684\u76f8\u673a\u4e0e\u96f7\u8fbe\u4f20\u611f\u5668\u53ef\u83b7\u53d6\u6570\u636e\nrobot.init(enable_sensor_set)\nprint(\"\u521d\u59cb\u5316\u6210\u529f\")\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(4)\n\ncloud = robot.get_lidar_data(SensorType.BASE_LIDAR)\nif not cloud:\n    print(\"No lidar data!\")\nelse:\n    pointcloud_dict = convert_pointcloud(cloud)\n    xyz_points = get_xyz_array(pointcloud_dict)\n    save_xyz_to_pcd(xyz_points, \"output_xyz.pcd\")\n    print(pointcloud_dict)\n    print(\"get lidar data success\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#galbotmotion","title":"\u7c7b\uff1aGalbotMotion","text":""},{"location":"examples_python/#_3","title":"\u83b7\u53d6\u5b9e\u4f8b\u5e76\u521d\u59cb\u5316","text":"examples/python/galbot_motion/get_instance.py<pre><code>from galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\n\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 GalbotRobot \u7ba1\u7406\u673a\u5668\u4eba\u751f\u547d\u5468\u671f\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#robotstates","title":"\u6b63\u8fd0\u52a8\u5b66\uff08\u4f7f\u7528\u5f53\u524d\u72b6\u6001\u6216\u6307\u5b9a RobotStates\uff09","text":"examples/python/galbot_motion/fk.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\n\nchain_joints = {\n    \"leg\": [0.4992,1.4991,1.0005,0.0000,-0.0004],\n    \"head\": [0.0000,0.0],\n    \"left_arm\": [1.9999,-1.6000,-0.5999,-1.6999,0.0000,-0.7999,0.0000],\n    \"right_arm\": [-2.0000,1.6001,0.6001,1.7000,0.0000,0.8000,0.0000]\n}\nchain_pose_baselink = {\n    \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n    \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n    \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n}\nwhole_body_joint = [\n    num for key in [\"leg\", \"head\", \"left_arm\", \"right_arm\"] \n    for num in chain_joints[key]\n]\nbase_state = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\ncustom_param = gm.Parameter()\nreference_frame = \"base_link\"\ntarget_frame = \"EndEffector\"\ntarget_chain = \"left_arm\"\none_chain = [target_chain]\nchain_with_torso = [target_chain, \"torso\"]\nerror_chains = [target_chain, \"torso\", \"head\"]\n# \u573a\u666f1\uff1a\u5355\u94fe\u9006\u89e3\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u57fa\u7840\u7248\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u57fa\u7840\u7248\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f2\uff1a\u624b\u81c2\u94fe+\u8170\u90e8\u9006\u89e3\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=chain_with_torso,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f3\uff1a\u975e\u6cd5\u94fe\u7ec4\u5408\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=error_chains,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.INVALID_INPUT, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u975e\u6cd5\u94fe\u7ec4\u5408\u8f93\u5165\u68c0\u6d4b\u6210\u529f\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f4\uff1a\u4f7f\u7528\u53c2\u8003\u5173\u8282\ntry:\n    # initial_joint_positions\u53ef\u6307\u5b9a\u94fe\u5173\u8282\u4f5c\u4e3a\u9006\u89e3\u53c2\u8003\u503c\uff0c\u672a\u6307\u5b9a\u94fe\u5173\u8282\u4f7f\u7528\u5168\u8eab\u5173\u8282\u8865\u5168\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        initial_joint_positions=chain_joints,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f5\uff1a\u4f7f\u7528RobotStates\ntry:\n    ref_robot_state = gm.RobotStates()\n    ref_robot_state.chain_name = target_chain\n    ref_robot_state.whole_body_joint = whole_body_joint\n    ref_robot_state.base_state = base_state\n    target_frame = \"EndEffector\"\n    reference_frame = \"base_link\"\n    status, joint_map = motion.inverse_kinematics_by_state(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        reference_robot_states=ref_robot_state\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u57fa\u4e8eRobotStates\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\nexcept Exception as e:\n    print(f\"\u274c \u57fa\u4e8eRobotStates\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#robotstates_1","title":"\u9006\u8fd0\u52a8\u5b66\uff08\u57fa\u7840\u4e0e\u57fa\u4e8e RobotStates\uff09","text":"examples/python/galbot_motion/ik.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\n\nchain_joints = {\n    \"leg\": [0.4992,1.4991,1.0005,0.0000,-0.0004],\n    \"head\": [0.0000,0.0],\n    \"left_arm\": [1.9999,-1.6000,-0.5999,-1.6999,0.0000,-0.7999,0.0000],\n    \"right_arm\": [-2.0000,1.6001,0.6001,1.7000,0.0000,0.8000,0.0000]\n}\nchain_pose_baselink = {\n    \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n    \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n    \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n}\nwhole_body_joint = [\n    num for key in [\"leg\", \"head\", \"left_arm\", \"right_arm\"] \n    for num in chain_joints[key]\n]\nbase_state = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\ncustom_param = gm.Parameter()\nreference_frame = \"base_link\"\ntarget_frame = \"EndEffector\"\ntarget_chain = \"left_arm\"\none_chain = [target_chain]\nchain_with_torso = [target_chain, \"torso\"]\nerror_chains = [target_chain, \"torso\", \"head\"]\n# \u573a\u666f1\uff1a\u5355\u94fe\u9006\u89e3\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u57fa\u7840\u7248\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u57fa\u7840\u7248\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f2\uff1a\u624b\u81c2\u94fe+\u8170\u90e8\u9006\u89e3\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=chain_with_torso,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f3\uff1a\u975e\u6cd5\u94fe\u7ec4\u5408\ntry:\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=error_chains,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.INVALID_INPUT, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u975e\u6cd5\u94fe\u7ec4\u5408\u8f93\u5165\u68c0\u6d4b\u6210\u529f\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f4\uff1a\u4f7f\u7528\u53c2\u8003\u5173\u8282\ntry:\n    # initial_joint_positions\u53ef\u6307\u5b9a\u94fe\u5173\u8282\u4f5c\u4e3a\u9006\u89e3\u53c2\u8003\u503c\uff0c\u672a\u6307\u5b9a\u94fe\u5173\u8282\u4f7f\u7528\u5168\u8eab\u5173\u8282\u8865\u5168\n    status, joint_map = motion.inverse_kinematics(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        initial_joint_positions=chain_joints,\n        enable_collision_check=False  # \u5173\u95ed\u78b0\u649e\u68c0\u6d4b\u52a0\u901f\u6d4b\u8bd5\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u81ea\u5b9a\u4e49\u521d\u59cb\u5173\u8282\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\n# \u573a\u666f5\uff1a\u4f7f\u7528RobotStates\ntry:\n    ref_robot_state = gm.RobotStates()\n    ref_robot_state.chain_name = target_chain\n    ref_robot_state.whole_body_joint = whole_body_joint\n    ref_robot_state.base_state = base_state\n    target_frame = \"EndEffector\"\n    reference_frame = \"base_link\"\n    status, joint_map = motion.inverse_kinematics_by_state(\n        target_pose=chain_pose_baselink[target_chain],\n        chain_names=one_chain,\n        target_frame=target_frame,\n        reference_frame=reference_frame,\n        reference_robot_states=ref_robot_state\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25\"\n    print(f\"\u2705 \u57fa\u4e8eRobotStates\u9006\u8fd0\u52a8\u5b66\u6210\u529f: \u5173\u8282\u89d2={joint_map}\")\nexcept Exception as e:\n    print(f\"\u274c \u57fa\u4e8eRobotStates\u9006\u8fd0\u52a8\u5b66\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_4","title":"\u83b7\u53d6\u4e0e\u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff","text":"examples/python/galbot_motion/get_set_end_effector_pose.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(1)\n\nchain_pose_baselink = {\n    \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n    \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n    \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n}\ncustom_param = gm.Parameter()\ntarget_frame = \"EndEffector\"\nreference_frame = \"base_link\"\ntarget_chain = \"left_arm\"\n# \u573a\u666f1\uff1a\u57fa\u7840\u7248\ntry:\n    end_ee_link = \"left_arm_end_effector_mount_link\"\n    status, pose = motion.get_end_effector_pose(\n        end_effector_frame=end_ee_link,\n        reference_frame=reference_frame\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u5931\u8d25\"\n    print(f\"\u2705 \u57fa\u7840\u7248\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u6210\u529f: {pose}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u57fa\u7840\u7248\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u5f02\u5e38: {e}\")\n\n# \u573a\u666f2\uff1a\u6307\u5b9a\u94fe\u540d + \u81ea\u5b9a\u4e49frame\ntry:\n    status, pose = motion.get_end_effector_pose_on_chain(\n        chain_name=target_chain,\n        frame_id=target_frame,\n        reference_frame=reference_frame\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u5931\u8d25\"\n    print(f\"\u2705 \u6307\u5b9a\u94fe\u540d\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u6210\u529f: {pose}\")\n    time.sleep(0.8)\nexcept Exception as e:\n    print(f\"\u274c \u6307\u5b9a\u94fe\u540d\u83b7\u53d6\u672b\u7aef\u4f4d\u59ff\u5f02\u5e38: {e}\")\n\nend_effector_frame=\"left_arm\"\nreference_frame = \"base_link\"\ntry:\n    status = motion.set_end_effector_pose(\n        target_pose=chain_pose_baselink[end_effector_frame],\n        end_effector_frame=end_effector_frame,\n        reference_frame=reference_frame,\n        enable_collision_check=False,\n        is_blocking=False,\n        timeout=5.0,\n        params=custom_param\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff\u5931\u8d25\"\n    print(f\"\u2705 \u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff\u6210\u529f: status={status}\")\nexcept Exception as e:\n    print(f\"\u274c \u8bbe\u7f6e\u672b\u7aef\u4f4d\u59ff\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_5","title":"\u5355\u70b9\u8fd0\u52a8\u89c4\u5212\uff08\u5173\u8282\u7a7a\u95f4\u4e0e\u7b1b\u5361\u5c14\u7a7a\u95f4\uff09","text":"examples/python/galbot_motion/motion_plan.py<pre><code>import time\n\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# NOTE:\n# - GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.\n# - Motion collision checking uses self-collision + a collision world built from objects you load manually via\n#   add_obstacle()/attach_target_object() (including point clouds if you load them explicitly).\n\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"Result: SUCCESS\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"Result: TIMEOUT\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"Result: FAULT\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"Result: INVALID_INPUT\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"Result: INIT_FAILED\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"Result: IN_PROGRESS\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"Result: STOPPED_UNREACHED\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"Result: DATA_FETCH_FAILED\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"Result: PUBLISH_FAIL\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"Result: COMM_DISCONNECTED\")\n\nif motion.init():\n    print(\"GalbotMotion init OK\")\nelse:\n    print(\"GalbotMotion init FAILED\")\nif robot.init():\n    print(\"GalbotRobot init OK\")\nelse:\n    print(\"GalbotRobot init FAILED\")\n\n# Wait for data to be ready.\ntime.sleep(1)\n\nchain_joints = {\n    \"leg\": [0.4992,1.4991,1.0005,0.0000,-0.0004],\n    \"head\": [0.0000,0.0],\n    \"left_arm\": [1.9999,-1.6000,-0.5999,-1.6999,0.0000,-0.7999,0.0000],\n    \"right_arm\": [-2.0000,1.6001,0.6001,1.7000,0.0000,0.8000,0.0000]\n}\nchain_pose_baselink = {\n    \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n    \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n    \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n}\nwhole_body_joint = [\n    num for key in [\"leg\", \"head\", \"left_arm\", \"right_arm\"] \n    for num in chain_joints[key]\n]\nbase_state = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\ncustom_param = gm.Parameter()\n\n# Scenario 1: joint-space planning, target type = joint state\ntry:\n    # \u6784\u9020\u76ee\u6807\u5173\u8282\u72b6\u6001\n\n    target_joint = gm.JointStates()\n    target_joint.chain_name = \"left_arm\"\n    target_joint.joint_positions = chain_joints[target_joint.chain_name]\n\n    status, traj = motion.motion_plan(\n        target=target_joint,\n        # When enable_collision_check=True, collision is checked against Motion-side explicitly loaded obstacles\n        # (add_obstacle/attach_target_object) and self-collision.\n        enable_collision_check=False,\n        params=custom_param\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"Planning failed\"\n    if traj != {}:\n        print(f\"\u2705 \u5173\u8282\u7a7a\u95f4\u89c4\u5212 + \u76ee\u6807\u70b9\u7c7b\u578b\u4e3a\u5173\u8282\u5355\u94fe\u5355\u70b9\u89c4\u5212\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u70b9\u6570={len(traj[target_joint.chain_name])}\")\n        time.sleep(0.8)\n    else:\n        print(f\"\u26a0\ufe0f \u8fd4\u56de\u72b6\u6001\u4e3aSUCCESS\uff0c\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u5df2\u5230\u8fbe\uff0c\u68c0\u67e5\u76ee\u6807\u503c\u4e0e\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e00\u81f4\u6216\u5728\u8bef\u5dee\u8303\u56f4\u5185\")\n\nexcept Exception as e:\n    print(f\"ERROR: joint-space single-point planning exception: {e}\")\n\n# Scenario 2: joint-space planning, target type = end-effector pose (Cartesian)\ntry:\n    # \u6784\u9020\u76ee\u6807\u4f4d\u59ff\u72b6\u6001\n    target_pose_state = gm.PoseState()\n    target_pose_state.chain_name = \"left_arm\"\n    target_pose_state.frame_id = \"EndEffector\"\n    target_pose_state.reference_frame = \"base_link\"\n    target_pose_state.pose = gm.Pose(chain_pose_baselink[target_pose_state.chain_name])\n    # target_pose_state.pose.position.x += 0.2\n\n    status, traj = motion.motion_plan(\n        target=target_pose_state,\n        enable_collision_check=False\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"Planning failed\"\n    if traj != {}:\n        print(f\"\u2705 \u5173\u8282\u7a7a\u95f4\u89c4\u5212 + \u76ee\u6807\u70b9\u7c7b\u578b\u4e3a\u672b\u7aef\u4f4d\u59ff\u5355\u94fe\u5355\u70b9\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u957f\u5ea6={len(traj[target_pose_state.chain_name])}\")\n        time.sleep(0.8)\n    else:\n        print(f\"\u26a0\ufe0f \u8fd4\u56de\u72b6\u6001\u4e3aSUCCESS\uff0c\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u5df2\u5230\u8fbe\uff0c\u68c0\u67e5\u76ee\u6807\u503c\u4e0e\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e00\u81f4\u6216\u5728\u8bef\u5dee\u8303\u56f4\u5185\")\n\nexcept Exception as e:\n    print(f\"ERROR: Cartesian single-point planning exception: {e}\")\n\n# Scenario 3: joint-space planning with an explicit start state\ntry:\n    # \u6784\u9020\u76ee\u6807\u5173\u8282\u72b6\u6001\n\n    target_joint = gm.JointStates()\n    target_joint.chain_name = \"left_arm\"\n    target_joint.joint_positions = chain_joints[target_joint.chain_name]\n\n    start_joint = gm.JointStates()\n    start_joint.chain_name = \"left_arm\"\n    start_joint.joint_positions = [0] * 7\n\n    status, traj = motion.motion_plan(\n        target=target_joint,\n        start=start_joint,\n        enable_collision_check=False,\n        params=custom_param\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"Planning failed\"\n    if traj != {}:\n        print(f\"\u2705 \u5173\u8282\u7a7a\u95f4\u89c4\u5212 + \u76ee\u6807\u70b9\u7c7b\u578b\u4e3a\u5173\u8282\u5355\u94fe\u5355\u70b9\u89c4\u5212\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u70b9\u6570={len(traj[target_joint.chain_name])}\")\n    else:\n        print(f\"\u26a0\ufe0f \u8fd4\u56de\u72b6\u6001\u4e3aSUCCESS\uff0c\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u5df2\u5230\u8fbe\uff0c\u68c0\u67e5\u76ee\u6807\u503c\u4e0e\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e00\u81f4\u6216\u5728\u8bef\u5dee\u8303\u56f4\u5185\")\n\nexcept Exception as e:\n    print(f\"ERROR: joint-space single-point planning exception: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_6","title":"\u591a\u70b9\u8f68\u8ff9\u89c4\u5212","text":"examples/python/galbot_motion/motion_plan_multi_waypoints.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\nchain_joints = {\n    \"leg\": [0.4992,1.4991,1.0005,0.0000,-0.0004],\n    \"head\": [0.0000,0.0],\n    \"left_arm\": [1.9999,-1.6000,-0.5999,-1.6999,0.0000,-0.7999,0.0000],\n    \"right_arm\": [-2.0000,1.6001,0.6001,1.7000,0.0000,0.8000,0.0000]\n}\nchain_pose_baselink = {\n    \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n    \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n    \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n}\nwhole_body_joint = [\n    num for key in [\"leg\", \"head\", \"left_arm\", \"right_arm\"]\n    for num in chain_joints[key]\n]\nbase_state = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\ncustom_param = gm.Parameter()\n\n# \u573a\u666f1\uff1a\u7b1b\u5361\u5c14\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212\uff08PoseState\u76ee\u6807\uff09\ntry:\n    # \u6784\u9020\u76ee\u6807\u4f4d\u59ff\n    target_pose_state = gm.PoseState()\n    target_pose_state.chain_name = \"left_arm\"\n\n    # \u6784\u9020\u8def\u70b9\uff083\u4e2a\u4e2d\u95f4\u4f4d\u59ff\uff09\n    waypoint_poses = [\n        [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.2267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.3267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.4267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n    ]\n\n    status, traj = motion.motion_plan_multi_waypoints(\n        target=target_pose_state,\n        waypoint_poses=waypoint_poses,\n        enable_collision_check=False,\n        params=custom_param\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u7b1b\u5361\u5c14\u591a\u70b9\u5355\u94fe\u89c4\u5212\u5931\u8d25\"\n    if traj != {}:\n        print(f\"\u2705 \u7b1b\u5361\u5c14\u8def\u70b9\u5355\u94fe\u89c4\u5212\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u70b9\u6570={len(traj[target_pose_state.chain_name])}\")\n        time.sleep(0.8)\n    else:\n        print(f\"\u26a0\ufe0f \u8fd4\u56de\u72b6\u6001\u4e3aSUCCESS\uff0c\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u5df2\u5230\u8fbe\uff0c\u68c0\u67e5\u76ee\u6807\u503c\u4e0e\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e00\u81f4\u6216\u5728\u8bef\u5dee\u8303\u56f4\u5185\")\nexcept Exception as e:\n    print(f\"\u274c \u7b1b\u5361\u5c14\u591a\u70b9\u8fd0\u52a8\u89c4\u5212\u5f02\u5e38: {e}\")\n\n# \u573a\u666f2\uff1a\u5173\u8282\u7a7a\u95f4\u591a\u8def\u70b9\u89c4\u5212\uff08JointStates\u76ee\u6807\uff09\ntry:\n    # \u6784\u9020\u76ee\u6807\u4f4d\u59ff\n    target_joint = gm.JointStates()\n    target_joint.chain_name = \"left_arm\"\n\n    # \u6784\u9020\u8def\u70b9\uff083\u4e2a\u4e2d\u95f4\u4f4d\u59ff\uff09\n    waypoints = [\n        [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.2267,0.4342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.3267,0.6342,0.7356,0.0220,0.0127,0.0343,0.9991],\n        [0.4267,0.8342,0.7356,0.0220,0.0127,0.0343,0.9991]\n    ]\n\n    status, traj = motion.motion_plan_multi_waypoints(\n        target=target_joint,\n        waypoint_poses=waypoints,\n        enable_collision_check=False,\n        params=custom_param\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u7b1b\u5361\u5c14\u591a\u70b9\u5355\u94fe\u89c4\u5212\u5931\u8d25\"\n    if traj != {}:\n        print(f\"\u2705 \u5173\u8282\u8def\u70b9\u5355\u94fe\u89c4\u5212\u89c4\u5212\u6210\u529f: \u8f68\u8ff9\u70b9\u6570={len(traj[target_pose_state.chain_name])}\")\n    else:\n        print(f\"\u26a0\ufe0f \u8fd4\u56de\u72b6\u6001\u4e3aSUCCESS\uff0c\u8f68\u8ff9\u4e3a\u7a7a\uff0c\u53ef\u80fd\u5df2\u5230\u8fbe\uff0c\u68c0\u67e5\u76ee\u6807\u503c\u4e0e\u5f53\u524d\u72b6\u6001\u662f\u5426\u4e00\u81f4\u6216\u5728\u8bef\u5dee\u8303\u56f4\u5185\")\nexcept Exception as e:\n    print(f\"\u274c \u5173\u8282\u7a7a\u95f4\u591a\u70b9\u8fd0\u52a8\u89c4\u5212\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_7","title":"\u78b0\u649e\u68c0\u6d4b","text":"examples/python/galbot_motion/check_collision.py<pre><code>import galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot, GalbotNavigation   \nimport time\n\n# NOTE:\n# - GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.\n# - Collision checking uses self-collision + the collision world built from objects you load manually via\n#   add_obstacle()/attach_target_object() (including point clouds if you load them explicitly).\n\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\nnav = GalbotNavigation.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"Result: SUCCESS\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"Result: TIMEOUT\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"Result: FAULT\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"Result: INVALID_INPUT\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"Result: INIT_FAILED\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"Result: IN_PROGRESS\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"Result: STOPPED_UNREACHED\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"Result: DATA_FETCH_FAILED\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"Result: PUBLISH_FAIL\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"Result: COMM_DISCONNECTED\")\n\nif motion.init():\n    print(\"GalbotMotion init OK\")\nelse:\n    print(\"GalbotMotion init FAILED\")\nif robot.init():\n    print(\"GalbotRobot init OK\")\nelse:\n    print(\"GalbotRobot init FAILED\")\nif nav.init():\n    print(\"GalbotNavigation init OK\")\nelse:\n    print(\"GalbotNavigation init FAILED\")\n\n# Wait for data to be ready.\ntime.sleep(3)\n\nchain_joints = {\n    \"leg\": [0.4992,1.4991,1.0005,0.0000,-0.0004],\n    \"head\": [0.0000,0.0],\n    \"left_arm\": [1.9999,-1.6000,-0.5999,-1.6999,0.0000,-0.7999,0.0000],\n    \"right_arm\": [-2.0000,1.6001,0.6001,1.7000,0.0000,0.8000,0.0000]\n}\n\nwhole_body_joint = [\n    num for key in [\"leg\", \"head\", \"left_arm\", \"right_arm\"] \n    for num in chain_joints[key]\n]\nbase_state = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\ncustom_param = gm.Parameter()\n\ntry:\n    # Build RobotStates list to check.\n    check_states = [gm.RobotStates() for _ in range(2)]\n    check_states[0].whole_body_joint = whole_body_joint\n    check_states[0].base_state = base_state\n\n    bad_left_arm_joint = [1.99995,-1.60004,0.599905,-1.69994,0,-0.799924,0]\n\n    check_left_arm = gm.JointStates()\n    check_left_arm.chain_name = \"left_arm\"\n    check_left_arm.joint_positions = bad_left_arm_joint\n    check_states[1] = check_left_arm\n\n    status, collision_res = motion.check_collision(\n        start=check_states,\n        enable_collision_check=True\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"Collision check failed\"\n    assert len(collision_res) == len(check_states), \"Result size mismatch\"\n    print(f\"OK: collision check finished: {collision_res} (False=no collision)\")\nexcept Exception as e:\n    print(f\"ERROR: collision check exception: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_8","title":"\u9644\u52a0\u5de5\u5177","text":"examples/python/galbot_motion/attach_tool.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\ntry:\n    chain_name = \"left_arm\"\n    tool_name = \"suction_cup\"\n    status = motion.attach_tool(\n        chain=chain_name,\n        tool=tool_name\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u52a0\u8f7d\u5de5\u5177\u5931\u8d25\"\n    print(f\"\u2705 \u52a0\u8f7d\u5de5\u5177\u6210\u529f\")\nexcept Exception as e:\n    print(f\"\u274c \u52a0\u8f7d\u5de5\u5177\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_9","title":"\u5378\u8f7d\u5de5\u5177","text":"examples/python/galbot_motion/detach_tool.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"\u6267\u884c\u7ed3\u679c: SUCCESS, \u6267\u884c\u6210\u529f\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"\u6267\u884c\u7ed3\u679c: TIMEOUT, \u6267\u884c\u8d85\u65f6\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"\u6267\u884c\u7ed3\u679c: FAULT, \u53d1\u751f\u6545\u969c\u65e0\u6cd5\u7ee7\u7eed\u6267\u884c\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"\u6267\u884c\u7ed3\u679c: INVALID_INPUT, \u8f93\u5165\u53c2\u6570\u4e0d\u7b26\u5408\u8981\u6c42\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: INIT_FAILED, \u5185\u90e8\u901a\u8baf\u7ec4\u4ef6\u521b\u5efa\u5931\u8d25\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"\u6267\u884c\u7ed3\u679c: IN_PROGRESS, \u6b63\u5728\u8fd0\u52a8\u4e2d\u4f46\u672a\u5230\u4f4d\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"\u6267\u884c\u7ed3\u679c: STOPPED_UNREACHED, \u5df2\u505c\u6b62\u4f46\u672a\u5230\u8fbe\u76ee\u6807\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"\u6267\u884c\u7ed3\u679c: DATA_FETCH_FAILED, \u6570\u636e\u83b7\u53d6\u5931\u8d25\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"\u6267\u884c\u7ed3\u679c: PUBLISH_FAIL, \u6570\u636e\u53d1\u9001\u5931\u8d25\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"\u6267\u884c\u7ed3\u679c: COMM_DISCONNECTED, \u8fde\u63a5\u5931\u8d25\")\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\n# 1. \u5378\u8f7d\u5de5\u5177\ntry:\n    chain_name = \"left_arm\"\n    status = motion.detach_tool(\n        chain=chain_name\n    )\n    printStatus(status)\n    assert status == gm.MotionStatus.SUCCESS, \"\u5378\u8f7d\u5de5\u5177\u5931\u8d25\"\n    print(f\"\u2705 \u5378\u8f7d\u5de5\u5177\u6210\u529f\")\nexcept Exception as e:\n    print(f\"\u274c \u5378\u8f7d\u5de5\u5177\u5f02\u5e38: {e}\") \n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_10","title":"\u83b7\u53d6\u8fde\u6746\u540d\u79f0\u5217\u8868","text":"examples/python/galbot_motion/get_link_names.py<pre><code>import time\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# \u83b7\u53d6 GalbotMotion \u5355\u4f8b\u5e76\u521d\u59cb\u5316\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\nif motion.init():\n    print(\"GalbotMotion \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotMotion \u521d\u59cb\u5316\u5931\u8d25\")\nif robot.init():\n    print(\"GalbotRobot \u521d\u59cb\u5316\u6210\u529f\")\nelse:\n    print(\"GalbotRobot \u521d\u59cb\u5316\u5931\u8d25\")\n\n# \u7a0b\u5e8f\u7acb\u5373\u542f\u52a8\uff0c\u7a0d\u7b49\u6570\u636e\u5c31\u7eea\u65f6\u95f4\ntime.sleep(2)\n\ntry:\n    # \u83b7\u53d6\u6240\u6709\u8fde\u6746\u540d\u79f0\n    all_link_names = motion.get_link_names(only_end_effector=False)\n    print(f\"\\n\u6240\u6709\u8fde\u6746\u540d\u79f0 (\u5171 {len(all_link_names)} \u4e2a):\")\n    for i, link_name in enumerate(all_link_names, 1):\n        print(f\"  {i}. {link_name}\")\n\n    # \u53ea\u83b7\u53d6\u672b\u7aef\u6267\u884c\u5668\u8fde\u6746\u540d\u79f0\n    ee_link_names = motion.get_link_names(only_end_effector=True)\n    print(f\"\\n\u672b\u7aef\u6267\u884c\u5668\u8fde\u6746\u540d\u79f0 (\u5171 {len(ee_link_names)} \u4e2a):\")\n    for i, link_name in enumerate(ee_link_names, 1):\n        print(f\"  {i}. {link_name}\")\n\n    # \u793a\u4f8b\uff1a\u4f7f\u7528\u8fde\u6746\u540d\u79f0\u8fdb\u884c\u524d\u5411\u8fd0\u52a8\u5b66\u8ba1\u7b97\n    if ee_link_names:\n        print(f\"\\n\u4f7f\u7528\u672b\u7aef\u6267\u884c\u5668\u8fde\u6746 '{ee_link_names[0]}' \u8fdb\u884c\u524d\u5411\u8fd0\u52a8\u5b66\u8ba1\u7b97...\")\n        success, fk_result = motion.forward_kinematics(ee_link_names[0])\n        if success == gm.MotionStatus.SUCCESS:\n            print(f\"\u524d\u5411\u8fd0\u52a8\u5b66\u7ed3\u679c: {fk_result}\")\n        else:\n            print(f\"\u524d\u5411\u8fd0\u52a8\u5b66\u8ba1\u7b97\u5931\u8d25: {success}\")\nexcept Exception as e:\n    print(f\"\u274c \u83b7\u53d6\u8fde\u6746\u540d\u79f0\u5f02\u5e38: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#_11","title":"\u52a0\u8f7d/\u79fb\u9664\u73af\u5883\u78b0\u649e\u4f53","text":"examples/python/galbot_motion/add_obstacle.py<pre><code>import time\n\nimport galbot_sdk.g1 as gm\nfrom galbot_sdk.g1 import GalbotMotion, GalbotRobot\n\n# NOTE:\n# - GalbotMotion currently does NOT provide real-time obstacle perception / automatic environment updates.\n# - If you want Motion collision checking to consider obstacles (including point clouds), you must load them\n#   manually via add_obstacle()/attach_target_object().\n\nmotion = GalbotMotion.get_instance()\nrobot = GalbotRobot.get_instance()\n\ndef printStatus(status):\n        if(status == gm.MotionStatus.SUCCESS):\n            print(\"Result: SUCCESS\")\n        elif(status == gm.MotionStatus.TIMEOUT):\n            print(\"Result: TIMEOUT\")\n        elif(status == gm.MotionStatus.FAULT):\n            print(\"Result: FAULT\")\n        elif(status == gm.MotionStatus.INVALID_INPUT):\n            print(\"Result: INVALID_INPUT\")\n        elif(status == gm.MotionStatus.INIT_FAILED):\n            print(\"Result: INIT_FAILED\")\n        elif(status == gm.MotionStatus.IN_PROGRESS):\n            print(\"Result: IN_PROGRESS\")\n        elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n            print(\"Result: STOPPED_UNREACHED\")\n        elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n            print(\"Result: DATA_FETCH_FAILED\")\n        elif(status == gm.MotionStatus.PUBLISH_FAIL):\n            print(\"Result: PUBLISH_FAIL\")\n        elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n            print(\"Result: COMM_DISCONNECTED\")\n\nif motion.init():\n    print(\"GalbotMotion init OK\")\nelse:\n    print(\"GalbotMotion init FAILED\")\nif robot.init():\n    print(\"GalbotRobot init OK\")\nelse:\n    print(\"GalbotRobot init FAILED\")\n\n# Wait for data to be ready.\ntime.sleep(2)\n\n# 1) Add a box collision object into Motion environment.\n#    This affects Motion-side collision checking (e.g., motion_plan/check_collision).\ntry:\n    obstacle_id = \"box_test_1\"\n    obj_type = \"box\"\n    obj_pose = [1.0, 0.0, 1.0, 0,0,0,1]\n    obj_size = [1.0, 1.0, 1.0]\n    target_frame = \"world\"\n    status = motion.add_obstacle(\n        obstacle_id=obstacle_id,\n        obstacle_type=obj_type,\n        pose=obj_pose,\n        scale=obj_size,\n        target_frame=target_frame\n    )\n    printStatus(status)\n    motion.clear_obstacle()\n    assert status == gm.MotionStatus.SUCCESS, \"Failed to add obstacle\"\n    print(f\"OK: added obstacle: {obstacle_id}\")\nexcept Exception as e:\n    print(f\"ERROR: add obstacle exception: {e}\")\n\n# 2) Add a duplicate ID (expected to fail).\ntry:\n    obstacle_id = \"box_test_1\"\n    obj_type = \"box\"\n    obj_pose = [1.0, 0.0, 1.0, 0,0,0,1]\n    obj_size = [1.0, 1.0, 1.0]\n    target_frame = \"world\"\n    status = motion.add_obstacle(\n        obstacle_id=obstacle_id,\n        obstacle_type=obj_type,\n        pose=obj_pose,\n        scale=obj_size,\n        target_frame=target_frame\n    )\n    status = motion.add_obstacle(\n        obstacle_id=obstacle_id,\n        obstacle_type=obj_type,\n        pose=obj_pose,\n        scale=obj_size,\n        target_frame=target_frame\n    )\n    printStatus(status)\n    motion.clear_obstacle()\n    assert status == gm.MotionStatus.FAULT, \"Expected duplicate obstacle ID to fail\"\n    print(\"OK: duplicate obstacle ID is rejected\")\nexcept Exception as e:\n    print(f\"ERROR: duplicate obstacle exception: {e}\")\n\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#galbotnavigation","title":"\u7c7b\uff1aGalbotNavigation","text":""},{"location":"examples_python/#_12","title":"\u83b7\u53d6\u5b9e\u4f8b / \u521d\u59cb\u5316","text":"examples/python/galbot_navigation/get_instance.py<pre><code>from galbot_sdk.g1 import GalbotNavigation, GalbotRobot\nimport numpy as np\n\n# \u521d\u59cb\u5316\u7cfb\u7edf\u4e0e\u5bfc\u822a\u6a21\u5757\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\nnav = GalbotNavigation.get_instance()\nnav.init()\n\nprint(\"GalbotNavigation \u5df2\u521d\u59cb\u5316:\", nav is not None)\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#_13","title":"\u91cd\u5b9a\u4f4d / \u662f\u5426\u5df2\u5b9a\u4f4d / \u83b7\u53d6\u5f53\u524d\u4f4d\u59ff","text":"examples/python/galbot_navigation/relocalized.py<pre><code>from galbot_sdk.g1 import GalbotNavigation, GalbotRobot\nimport numpy as np\nimport time\n\nnav = GalbotNavigation.get_instance()\nnav.init()\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\ninit_pose = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n\n# \u5c1d\u8bd5\u786e\u4fdd\u5b9a\u4f4d\u6210\u529f\nwhile not nav.is_localized():\n    nav.relocalize(init_pose)\n    time.sleep(0.5)\n\nprint(\"\u5f53\u524d\u4f4d\u59ff:\", nav.get_current_pose())\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#_14","title":"\u68c0\u67e5\u8def\u5f84\u53ef\u8fbe\u6027\u5e76\u963b\u585e\u5bfc\u822a\u5230\u76ee\u6807","text":"examples/python/galbot_navigation/check_path_reachability.py<pre><code>from galbot_sdk.g1 import GalbotNavigation, GalbotRobot\nimport numpy as np\n\nnav = GalbotNavigation.get_instance()\nnav.init()\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\nstart = nav.get_current_pose()\ngoal = np.array([1.0, 1.0, 0.0, 0, 0, 0.4794255, 0.8775826])\n\nif nav.check_path_reachability(goal, start):\n    status = nav.navigate_to_goal(goal, enable_collision_check=True, is_blocking=True, timeout=30)\n    print(\"navigate_to_goal \u8fd4\u56de\u72b6\u6001:\", status)\n    print(\"\u662f\u5426\u5230\u8fbe:\", nav.check_goal_arrival())\nelse:\n    print(\"\u8def\u5f84\u4e0d\u53ef\u8fbe\u6216\u4e0d\u5b89\u5168\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#_15","title":"\u975e\u963b\u585e\u5bfc\u822a + \u8f6e\u8be2\u5224\u65ad\u5230\u8fbe","text":"examples/python/galbot_navigation/navigate_to_goal.py<pre><code>from galbot_sdk.g1 import GalbotNavigation, GalbotRobot\nimport numpy as np\nimport time\n\nnav = GalbotNavigation.get_instance()\nnav.init()\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\ngoal = np.array([0.5, 0.0, 0.0, 0, 0, 0.0, 1.0])\n\nnav.navigate_to_goal(goal, enable_collision_check=True, is_blocking=False, timeout=20)\nwhile not nav.check_goal_arrival():\n    print(\"\u6b63\u5728\u5bfc\u822a...\")\n    time.sleep(0.5)\n\nprint(\"\u5df2\u5230\u8fbe\u76ee\u6807\")\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#_16","title":"\u76f4\u7ebf\u79fb\u52a8\u5230\u76ee\u6807 / \u505c\u6b62\u5bfc\u822a","text":"examples/python/galbot_navigation/move_straight_to.py<pre><code>from galbot_sdk.g1 import GalbotNavigation, GalbotRobot\nimport numpy as np\nimport time\n\nnav = GalbotNavigation.get_instance()\nnav.init()\nrobot = GalbotRobot.get_instance()\nrobot.init()\n\ntarget = np.array([0.2, 0.0, 0.0, 0, 0, 0.0, 1.0])\n\nnav.move_straight_to(target, is_blocking=False, timeout=10)\ntime.sleep(1.0)\nnav.stop_navigation()\n\n# \u4e3b\u52a8\u53d1\u51faSIGINT\u9000\u51fa\u4fe1\u53f7\nrobot.request_shutdown()\n# \u7b49\u5f85\u8fdb\u5165shutdown\u72b6\u6001\nrobot.wait_for_shutdown()\n# \u8fdb\u884cSDK\u8d44\u6e90\u91ca\u653e\nrobot.destroy()\nprint('\u8d44\u6e90\u91ca\u653e\u6210\u529f')\n</code></pre>"},{"location":"examples_python/#_17","title":"\u5b8c\u6574\u8fd0\u884c\u793a\u4f8b\uff08\u7b80\u5355\u6d41\u7a0b\uff09","text":"examples/python/galbot_navigation/complete_example.py<pre><code>from galbot_sdk.g1 import GalbotRobot, GalbotNavigation\nimport numpy as np\nimport time\n\nrobot = GalbotRobot.get_instance()\nrobot.init()\nnav = GalbotNavigation.get_instance()\nnav.init()\n\ninit_pose = np.array([0.0, 0.0, 0.0, 0, 0, 0.0, 1.0])\ngoal_pose = np.array([1.0, 0.0, 0.0, 0, 0, 0.0, 1.0])\n\nwhile not nav.is_localized():\n    nav.relocalize(init_pose)\n    time.sleep(0.5)\n\nif nav.check_path_reachability(goal_pose, nav.get_current_pose()):\n    nav.navigate_to_goal(goal_pose, enable_collision_check=True, is_blocking=True, timeout=30)\n    print(\"\u662f\u5426\u5df2\u5230\u8fbe:\", nav.check_goal_arrival())\n\n# \u5173\u95ed\u7cfb\u7edf\nrobot.request_shutdown()\nrobot.wait_for_shutdown()\nrobot.destroy()\n</code></pre>"},{"location":"examples_python/#parameter","title":"\u7c7b\uff1aParameter","text":"examples/python/galbot_motion/create_parameter.py<pre><code>from galbot_sdk.g1 import Parameter, create_parameter\n\n# \u901a\u8fc7\u6784\u9020\u51fd\u6570\u521b\u5efa Parameter \u5e76\u8bbe\u7f6e\u9009\u9879\np = Parameter()\np.set_blocking(True)\np.set_check_collision(False)\np.set_timeout(5.0)\np.set_actuate('with_chain_only')\np.set_tool_pose(False)\np.set_reference_frame('base_link')\np.set_joint_state('left_arm', [0.0] * 7)\n\nprint('blocking:', p.get_blocking())\nprint('collision check:', p.get_check_collision())\nprint('timeout:', p.get_timeout())\n\n# \u6216\u8005\u4f7f\u7528\u5de5\u5382\u51fd\u6570\u5feb\u901f\u521b\u5efa Parameter\np2 = create_parameter(direct_execute=False, blocking=True, timeout=3.0, actuate='with_chain_only', tool_pose=False, check_collision=True)\nprint('\u5de5\u5382\u521b\u5efa\u7684 timeout:', p2.get_timeout())\n</code></pre>"},{"location":"examples_python/#_18","title":"\u8f85\u52a9\u51fd\u6570","text":""},{"location":"examples_python/#check_motion_status","title":"check_motion_status","text":"examples/python/galbot_motion/check_motion_status.py<pre><code>from galbot_sdk.g1 import MotionStatus, check_motion_status\n\nstatus_str = check_motion_status(MotionStatus.SUCCESS)\nprint('MotionStatus \u5b57\u7b26\u4e32:', status_str)\n</code></pre>"},{"location":"examples_python/#create_joint_state-create_pose_state","title":"create_joint_state / create_pose_state","text":"examples/python/galbot_motion/create_pose_state.py<pre><code>from galbot_sdk.g1 import create_joint_state, create_pose_state, JointStates, PoseState\n\n# \u4f7f\u7528\u5de5\u5382\u51fd\u6570\u521b\u5efa\u8f85\u52a9\u5bf9\u8c61\njs = create_joint_state()\nps = create_pose_state()\n\n# \u586b\u5145\u793a\u4f8b\u5b57\u6bb5\njs.chain_name = 'left_arm'\njs.joint_positions = [0.0] * 7\n\nps.chain_name = 'left_arm'\nps.pose = [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\n\nprint(type(js), js.chain_name)\nprint(type(ps), ps.chain_name)\n</code></pre>"},{"location":"installation_and_configuration/","title":"\u5b89\u88c5\u4e0e\u914d\u7f6e","text":""},{"location":"installation_and_configuration/#_2","title":"\u7cfb\u7edf\u8981\u6c42","text":"\u5bf9\u8c61 \u63a8\u8350 \u652f\u6301\u8303\u56f4 \u64cd\u4f5c\u7cfb\u7edf Ubuntu 22.04 Ubuntu 20.04 - 24.04 \u67b6\u6784\uff08PC\uff09 x86_64 x86_64 \u67b6\u6784\uff08\u673a\u5668\u4eba\uff09 aarch64 aarch64 Python 3.8+ 3.8 - 3.14 \u5b58\u50a8\u7a7a\u95f4 16GB 3GB+"},{"location":"installation_and_configuration/#_3","title":"\u672f\u8bed\u8bf4\u660e","text":"<ul> <li>XCU\uff1a\u57fa\u7840\u8fd0\u7b97\u5e73\u53f0\uff0c\u8d1f\u8d23\u5e95\u5c42\u63a7\u5236\u548c\u57fa\u7840\u8fd0\u7b97</li> <li>Orin\uff1a\u9ad8\u7b97\u529b\u8fd0\u7b97\u5e73\u53f0\uff0c\u8d1f\u8d23\u56fe\u50cf\u5904\u7406\u548cAI\u8ba1\u7b97</li> </ul>"},{"location":"installation_and_configuration/#_4","title":"\u6a21\u5f0f\u4e00\uff1a\u673a\u5668\u4eba\u7aef\u90e8\u7f72","text":"<p>\u9002\u7528\u573a\u666f\uff1a \u751f\u4ea7\u73af\u5883\u90e8\u7f72\uff0c\u5b9e\u65f6\u6027\u8981\u6c42\u9ad8\u7684\u5e94\u7528</p> <p>\u7279\u70b9\uff1a \u65e0\u7f51\u7edc\u5ef6\u8fdf\uff0c\u901a\u4fe1\u5f00\u9500\u6700\u5c0f</p>"},{"location":"installation_and_configuration/#1","title":"1. \u8fde\u63a5\u673a\u5668\u4eba\u7f51\u7edc","text":"<p>1.1 \u5f00\u673a\u540e\u5728\u7f51\u7edc\u9009\u62e9\u754c\u9762\u8fde\u63a5WiFi</p> <p></p> <p></p> <p>1.2 \u5728Network\u754c\u9762\u67e5\u770b\u673a\u5668\u4ebaIP\u5730\u5740</p> <p></p>"},{"location":"installation_and_configuration/#2-sdk","title":"2. \u90e8\u7f72SDK\u5230\u673a\u5668\u4eba","text":"<p>2.1 \u5728PC\u4e0a\u6267\u884c\u90e8\u7f72\u811a\u672c</p> <pre><code>cd GalbotSDK\n./deploy_to_robot.sh\n</code></pre> <p>2.2 \u6839\u636e\u63d0\u793a\u8f93\u5165\u8fde\u63a5\u4fe1\u606f</p> <ul> <li>\u7528\u6237\u540d\uff1a<code>galbot</code></li> <li>Orin IP\u5730\u5740\uff1a\u4f8b\u5982 <code>192.168.120.180</code> </li> <li>\u5bc6\u7801\uff1a<code>gb@2023</code></li> </ul> <p></p> <p>\u90e8\u7f72\u7ed3\u679c</p> <p>\u52a8\u6001\u5e93\u81ea\u52a8\u5b89\u88c5\u5230\uff1a<code>/data/galbot/lib</code></p> <p>2.3 \u9a8c\u8bc1\u5b89\u88c5</p> <pre><code>ssh galbot@&lt;\u673a\u5668\u4ebaIP&gt;\nls /data/galbot/lib | grep galbot_g1_sdk\n</code></pre> <p>\u9884\u671f\u8f93\u51fa</p> <p>\u663e\u793a libgalbot_g1_sdk.so \u548c libgalbot_g1_sdk.so.1.5.0</p> <p></p>"},{"location":"installation_and_configuration/#3-pcsdk","title":"3. \u5728PC\u4e0a\u5b89\u88c5SDK","text":"<p>\u8fdb\u5165\u5230SDK\u76ee\u5f55\u4e0b\u6267\u884c\u5b89\u88c5\u811a\u672c <pre><code>cd GalbotSDK\nsudo ./install.sh\n</code></pre></p>"},{"location":"installation_and_configuration/#4","title":"4. \u7f16\u8bd1\u7a0b\u5e8f","text":"<p>4.1 \u5728PC\u4e0a\u4ea4\u53c9\u7f16\u8bd1\uff08aarch64\uff09</p> <pre><code>cd examples/cpp/\nmkdir -p build\ncd build\ncmake ../ -DCMAKE_TOOLCHAIN_FILE=../cmake/linux-aarch64-gcc940.cmake\nmake\n</code></pre> <p>4.2 \u4f20\u8f93\u53ef\u6267\u884c\u6587\u4ef6\u5230\u673a\u5668\u4eba\u7684Orin\u4e0a</p> <pre><code>scp your_app galbot@&lt;\u673a\u5668\u4ebaIP&gt;:/userdata\n</code></pre>"},{"location":"installation_and_configuration/#5","title":"5. \u8fd0\u884c\u7a0b\u5e8f","text":"<p>5.1 C++\u7a0b\u5e8f</p> <pre><code>ssh galbot@&lt;\u673a\u5668\u4ebaIP&gt;\ncd /userdata\n./your_app\n</code></pre> <p>5.2 Python\u7a0b\u5e8f</p> <pre><code>export PYTHONPATH=/data/galbot/lib:$PYTHONPATH\npython your_app.py\n</code></pre> <p>\u73af\u5883\u53d8\u91cf\u6301\u4e45\u5316</p> <pre><code>echo 'export PYTHONPATH=/data/galbot/lib:$PYTHONPATH' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"installation_and_configuration/#pc","title":"\u6a21\u5f0f\u4e8c\uff1aPC\u7aef\u90e8\u7f72","text":"<p>\u9002\u7528\u573a\u666f\uff1a \u5f00\u53d1\u8c03\u8bd5\uff0c\u5feb\u901f\u8fed\u4ee3</p> <p>\u7279\u70b9\uff1a \u5f00\u53d1\u4fbf\u6377\uff0c\u652f\u6301\u5c40\u57df\u7f51\u8fdc\u7a0b\u63a7\u5236</p>"},{"location":"installation_and_configuration/#1_1","title":"1. \u7269\u7406\u8fde\u63a5","text":"<p>\u4f7f\u7528\u7f51\u7ebf\u8fde\u63a5PC\u4e0e\u673a\u5668\u4eba</p> <p></p>"},{"location":"installation_and_configuration/#2","title":"2. \u914d\u7f6e\u7f51\u7edc","text":""},{"location":"installation_and_configuration/#21-pcip","title":"2.1 \u914d\u7f6ePC\u7f51\u53e3IP","text":"<ul> <li>IP\u5730\u5740\uff1a<code>192.168.1.99</code>\uff08\u6216\u540c\u7f51\u6bb5\u5176\u4ed6\u5730\u5740\uff09</li> <li>\u5b50\u7f51\u63a9\u7801\uff1a<code>255.255.255.0</code></li> </ul> <p>Ubuntu\u8bbe\u7f6e\u8def\u5f84\uff1a\u8bbe\u7f6e \u2192 \u7f51\u7edc \u2192 \u6709\u7ebf\u8bbe\u7f6e \u2192 IPv4 \u2192 \u624b\u52a8</p> <p></p> <p>\u9a8c\u8bc1\u914d\u7f6e\uff1a</p> <pre><code>ifconfig\n</code></pre> <p>\u9884\u671f\u8f93\u51fa</p> <p>\u663e\u793a <code>inet 192.168.1.99</code></p> <p></p>"},{"location":"installation_and_configuration/#22-pcip","title":"2.2 \u914d\u7f6ePC\u7aefIP\u914d\u7f6e\u6587\u4ef6","text":"<p>\u6587\u4ef6\u8def\u5f84\uff1a<code>/data/config/embosa_ip_config.json</code></p> <p>\u914d\u7f6e\u793a\u4f8b\uff08\u5047\u8bbePC: 192.168.1.99, XCU: 192.168.1.66, Orin: 192.168.1.88\uff09\uff1a</p> <pre><code>{\n    \"embosa_ip\": {\n        \"local_interface\": [\n            \"192.168.1.99\"\n        ],\n        \"peer_lists\": [\n            \"192.168.1.66\",\n            \"192.168.1.88\"\n        ]\n    }\n}\n</code></pre>"},{"location":"installation_and_configuration/#23-orinip","title":"2.3 \u914d\u7f6eOrin\u7aefIP\u914d\u7f6e\u6587\u4ef6","text":"<p>\u524d\u63d0\u6761\u4ef6</p> <p>\u9700\u5148\u901a\u8fc7WiFi\u8fde\u63a5Orin\uff0c\u53c2\u8003\u6a21\u5f0f\u4e00\u6b65\u9aa41</p> <p>2.3.1 \u767b\u5f55Orin</p> <pre><code>ssh galbot@&lt;Orin\u65e0\u7ebfIP&gt;\n# \u5bc6\u7801\uff1agb@2023\n</code></pre> <p>2.3.2 \u7f16\u8f91\u914d\u7f6e\u6587\u4ef6</p> <pre><code>vi /data/config/embosa_ip_config.json\n</code></pre> <p>2.3.3 \u914d\u7f6e\u5185\u5bb9</p> <p>\u91cd\u8981</p> <p><code>192.168.100.88</code> \u548c <code>192.168.100.66</code> \u662fOrin\u4e0eXCU\u5185\u90e8\u76f4\u8fdeIP\uff0c\u5fc5\u987b\u4fdd\u7559</p> <pre><code>{\n    \"embosa_ip\": {\n        \"local_interface\": [\n            \"192.168.100.88\",\n            \"192.168.1.88\"\n        ],\n        \"peer_lists\": [\n            \"192.168.100.66\",\n            \"192.168.1.99\"\n        ]\n    }\n}\n</code></pre>"},{"location":"installation_and_configuration/#24-xcuip","title":"2.4 \u914d\u7f6eXCU\u7aefIP\u914d\u7f6e\u6587\u4ef6","text":"<p>2.4.1 \u767b\u5f55XCU</p> <pre><code>ssh root@&lt;XCU\u65e0\u7ebfIP&gt;\n# \u5bc6\u7801\uff1a12345678\n</code></pre> <p>2.4.2 \u7f16\u8f91\u914d\u7f6e\u6587\u4ef6</p> <pre><code>vi /data/config/embosa_ip_config.json\n</code></pre> <p>2.4.3 \u914d\u7f6e\u5185\u5bb9</p> <pre><code>{\n    \"embosa_ip\": {\n        \"local_interface\": [\n            \"192.168.100.66\",\n            \"192.168.1.66\"\n        ],\n        \"peer_lists\": [\n            \"192.168.100.88\",\n            \"192.168.1.99\"\n        ]\n    }\n}\n</code></pre>"},{"location":"installation_and_configuration/#25","title":"2.5 \u9a8c\u8bc1\u7f51\u7edc\u8fde\u63a5","text":"<p>\u5fc5\u987b\u64cd\u4f5c</p> <p>\u914d\u7f6e\u4fee\u6539\u540e\u5fc5\u987b\u91cd\u542f\u673a\u5668\u4eba</p> <p>\u91cd\u542f\u540e\u6d4b\u8bd5\u8fde\u63a5\uff1a</p> <pre><code>ping 192.168.1.66  # \u6d4b\u8bd5XCU\nping 192.168.1.88  # \u6d4b\u8bd5Orin\n</code></pre> <p>\u9884\u671f\u7ed3\u679c</p> <p>\u6b63\u5e38\u8fd4\u56deping\u54cd\u5e94</p> <p></p>"},{"location":"installation_and_configuration/#3-pcsdk_1","title":"3. \u5728PC\u4e0a\u5b89\u88c5SDK","text":"<p>\u8fdb\u5165\u5230SDK\u76ee\u5f55\u4e0b\u6267\u884c\u5b89\u88c5\u811a\u672c <pre><code>cd GalbotSDK\nsudo ./install.sh\n</code></pre></p>"},{"location":"installation_and_configuration/#4_1","title":"4. \u7f16\u8bd1\u7a0b\u5e8f","text":"<p>\u5728PC\u4e0a\u7f16\u8bd1\uff08x86_64\uff09</p> <pre><code>cd examples/cpp/\nmkdir -p build\ncd build\ncmake ../ -DCMAKE_TOOLCHAIN_FILE=../cmake/linux-x86_64-gcc940.cmake\nmake\n</code></pre>"},{"location":"installation_and_configuration/#5_1","title":"5. \u8fd0\u884c\u7a0b\u5e8f","text":"<p>5.1 \u914d\u7f6e\u73af\u5883\u53d8\u91cf</p> <p>\u8def\u5f84\u8bf4\u660e</p> <p>/opt/galbot/\u4e3a\u9ed8\u8ba4\u5b89\u88c5\u8def\u5f84\uff0c\u53ef\u6839\u636e\u81ea\u5df1\u7684\u5b89\u88c5\u8def\u5f84\u8fdb\u884c\u4fee\u6539</p> <pre><code>source /opt/galbot/galbot_sdk/linux-x86_64-gcc940/setup.sh\n</code></pre> <p>\u73af\u5883\u53d8\u91cf\u6301\u4e45\u5316</p> <pre><code>echo 'source /opt/galbot/galbot_sdk/linux-x86_64-gcc940/setup.sh' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>5.2 \u8fd0\u884cC++\u7a0b\u5e8f</p> <pre><code>cd /userdata  # \u6216\u7a0b\u5e8f\u6240\u5728\u76ee\u5f55\n./your_app\n</code></pre> <p>5.3 \u8fd0\u884cPython\u7a0b\u5e8f</p> <pre><code>python your_app.py\n</code></pre>"},{"location":"license/","title":"Galbot SDK \u8bb8\u53ef\u8bc1","text":"<pre><code>Copyright (c) 2023-2026 Galbot. All Rights Reserved.\n\nThis software contains confidential and proprietary information of Galbot, Inc.\n(\"Confidential Information\"). You shall not disclose such Confidential Information\nand shall use it only in accordance with the terms of the license agreement you\nentered into with Galbot, Inc.\n\nUNAUTHORIZED COPYING, USE, OR DISTRIBUTION OF THIS SOFTWARE, OR ANY PORTION OR\nDERIVATIVE THEREOF, IS STRICTLY PROHIBITED. IF YOU HAVE RECEIVED THIS SOFTWARE IN\nERROR, PLEASE NOTIFY GALBOT, INC. IMMEDIATELY AND DELETE IT FROM YOUR SYSTEM.\n</code></pre>"},{"location":"license/#_1","title":"\u7b2c\u4e09\u65b9\u4f9d\u8d56\u8bb8\u53ef\u8bc1","text":"<p>\u672c\u9879\u76ee\u4e2d\u4f7f\u7528\u7684\u7b2c\u4e09\u65b9\u4f9d\u8d56\u5e93\u7684\u8bb8\u53ef\u8bc1\u6587\u4ef6\u4f4d\u4e8e <code>licenses/</code> \u76ee\u5f55\u4e2d\u3002</p>"},{"location":"overview/","title":"\u4ea7\u54c1\u6982\u8ff0","text":"<p>Galbot SDK \u662f\u4e13\u4e3a Galbot \u7cfb\u5217\u673a\u5668\u4eba\u5e73\u53f0\u63d0\u4f9b\u7684\u7edf\u4e00\u4e8c\u6b21\u5f00\u53d1\u5de5\u5177\u5305\u3002\u901a\u8fc7\u5c01\u88c5\u5e95\u5c42\u786c\u4ef6\u901a\u4fe1\u4e0e\u7b97\u6cd5\u7ec6\u8282\uff0c\u63d0\u4f9b\u539f\u5b50\u5316\u63a7\u5236\u4e0e\u611f\u77e5\u80fd\u529b\uff0c\u4ee5\u53ca\u53ef\u9009\u7684\u4e1a\u52a1\u7ea7\u80fd\u529b\u3002\u9002\u7528\u4e8e\u5de5\u4e1a\u4e0e\u96f6\u552e\u96c6\u6210\u3001\u5b66\u672f\u7814\u7a76\u7b49\u573a\u666f\uff0c\u5e2e\u52a9\u5f00\u53d1\u8005\u901a\u8fc7\u7b80\u6d01\u7684 API \u5feb\u901f\u5b9e\u73b0\u8fd0\u52a8\u63a7\u5236\u3001\u611f\u77e5\u4ea4\u4e92\u4e0e\u81ea\u4e3b\u5bfc\u822a\u3002</p>"},{"location":"overview/#_2","title":"\u6838\u5fc3\u529f\u80fd","text":"<p>Galbot SDK \u91c7\u7528\u5206\u5c42\u89e3\u8026\u8bbe\u8ba1\uff0c\u5c06\u673a\u5668\u4eba\u80fd\u529b\u5212\u5206\u4e3a\u4e09\u5927\u6838\u5fc3\u5c42\u6b21\uff0c\u8986\u76d6\u4ece\u5e95\u5c42\u63a7\u5236\u5230\u9ad8\u5c42\u4e1a\u52a1\u7684\u5168\u573a\u666f\u5f00\u53d1\u9700\u6c42\u3002</p> <p></p>"},{"location":"overview/#1","title":"1. \u57fa\u7840\u80fd\u529b","text":"<p>\u63d0\u4f9b\u786c\u4ef6\u76f4\u63a5\u63a7\u5236\u4e0e\u539f\u59cb\u6570\u636e\u8bbf\u95ee\u80fd\u529b\uff0c\u5b9e\u73b0\u5bf9\u673a\u5668\u4eba\u7684\u64cd\u63a7\u4e0e\u4f20\u611f\u5668\u6570\u636e\u83b7\u53d6\u3002</p> <ul> <li>\u8fd0\u52a8\u63a7\u5236\uff1a\u652f\u6301\u5173\u8282\u7a7a\u95f4\u4f4d\u7f6e/\u8f68\u8ff9\u63a7\u5236\u3001\u672b\u7aef\u7b1b\u5361\u5c14\u7a7a\u95f4\u4f4d\u59ff/\u8f68\u8ff9\u63a7\u5236\uff0c\u4ee5\u53ca\u5e95\u76d8\u7684\u901f\u5ea6\u5f00\u73af\u63a7\u5236\u4e0e\u7d27\u6025\u505c\u6b62\u3002</li> <li>\u4f20\u611f\u5668\u8bfb\u53d6\uff1a\u63d0\u4f9b\u5f69\u8272/\u6df1\u5ea6\u89c6\u89c9\u6d41\u3001\u96f7\u8fbe\u70b9\u4e91\u3001IMU \u60ef\u6027\u6570\u636e\u3001\u529b\u4f20\u611f\u5668\u53ca\u8d85\u58f0\u6ce2\u7b49\u5168\u65b9\u4f4d\u73af\u5883\u611f\u77e5\u6570\u636e\u3002</li> <li>\u4eba\u673a\u4ea4\u4e92\uff1a\u5305\u542b\u9ea6\u514b\u98ce\u6d41\u91c7\u96c6\u3001\u97f3\u9891\u64ad\u653e\u63a7\u5236\u3001RGB \u6307\u793a\u706f\u6548\u679c\u8bbe\u7f6e\u3002</li> <li>\u7cfb\u7edf\u4e0e\u5b89\u5168\uff1a\u652f\u6301\u7535\u6e90/\u65e5\u5fd7\u7cfb\u7edf\u76d1\u63a7\u3001\u8f6f\u4ef6\u6025\u505c\u673a\u5236\u3001\u78b0\u649e\u4fdd\u62a4\u53c2\u6570\u914d\u7f6e\u53ca\u5b9e\u65f6\u8d44\u6e90\u9500\u6bc1\u7ba1\u7406\u3002</li> </ul>"},{"location":"overview/#2","title":"2. \u9ad8\u7ea7\u80fd\u529b","text":"<p>\u63d0\u4f9b\u5185\u7f6e\u7b97\u6cd5\u670d\u52a1\u8bbf\u95ee\u80fd\u529b\uff0c\u652f\u6301\u81ea\u5b9a\u4e49\u7b97\u6cd5\u63a8\u7406\u4e0e\u6267\u884c\u3002\u5f00\u53d1\u8005\u53ef\u6839\u636e\u9700\u6c42\u4f7f\u7528\u5185\u7f6e\u7b97\u6cd5\u670d\u52a1\uff0c\u6216\u81ea\u884c\u8bbe\u8ba1\u7b97\u6cd5\u3002</p> <ul> <li>\u89c4\u5212\u4e0e\u63a7\u5236\u63a5\u53e3<ul> <li>\u5b9e\u65f6\u63a7\u5236\uff1a\u5f00\u653e\u9ad8\u9891\u5b9e\u65f6\u5173\u8282/\u672b\u7aef\u6307\u4ee4\u63a5\u53e3\uff0c\u652f\u6301\u81ea\u5b9a\u4e49\u95ed\u73af\u63a7\u5236\u7b97\u6cd5\u53ca VLA\u3001RL \u7b49\u63a8\u7406\u6267\u884c\u3002</li> <li>\u6b63\u9006\u8fd0\u52a8\u5b66\uff1a\u63d0\u4f9b\u6b63\u5411\u8fd0\u52a8\u5b66\u4e0e\u9006\u5411\u8fd0\u52a8\u5b66\u8ba1\u7b97\u63a5\u53e3\uff0c\u652f\u6301\u7ea6\u675f\u4f18\u5316\u3002</li> <li>\u8fd0\u52a8\u89c4\u5212\uff1a\u652f\u6301\u5355\u94fe\u4e0e\u5168\u8eab\u591a\u94fe\u3001\u5355\u8def\u70b9\u8f68\u8ff9\u4e0e\u591a\u8def\u70b9\u8fde\u7eed\u8f68\u8ff9\u751f\u6210\uff0c\u5e76\u5177\u5907\u81ea\u78b0\u649e\u4e0e\u73af\u5883\u78b0\u649e\u68c0\u6d4b\u529f\u80fd\u3002</li> <li>\u73af\u5883\u7ba1\u7406\uff1a\u652f\u6301\u52a8\u6001\u6dfb\u52a0/\u5220\u9664\u969c\u788d\u7269\uff0c\u4ee5\u53ca\u9644\u52a0\u672b\u7aef\u5de5\u5177\u4e0e\u76ee\u6807\u7269\u4f53\u3002</li> </ul> </li> <li>\u5bfc\u822a\u63a5\u53e3<ul> <li>\u81ea\u4e3b\u5bfc\u822a\uff1a\u5177\u5907 SLAM \u5efa\u56fe\u5b9a\u4f4d\u3001\u5168\u5c40/\u5c40\u90e8\u8def\u5f84\u89c4\u5212\u53ca\u52a8\u6001\u907f\u969c\u80fd\u529b\uff0c\u652f\u6301\u5bfc\u822a\u4efb\u52a1\u7684\u7cbe\u51c6\u4e0b\u53d1\u4e0e\u72b6\u6001\u76d1\u63a7\u3002</li> </ul> </li> </ul>"},{"location":"overview/#3","title":"3. \u4e1a\u52a1\u80fd\u529b","text":"<p>\u63d0\u4f9b\u573a\u666f\u5316\u4e1a\u52a1\u903b\u8f91\u5c01\u88c5\uff0c\u5305\u542b\u6599\u7bb1\u642c\u8fd0\u3001SPS \u5206\u62e3\u7b49\u4e1a\u52a1\u573a\u666f\u80fd\u529b\u3002\u7528\u6237\u53ef\u6839\u636e\u5b9e\u9645\u573a\u666f\u8fdb\u884c\u53c2\u6570\u914d\u7f6e\u548c\u6d41\u7a0b\u4fee\u6539\uff0c\u5feb\u901f\u5b9e\u73b0\u7279\u5b9a\u4e1a\u52a1\u529f\u80fd\u3002\u8be5\u90e8\u5206\u80fd\u529b\u9700\u8054\u7cfb\u5546\u52a1\u89e3\u9501\u3002</p> <ul> <li>SPS \u5206\u62e3\u6a21\u5757\uff1a\u9488\u5bf9\u5206\u62e3\u573a\u666f\u7684\u81ea\u52a8\u5316\u62fe\u53d6\u4e0e\u653e\u7f6e\u903b\u8f91\u3002</li> <li>\u6599\u7bb1\u642c\u8fd0\u6a21\u5757\uff1a\u6599\u7bb1\u8bc6\u522b\u3001\u5806\u53e0\u53ca\u642c\u8fd0\u6d41\u7a0b\u7684\u5feb\u901f\u5b9e\u73b0\u3002</li> <li>\u66f4\u591a\u4e1a\u52a1\u6a21\u5757\u6301\u7eed\u5f00\u53d1\u4e2d\u3002</li> </ul>"},{"location":"overview/#_3","title":"\u5e94\u7528\u573a\u666f","text":"<p>Galbot SDK \u53ef\u6839\u636e\u7528\u6237\u5b9e\u9645\u9700\u6c42\uff0c\u5e94\u7528\u4e8e\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u4ee5\u4e0b\u573a\u666f\uff1a</p> <ul> <li>\u5de5\u4e1a\u573a\u666f\uff1a\u7269\u6599\u642c\u8fd0\u4e0e\u5206\u62e3\u3001\u667a\u80fd\u4ed3\u50a8\u7ba1\u7406</li> <li>\u96f6\u552e\u573a\u666f\uff1a\u5546\u54c1\u5206\u62e3\u4e0e\u914d\u9001</li> <li>\u670d\u52a1\u573a\u666f\uff1a\u8fce\u5bbe\u5bfc\u89c8\u670d\u52a1</li> <li>\u7814\u7a76\u573a\u666f\uff1a\u673a\u5668\u4eba\u7b97\u6cd5\u7814\u7a76\u3001\u4eba\u673a\u4ea4\u4e92\u5b9e\u9a8c</li> </ul> <p></p>"},{"location":"overview/#_4","title":"\u670d\u52a1\u4e0e\u652f\u6301","text":"<p>Galbot SDK \u63d0\u4f9b\u4ee5\u4e0b\u670d\u52a1\u4e0e\u652f\u6301\uff1a</p> <ul> <li>\u6280\u672f\u6587\u6863\uff1aAPI \u53c2\u8003\u3001\u5f00\u53d1\u793a\u4f8b\u4e0e\u6700\u4f73\u5b9e\u8df5</li> <li>\u6280\u672f\u652f\u6301\uff1a\u6280\u672f\u54a8\u8be2\u4e0e\u95ee\u9898\u89e3\u7b54\u7fa4</li> <li>\u5b9a\u5236\u670d\u52a1\uff1a\u6839\u636e\u5ba2\u6237\u9700\u6c42\uff0c\u63d0\u4f9b SDK \u4f7f\u7528\u57f9\u8bad\u4e0e\u5f00\u53d1\u6307\u5bfc\uff0c\u63d0\u4f9b\u4e1a\u52a1\u80fd\u529b\u6a21\u5757\u6388\u6743\uff0c\u7ec6\u8282\u8bf7\u8054\u7cfb\u5546\u52a1</li> </ul> <p></p>"},{"location":"troubleshooting/","title":"\u6545\u969c\u6392\u9664","text":"<p>\u672c\u6587\u6863\u4ecb\u7ecd SDK \u4f7f\u7528\u8fc7\u7a0b\u4e2d\u7684\u5e38\u89c1\u95ee\u9898\u4e0e\u89e3\u51b3\u65b9\u6cd5\u3002</p>"},{"location":"troubleshooting/#_2","title":"\u63a7\u5236\u95ee\u9898","text":""},{"location":"troubleshooting/#_3","title":"\u53d1\u9001\u63a7\u5236\u6307\u4ee4\u65e0\u54cd\u5e94","text":""},{"location":"troubleshooting/#_4","title":"\u53ef\u80fd\u539f\u56e0\u4e00\uff1a\u673a\u5668\u4eba\u5904\u4e8e\u7d27\u6025\u505c\u6b62\u72b6\u6001","text":"<p>\u68c0\u67e5\u673a\u5668\u4eba\u80cc\u540e\u7684\u7ea2\u8272\u7d27\u6025\u505c\u6b62\u6309\u94ae\u662f\u5426\u5904\u4e8e\u6309\u4e0b\u72b6\u6001\uff08\u672a\u5f39\u51fa\uff09\u3002\u901a\u8fc7\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b singorix \u65e5\u5fd7\u4ee5\u786e\u8ba4\u72b6\u6001\uff1a</p> <pre><code>tail -f /userdata/log/SingoriX/info/singorix_wbcs_main.INFO\n</code></pre> <p></p>"},{"location":"troubleshooting/#_5","title":"\u53ef\u80fd\u539f\u56e0\u4e8c\uff1a\u63a7\u5236\u670d\u52a1\u672a\u542f\u52a8","text":"<p>\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u68c0\u67e5 singorix \u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\uff1a</p> <pre><code>ps -ef | grep singorix | grep -v grep\n</code></pre> <p></p>"},{"location":"troubleshooting/#_6","title":"\u53ef\u80fd\u539f\u56e0\u4e09\uff1a\u5e95\u76d8\u670d\u52a1\u5f02\u5e38","text":"<p>\u5e95\u76d8\u670d\u52a1\u672a\u542f\u52a8\u6216\u8fd0\u884c\u5f02\u5e38\u3002\u53ef\u901a\u8fc7\u4ee5\u4e0b\u547d\u4ee4\u68c0\u67e5\u5e95\u76d8\u670d\u52a1\u8fd0\u884c\u72b6\u6001\uff1a</p> <pre><code>ps -ef | grep chassis\n</code></pre> <p>\u540c\u65f6\u67e5\u770b singorix \u65e5\u5fd7\u4ee5\u83b7\u53d6\u8be6\u7ec6\u9519\u8bef\u4fe1\u606f\uff1a</p> <pre><code>tail -f /userdata/log/SingoriX/info/singorix_wbcs_main.INFO\n</code></pre> <p></p>"},{"location":"troubleshooting/#_7","title":"\u673a\u5668\u4eba\u5173\u8282\u65e0\u6cd5\u8fd0\u52a8","text":"<p>\u672c\u95ee\u9898\u9002\u7528\u4e8e\u5934\u90e8\u3001\u817f\u90e8\u6216\u624b\u81c2\u7684\u67d0\u4e2a\u5173\u8282\u65e0\u54cd\u5e94\u7684\u60c5\u51b5\u3002</p>"},{"location":"troubleshooting/#_8","title":"\u53ef\u80fd\u539f\u56e0\u4e00\uff1a\u5173\u8282\u8d85\u51fa\u8fd0\u52a8\u8303\u56f4\u9650\u5236","text":"<p>\u5173\u8282\u4f4d\u7f6e\u53ef\u80fd\u5df2\u8fbe\u5230\u6216\u8d85\u51fa\u5176\u673a\u68b0\u9650\u4f4d\u3002\u6b64\u95ee\u9898\u5728\u624b\u81c2\u5173\u8282\u4e0a\u8f83\u4e3a\u5e38\u89c1\uff0c\u53ef\u901a\u8fc7\u76ee\u89c6\u89c2\u5bdf\u5230\u5173\u8282\u59ff\u6001\u5f02\u5e38\uff0c\u540c\u65f6 singorix \u4f1a\u8f93\u51fa\u76f8\u5e94\u62a5\u9519\u4fe1\u606f\u3002\u67e5\u770b\u65e5\u5fd7\uff1a</p> <pre><code>tail -f /userdata/log/SingoriX/info/singorix_wbcs_main.INFO\n</code></pre> <p></p>"},{"location":"troubleshooting/#_9","title":"\u53ef\u80fd\u539f\u56e0\u4e8c\uff1a\u5173\u8282\u521d\u59cb\u5316\u5931\u8d25","text":"<p>\u673a\u5668\u4eba\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5173\u8282\u672a\u6210\u529f\u91ca\u653e\u5236\u52a8\u5668\uff08\u65e0\u62b1\u95f8\u91ca\u653e\u58f0\uff09\u3002singorix \u4f1a\u8f93\u51fa\u521d\u59cb\u5316\u5931\u8d25\u7684\u9519\u8bef\u4fe1\u606f\uff1a</p> <pre><code>tail -f /userdata/log/SingoriX/info/singorix_wbcs_main.INFO\n</code></pre> <p>\u4ee5\u4e0b\u622a\u56fe\u4e3a\u5934\u90e8\u5173\u8282\u521d\u59cb\u5316\u5931\u8d25\u7684\u793a\u4f8b\uff1a</p> <p></p>"},{"location":"troubleshooting/#mcu","title":"\u53ef\u80fd\u539f\u56e0\u4e09\uff1aMCU \u6545\u969c","text":"<p>\u5fae\u63a7\u5236\u5355\u5143\uff08MCU\uff09\u53ef\u80fd\u51fa\u73b0\u9519\u8bef\u6216\u505c\u6b62\u54cd\u5e94\u3002\u68c0\u67e5 <code>/userdata/log/mp_core/</code> \u548c <code>/userdata/log/secure_core</code> \u76ee\u5f55\u4e0b\u7684\u6700\u65b0\u65e5\u5fd7\u6587\u4ef6\uff0c\u786e\u8ba4\u65e5\u5fd7\u662f\u5426\u6301\u7eed\u66f4\u65b0\u4e14\u65e0\u9519\u8bef\u4fe1\u606f\u8f93\u51fa\u3002</p> <p>\u6ce8\u610f\uff1a\u6682\u65e0\u95ee\u9898\u622a\u56fe</p>"},{"location":"troubleshooting/#_10","title":"\u673a\u5668\u4eba\u5e95\u76d8\u65e0\u6cd5\u79fb\u52a8","text":""},{"location":"troubleshooting/#_11","title":"\u53ef\u80fd\u539f\u56e0\u4e00\uff1a\u5e95\u76d8\u670d\u52a1\u672a\u542f\u52a8","text":"<p>\u68c0\u67e5\u5e95\u76d8\u63a7\u5236\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\uff1a</p> <pre><code>ps -ef | grep galbot_chassis_service | grep -v grep\n</code></pre> <p></p>"},{"location":"troubleshooting/#_12","title":"\u53ef\u80fd\u539f\u56e0\u4e8c\uff1a\u7535\u6c60\u7535\u91cf\u8fc7\u4f4e","text":"<p>\u5f53\u673a\u5668\u4eba\u7535\u6c60\u7535\u91cf\u4f4e\u4e8e 25% \u65f6\uff0c\u5e95\u76d8\u5c06\u505c\u6b62\u8fd0\u884c\u4ee5\u4fdd\u62a4\u7535\u6c60\u3002\u901a\u8fc7\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b\u5f53\u524d\u7535\u91cf\uff08SOC\uff09\uff1a</p> <pre><code>tail -f /userdata/log/galbot_chassis_service/galbot_chassis_service.INFO | grep soc\n</code></pre> <p></p>"},{"location":"troubleshooting/#_13","title":"\u672b\u7aef\u6267\u884c\u5668\u63a7\u5236\u5931\u8d25","text":"<p>\u672c\u95ee\u9898\u9002\u7528\u4e8e\u5939\u722a\u6216\u5438\u76d8\u65e0\u6cd5\u6b63\u5e38\u63a7\u5236\u7684\u60c5\u51b5\u3002</p>"},{"location":"troubleshooting/#_14","title":"\u53ef\u80fd\u539f\u56e0\u4e00\uff1a\u672b\u7aef\u6267\u884c\u5668\u786c\u4ef6\u6545\u969c","text":"<p>\u6309\u4e0b\u7d27\u6025\u505c\u6b62\u6309\u94ae\u540e\u518d\u91ca\u653e\uff0c\u89c2\u5bdf\u672b\u7aef\u6267\u884c\u5668\uff08\u5939\u722a\u6216\u5438\u76d8\uff09\u662f\u5426\u6709\u54cd\u5e94\u52a8\u4f5c\u3002\u82e5\u65e0\u4efb\u4f55\u52a8\u4f5c\uff0c\u53ef\u80fd\u5b58\u5728\u786c\u4ef6\u672c\u4f53\u6545\u969c\u3002</p>"},{"location":"troubleshooting/#_15","title":"\u53ef\u80fd\u539f\u56e0\u4e8c\uff1a\u672b\u7aef\u914d\u7f6e\u4e0d\u5339\u914d","text":"<p>singorix \u7684\u9ed8\u8ba4\u914d\u7f6e\u4e3a\u5de6\u624b\u5939\u722a\u3001\u53f3\u624b\u5438\u76d8\u3002\u68c0\u67e5\u673a\u5668\u4eba\u5f53\u524d\u5b89\u88c5\u7684\u672b\u7aef\u6267\u884c\u5668\u7c7b\u578b\u662f\u5426\u4e0e\u914d\u7f6e\u4e00\u81f4\u3002\u82e5\u4e0d\u4e00\u81f4\uff0c\u9700\u4fee\u6539\u4ee5\u4e0b\u914d\u7f6e\u6587\u4ef6\uff1a</p> <pre><code>/data/config/SingoriX/galbot_one_golf/real/robot_config.toml\n</code></pre> <p></p>"},{"location":"troubleshooting/#_16","title":"\u8fd0\u52a8\u89c4\u5212\u95ee\u9898","text":""},{"location":"troubleshooting/#_17","title":"\u9006\u8fd0\u52a8\u5b66\u6c42\u89e3\u5931\u8d25","text":""},{"location":"tutorials/","title":"\u5165\u95e8\u6559\u7a0b","text":"<p>\u63a5\u4e0b\u6765\u5c06\u4f1a\u901a\u8fc7\u51e0\u4e2a\u7b80\u5355\u793a\u4f8b\u7684\u4ecb\u7ecd\uff0c\u6765\u5feb\u901f\u4e86\u89e3Galbot\u673a\u5668\u4eba\u7684\u57fa\u7840\u5f00\u53d1\u5e94\u7528\u3002\u8fd0\u884c\u63a5\u4e0b\u6765\u7684\u6240\u6709\u793a\u4f8b\uff0c\u60a8\u9700\u8981\u9996\u5148\u4e0b\u8f7d\u5b89\u88c5Galbot SDK\uff0c\u5e76\u53c2\u8003\u5b89\u88c5\u4e0e\u914d\u7f6e\u8bf4\u660e\u8fdb\u884c\u914d\u7f6e\u3002</p>"},{"location":"tutorials/#example1","title":"Example1. \u673a\u5668\u4eba\u7684\u57fa\u7840\u63a7\u5236","text":"<p>\u672c\u793a\u4f8b\u5c55\u793a\u4e86GALBOT\u673a\u5668\u4eba\u7684\u57fa\u7840\u63a7\u5236\uff0c\u6267\u884c\u672c\u7a0b\u5e8f\u540e\uff0c\u673a\u5668\u4eba\u7684\u4e24\u81c2\u5c06\u7f13\u6162\u4e3e\u8d77\u5230\u5934\u9876\uff0c\u5f62\u6210\u4e00\u4e2a\u7c7b\u4f3c\u6bd4\u5fc3\u7684\u59ff\u52bf\u3002\u901a\u8fc7\u521d\u59cb\u5316\u673a\u5668\u4eba\u5b9e\u4f8b\u3001\u68c0\u67e5\u5b89\u5168\u72b6\u6001\u540e\uff0c\u8ba9\u673a\u5668\u4eba\u7684\u5de6\u53f3\u624b\u81c2\u6267\u884c\u9884\u8bbe\u7684\u6bd4\u5fc3\u52a8\u4f5c\u5e8f\u5217\uff0c\u5148\u5c06\u624b\u81c2\u79fb\u52a8\u5230\u6bd4\u5fc3\u59ff\u52bf\u4fdd\u6301\u4e00\u6bb5\u65f6\u95f4\uff0c\u7136\u540e\u6062\u590d\u5230\u539f\u59cb\u59ff\u6001\uff0c\u6574\u4e2a\u8fc7\u7a0b\u5305\u542b\u4e86\u5173\u8282\u4f4d\u7f6e\u83b7\u53d6\u3001\u5173\u8282\u89d2\u5ea6\u8bbe\u7f6e\u3001\u963b\u585e\u7b49\u5f85\u4ee5\u53ca\u5f02\u5e38\u5904\u7406\u7b49\u57fa\u672c\u63a7\u5236\u6d41\u7a0b\u3002</p> <p>\u6ce8\u610f\uff1a1. \u4fdd\u6301\u6025\u505c\u6309\u94ae\u4e3a\u6253\u5f00\u72b6\u6001\uff1b2. \u786e\u4fdd\u673a\u5668\u4eba\u9644\u8fd12\u7c73\u8303\u56f4\u65e0\u906e\u6321\uff0c\u907f\u514d\u624b\u81c2\u89e6\u78b0\u969c\u788d\u7269\u51fa\u73b0\u5371\u9669\u3002</p> examples/python/tutorials/example1_galbot_control_started.py<pre><code>\"\"\"\nNote: When running this example, please ensure the robot's `emergency stop button` is released;\n\"\"\"\nimport time\n\ntry:\n    from galbot_sdk.g1  import GalbotRobot, ControlStatus\nexcept ImportError:\n    print(\"Failed to import galbot_sdk, please install it first or check if it is in PYTHONPATH\")\n    exit(1)\n\n\ndef demo_heart_pose(robot: GalbotRobot,\n                    joint_group_names: list,\n                    position_seq: list,\n                    is_blocking: bool,\n                    max_speed: float,\n                    timeout_s: float,\n                    retry_count: int = 3\n                    ):\n    \"\"\"\n    Robot heart gesture demonstration function\n\n    Parameters:\n        robot (GalbotRobot): GalbotRobot instance\n        joint_group_names (list): List of joint group names to control\n        position_seq (list): List of joint group angle sequences to set\n        is_blocking (bool): Whether to set angles in blocking mode\n        max_speed (float): Maximum speed\n        timeout_s (float): Timeout time (seconds)\n        retry_count (int, optional): Number of retries, default is 3\n\n    Returns:\n        None\n    \"\"\"\n\n    # Get current joint group angles for subsequent restoration\n    original_pos = robot.get_joint_positions(joint_group_names, [])\n    print(f\"Current angles of joint group {joint_group_names}: {original_pos}\")\n\n    # Start heart gesture\n    pos_idx = 0\n    print(\"Starting heart gesture...\")\n    while True:\n        time.sleep(1)\n        pos = position_seq[pos_idx]\n        control_status = robot.set_joint_positions(\n            pos, joint_group_names, [], is_blocking, max_speed, timeout_s\n        )\n\n        # If setting fails, retry 3 times\n        retry_cnt = retry_count\n        while control_status != ControlStatus.SUCCESS and retry_cnt &gt; 0:\n            print(f\"Setting angles for joint group {joint_group_names} failed, retrying {retry_cnt}...\")\n            retry_cnt = retry_cnt - 1\n            time.sleep(1)\n            control_status = robot.set_joint_positions(\n                pos, joint_group_names, [], is_blocking, max_speed, timeout_s\n            )\n        # If successful, switch to next pose sequence\n        if control_status == ControlStatus.SUCCESS:\n            print(f\"Setting angles for joint group {joint_group_names} successful\")\n            pos_idx = pos_idx + 1\n        # If failed, break the loop\n        else:\n            print(f\"Setting angles for joint group {joint_group_names} failed\")\n            break\n\n        # If all pose sequences are completed, break the loop\n        if pos_idx &gt; len(position_seq) - 1:\n            break\n\n    # Get current joint group angles\n    print(\"Showing heart gesture for 15 seconds, then restoring original pose...\")\n    time.sleep(5)\n\n    # Restore original pose joint group angles\n    control_status = robot.set_joint_positions(\n        original_pos, joint_group_names, [], is_blocking, max_speed, timeout_s\n    )\n    # If setting fails, retry 5 times\n    retry_cnt = retry_count\n    while control_status != ControlStatus.SUCCESS and retry_cnt &gt; 0:\n        print(f\"Setting angles for joint group {joint_group_names} failed, retrying {retry_cnt}...\")\n        retry_cnt = retry_cnt - 1\n        time.sleep(2)\n        control_status = robot.set_joint_positions(\n            original_pos, joint_group_names, [], is_blocking, max_speed, timeout_s\n        )\n    # If successful, restore original pose\n    if control_status == ControlStatus.SUCCESS:\n        print(f\"Restoring angles for joint group {joint_group_names} successful\")\n    else:\n        print(f\"Restoring angles for joint group {joint_group_names} failed\")\n\ndef check_robot_safety():\n    \"\"\"Check if the robot is safe\"\"\"\n    # Prompt for precautions\n    print(\"\u26a0\ufe0f  Note: 1. Please ensure the robot's emergency stop button is released; 2. Please ensure there are no obstacles in front, back, left, and right of the robot to avoid unexpected situations.\")\n    while True:\n        key = input(\"Please confirm that the robot's emergency stop button is released and there are no obstacles. Continue? (y/n)...\")\n        if key == 'y':\n            print(\"User confirmed, continuing execution...\")\n            break\n        elif key == 'n':\n            print(\"User not confirmed, program exiting...\")\n            exit(1)\n        else:\n            print(\"Input error, please enter 'y' or 'n'\")\n\ndef main():\n    check_robot_safety()\n\n    try:\n        # Get robot instance\n        robot = GalbotRobot.get_instance()\n\n        # Initialize robot\n        state = robot.init()\n        if not state:\n            print(f\"Initialization failed\")\n            exit(1)\n        else:\n            print(f\"Initialization successful\")\n            print(f\"Is robot running: {robot.is_running()}\")\n\n        # Wait for data preparation\n        time.sleep(3)\n\n        # Get list of joint names\n        joint_names = robot.get_joint_names()\n        if len(joint_names) &gt; 0:\n            print(f\"List of joint names: {joint_names}\")\n        else:\n            print(f\"Failed to get list of joint names\")\n\n        # Get joint positions using joint group names, empty returns all joints by default\n        joint_group_names = [\"left_arm\", \"right_arm\"]\n        # Left and right arm heart gesture sequence\n        position_seq = [\n            [1.53, 0.36, -2.54, -1.80, 0.12, -0.82, 0.09, # left_arm\n             -1.53, -0.36, 2.54, 1.80, -0.12, 0.82, -0.09] # right_arm\n        ]\n        # Whether to block and wait for joints to reach position\n        is_blocking = True\n        # Limit maximum joint speed to 0.1rad/s\n        max_speed = 0.1\n        # Maximum blocking wait time\n        timeout_s = 20\n\n        # Perform heartbeat gesture\n        demo_heart_pose(robot, joint_group_names, position_seq,\n                        is_blocking, max_speed, timeout_s)\n\n    except Exception as e:\n        print(f\"An exception occurred: {e}\")\n    finally:\n        # Actively send SIGINT shutdown signal\n        robot.request_shutdown()\n        # Wait to enter shutdown state\n        robot.wait_for_shutdown()\n        # Release SDK resources\n        robot.destroy()\n        print('Resource release successful')\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/#example2","title":"Example2. \u624b\u81c2\u64cd\u63a7","text":"<p>\u672c\u793a\u4f8b\u5c55\u793a\u4e86GALBOT\u673a\u5668\u4eba\u7684\u624b\u81c2\u64cd\u63a7\uff0c\u6267\u884c\u672c\u7a0b\u5e8f\u540e\uff0c\u673a\u5668\u4eba\u5de6\u81c2\u5c06\u7f13\u7f13\u62ac\u8d77\u4e00\u5b9a\u9ad8\u5ea6\uff0c\u7136\u540e\u5728\u7f13\u7f13\u6062\u590d\u539f\u59cb\u59ff\u6001\u3002\u4e3b\u8981\u5b9e\u73b0\u4e86\u6b63\u9006\u8fd0\u52a8\u5b66\uff08IK/FK\uff09\u6c42\u89e3\u3001\u672b\u7aef\u6267\u884c\u5668\u4f4d\u59ff\u63a7\u5236\u4ee5\u53ca\u5173\u8282\u89d2\u5ea6\u8bbe\u7f6e\u7b49\u529f\u80fd\uff0c\u901a\u8fc7\u83b7\u53d6\u5f53\u524d\u5de6\u81c2\u672b\u7aef\u4f4d\u59ff\u3001\u4f7f\u7528\u9006\u8fd0\u52a8\u5b66\u8ba1\u7b97\u76ee\u6807\u4f4d\u59ff\u5bf9\u5e94\u7684\u5173\u8282\u89d2\u5ea6\u3001\u8bbe\u7f6e\u5173\u8282\u89d2\u5ea6\u4f7f\u673a\u5668\u4eba\u79fb\u52a8\u5230\u76ee\u6807\u4f4d\u7f6e\uff0c\u5e76\u9a8c\u8bc1\u6700\u7ec8\u4f4d\u59ff\u4e0e\u76ee\u6807\u4f4d\u59ff\u7684\u4e00\u81f4\u6027\uff0c\u6700\u540e\u5c06\u673a\u5668\u4eba\u6062\u590d\u5230\u539f\u59cb\u4f4d\u59ff\u3002</p> <p>\u6ce8\u610f\uff1a1. \u4fdd\u6301\u6025\u505c\u6309\u94ae\u4e3a\u6253\u5f00\u72b6\u6001\uff1b2. \u786e\u4fdd\u673a\u5668\u4eba\u9644\u8fd12\u7c73\u8303\u56f4\u65e0\u906e\u6321\uff0c\u907f\u514d\u624b\u81c2\u89e6\u78b0\u969c\u788d\u7269\u51fa\u73b0\u5371\u9669\u3002</p> examples/python/tutorials/example2_arm_manipulation.py<pre><code>\"\"\"\nNote: When running this example, please ensure the robot's motion control service `/data/galbot/bin/service_motion_plan`,\n    robot state publishing service `/data/galbot/bin/robot_state_publish`,\n    and hand-eye calibration publishing service `/data/galbot/bin/eyehand_calib_publish` are loaded;\n\"\"\"\ntry:\n    import galbot_sdk.g1 as gm\n    from galbot_sdk.g1 import GalbotMotion, GalbotRobot, ControlStatus\nexcept ImportError:\n    print(\"Failed to import galbot_sdk, please install it first or check if it is in PYTHONPATH\")\n    exit(1)\n\nimport os\n\ntry:\n    import numpy as np\nexcept ImportError:\n    os.system(\"pip install numpy\")\n    import numpy as np\n\nimport time\nfrom typing import Sequence, Dict\n\ndef printStatus(status):\n    if(status == gm.MotionStatus.SUCCESS):\n        print(\"Execution result: SUCCESS, Execution successful\")\n    elif(status == gm.MotionStatus.TIMEOUT):\n        print(\"Execution result: TIMEOUT, Execution timeout\")\n    elif(status == gm.MotionStatus.FAULT):\n        print(\"Execution result: FAULT, Fault occurred, unable to continue execution\")\n    elif(status == gm.MotionStatus.INVALID_INPUT):\n        print(\"Execution result: INVALID_INPUT, Input parameters do not meet requirements\")\n    elif(status == gm.MotionStatus.INIT_FAILED):\n        print(\"Execution result: INIT_FAILED, Internal communication component creation failed\")\n    elif(status == gm.MotionStatus.IN_PROGRESS):\n        print(\"Execution result: IN_PROGRESS, Moving but not in position\")\n    elif(status == gm.MotionStatus.STOPPED_UNREACHED):\n        print(\"Execution result: STOPPED_UNREACHED, Stopped but did not reach target\")\n    elif(status == gm.MotionStatus.DATA_FETCH_FAILED):\n        print(\"Execution result: DATA_FETCH_FAILED, Data acquisition failed\")\n    elif(status == gm.MotionStatus.PUBLISH_FAIL):\n        print(\"Execution result: PUBLISH_FAIL, Data sending failed\")\n    elif(status == gm.MotionStatus.COMM_DISCONNECTED):\n        print(\"Execution result: COMM_DISCONNECTED, Connection failed\")\n\ndef quat_normalize(q: np.ndarray) -&gt; np.ndarray:\n    q = np.array(q, dtype=np.float64)\n    return q / np.linalg.norm(q)\n\ndef quat_conjugate(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the conjugate of a quaternion\n\n    Parameters:\n        q (np.ndarray): Input quaternion [x, y, z, w]\n\n    Returns:\n        np.ndarray: Conjugate of the quaternion [x, y, z, w]\n    \"\"\"\n    qx, qy, qz, qw = q\n    return np.array([-qx, -qy, -qz, qw])\n\ndef quat_multiply(q1: np.ndarray, q2: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the product of two quaternions\n\n    Parameters:\n        q1 (np.ndarray): First quaternion [x, y, z, w]\n        q2 (np.ndarray): Second quaternion [x, y, z, w]\n\n    Returns:\n        np.ndarray: Product of the two quaternions [x, y, z, w]\n    \"\"\"\n    x1, y1, z1, w1 = q1\n    x2, y2, z2, w2 = q2\n    return np.array([\n        w1*x2 + x1*w2 + y1*z2 - z1*y2,\n        w1*y2 - x1*z2 + y1*w2 + z1*x2,\n        w1*z2 + x1*y2 - y1*x2 + z1*w2,\n        w1*w2 - x1*x2 - y1*y2 - z1*z2\n    ])\n\ndef orientation_error_angle(A: np.ndarray, B: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculate the rotation angle error between two quaternions (radians)\n\n    Parameters:\n        A (np.ndarray): First quaternion [x, y, z, w]\n        B (np.ndarray): Second quaternion [x, y, z, w]\n\n    Returns:\n        float: Rotation angle error (radians)\n    \"\"\"\n    qA = quat_normalize(A[3:7])\n    qB = quat_normalize(B[3:7])\n\n    q_err = quat_multiply(qB, quat_conjugate(qA))\n    q_err = quat_normalize(q_err)\n\n    # Numerical stability\n    qw = np.clip(q_err[3], -1.0, 1.0)\n\n    angle = 2 * np.arccos(qw)\n    return angle  # Unit: radians\n\n\ndef calculate_error(pose1: Sequence[float], pose2: Sequence[float]) -&gt; Dict[str, float]:\n    \"\"\"\n    Calculate position error and rotation error between two poses (radians)\n\n    Parameters:\n        pose1 (Sequence[float]): First pose [x, y, z, qx, qy, qz, qw]\n        pose2 (Sequence[float]): Second pose [x, y, z, qx, qy, qz, qw]\n\n    Returns:\n        dict: Dictionary containing position error (meters) and rotation error (radians)\n    \"\"\"\n    A, B = np.array(pose1), np.array(pose2)\n    pos_err = np.linalg.norm(A[:3] - B[:3])\n    rot_err = orientation_error_angle(A, B)\n\n    return {\n        \"position_error_norm\": pos_err,\n        \"orientation_error_rad\": rot_err,\n        \"orientation_error_deg\": np.degrees(rot_err)\n    }\n\ndef check_robot_safety():\n    \"\"\"Check if the robot is safe\"\"\"\n    # Prompt for precautions\n    print(\"\u26a0\ufe0f  Note: 1. Please ensure the robot's emergency stop button is released; 2. Please ensure there are no obstacles in front, back, left, and right of the robot to avoid unexpected situations.\")\n    while True:\n        key = input(\"Please confirm that the robot's emergency stop button is released and there are no obstacles. Continue? (y/n)...\")\n        if key == 'y':\n            print(\"User confirmed, continuing execution...\")\n            break\n        elif key == 'n':\n            print(\"User not confirmed, program exiting...\")\n            exit(1)\n        else:\n            print(\"Input error, please enter 'y' or 'n'\")\n\ndef main():\n    check_robot_safety()\n    try:\n        # Get GalbotMotion singleton and initialize\n        motion = GalbotMotion.get_instance()\n        robot = GalbotRobot.get_instance()\n\n        if motion.init():\n            print(\"GalbotMotion initialization successful\")\n        else:\n            print(\"GalbotMotion initialization failed\")\n        if robot.init():\n            print(\"GalbotRobot initialization successful\")\n        else:\n            print(\"GalbotRobot initialization failed\")\n\n        # Program starts immediately, wait for data readiness time\n        time.sleep(1)\n\n        # Define target pose\n        chain_pose_baselink = {\n            \"leg\": [0.0596,-0.0000,1.0327,0.5000,0.5003,0.4997,0.5000],\n            \"head\": [0.0599,0.0002,1.4098,-0.7072,0.0037,0.0037,0.7069],\n            \"left_arm\": [0.1267,0.2342,0.7356,0.0220,0.0127,0.0343,0.9991],\n            \"right_arm\": [0.1267,-0.2345,0.7358,-0.0225,0.0126,-0.0343,0.9991]\n        }\n        # Define target chain name, target pose, reference pose, end link\n        target_frame = \"EndEffector\"\n        reference_frame = \"base_link\"\n        target_chain = \"left_arm\"\n        end_link = \"left_arm_end_effector_mount_link\"\n\n        # 1. Get current left_arm end-effector pose\n        try:\n            status, original_pose = motion.get_end_effector_pose_on_chain(\n                chain_name=target_chain,\n                frame_id=target_frame,\n                reference_frame=reference_frame\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Failed to get end-effector pose\"\n            print(f\"\u2705 Current {target_chain} end-effector pose: {original_pose}\")\n            time.sleep(0.8)\n        except Exception as e:\n            print(f\"\u274c Exception getting end-effector pose by chain name: {e}\")\n\n        # 2. Solve joint angles based on target pose IK and verify the solution\n        # 2.1 Solve joint angles joint_angles_ik for target pose through IK\n        try:\n            status, joint_angles_ik = motion.inverse_kinematics(\n                target_pose=chain_pose_baselink[target_chain],\n                chain_names=[target_chain],\n                target_frame=target_frame,\n                reference_frame=reference_frame,\n                enable_collision_check=False # Disable collision detection\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"IK solving failed\"\n            print(f\"\u2705 Target {target_chain} IK solving successful joint_angles_ik: {joint_angles_ik}\")\n            time.sleep(1)\n        except Exception as e:\n            print(f\"\u274c IK solving exception: {e}\")\n\n        # 2.2 Set end-effector pose to target pose tgt_pose_ik by setting joint group angles joint_angles_ik\n        try:\n            status = robot.set_joint_positions(\n                joint_angles_ik[target_chain], \n                [target_chain], \n                [], \n                True,\n                0.1,\n                20.0,\n            )\n            assert status == ControlStatus.SUCCESS, \"Setting joint group angles failed\"\n            print(f\"\u2705 Setting {target_chain} joint group angles successful.\")\n            time.sleep(1)\n        except Exception as e:\n            print(f\"\u274c Setting {target_chain} joint group angles exception: {e}\")\n\n        # 2.3 Verify whether the set joint group angles are consistent with the solved angles\n        try:\n            status, tgt_pose_ik = motion.get_end_effector_pose_on_chain(\n                chain_name=target_chain,\n                frame_id=target_frame,\n                reference_frame=reference_frame\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Failed to get end-effector pose\"\n            print(f\"\u2705 Getting {target_chain} end-effector pose successful: {tgt_pose_ik}\")\n            time.sleep(1)\n\n            error = calculate_error(tgt_pose_ik, chain_pose_baselink[target_chain])\n            print(f\"End-effector pose error: {error}\")\n        except Exception as e:\n            print(f\"\u274c Getting {target_chain} end-effector pose exception: {e}\")\n\n        # 2.4 Verify whether the end-effector pose tgt_pose_fk corresponding to joint group angles joint_angles_ik solved by FK is consistent with target pose tgt_pose_ik\n        try:\n            status, tgt_pose_fk = motion.forward_kinematics(\n                target_frame=end_link,\n                reference_frame=reference_frame,\n                joint_state=joint_angles_ik,\n                params=gm.Parameter()\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"FK solving failed\"\n            print(f\"\u2705 Target {target_chain} FK solving successful: {tgt_pose_fk}\")\n            time.sleep(1)\n\n            error = calculate_error(tgt_pose_fk, chain_pose_baselink[target_chain])\n            print(f\"FK solving error: {error}\")\n        except Exception as e:\n            print(f\"\u274c FK solving exception: {e}\")\n\n        time.sleep(3)\n        print()\n\n        # 3. Restore to original pose by setting end-effector pose\n        # 3.1 Set end-effector pose to restore to original pose\n        try:\n            status = motion.set_end_effector_pose(\n                target_pose=original_pose,\n                end_effector_frame=target_chain,\n                reference_frame=reference_frame,\n                enable_collision_check=False,\n                is_blocking=True,\n                timeout=5.0,\n                params=gm.Parameter()\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Setting end-effector pose failed\"\n            print(f\"\u2705 Setting end-effector pose successful: status={status}\")\n            time.sleep(1)\n        except Exception as e:\n            print(f\"\u274c Setting {target_chain} end-effector pose exception: {e}\")\n\n        # 3.2 Get end-effector pose and verify whether it has been restored to original pose\n        try:\n            status, original_pose_rec = motion.get_end_effector_pose_on_chain(\n                chain_name=target_chain,\n                frame_id=target_frame,\n                reference_frame=reference_frame\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Failed to get end-effector pose\"\n            print(f\"\u2705 Getting {target_chain} end-effector pose successful: {original_pose_rec}\")\n            time.sleep(0.8)\n\n            error = calculate_error(original_pose_rec, original_pose)\n            print(f\"Restore end-effector pose error: {error}\")\n        except Exception as e:\n            print(f\"\u274c Setting end-effector pose exception: {e}\")\n\n    except Exception as e:\n        print(f\"\u274c Main program exception: {e}\")\n    finally:\n        robot.request_shutdown()\n        robot.wait_for_shutdown()\n        robot.destroy()\n\nif __name__==\"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/#example3","title":"Example3. \u673a\u5668\u4eba\u5bfc\u822a","text":"<p>\u672c\u793a\u4f8b\u5c55\u793a\u4e86GALBOT\u673a\u5668\u4eba\u7684\u5bfc\u822a\u529f\u80fd\uff0c\u6267\u884c\u672c\u7a0b\u5e8f\u540e\uff0c\u673a\u5668\u4eba\u5728\u5176\u5de6\u524d\u65b9\u7ed5\u884c\u4e00\u4e2a\u6b63\u65b9\u5f62\u8def\u5f84\u3002\u901a\u8fc7\u521d\u59cb\u5316\u5bfc\u822a\u548c\u673a\u5668\u4eba\u5b9e\u4f8b\u3001\u68c0\u67e5\u5b89\u5168\u72b6\u6001\u540e\uff0c\u8ba9\u673a\u5668\u4eba\u6267\u884c\u6b63\u65b9\u5f62\u8f68\u8ff9\u8fd0\u52a8\uff0c\u6bcf\u6b21\u5411\u524d\u79fb\u52a80.5\u7c73\u5e76\u5de6\u8f6c90\u5ea6\uff0c\u91cd\u590d4\u6b21\u5f62\u6210\u4e00\u4e2a\u6b63\u65b9\u5f62\u8def\u5f84\uff0c\u5e76\u5728\u5b8c\u6210\u540e\u8fd4\u56de\u8d77\u59cb\u4f4d\u7f6e\uff0c\u6574\u4e2a\u8fc7\u7a0b\u5305\u542b\u4e86\u4f4d\u59ff\u83b7\u53d6\u3001\u8def\u5f84\u53ef\u8fbe\u6027\u68c0\u67e5\u3001\u5bfc\u822a\u5230\u76ee\u6807\u70b9\u3001\u76ee\u6807\u5230\u8fbe\u68c0\u6d4b\u4ee5\u53ca\u5f02\u5e38\u5904\u7406\u7b49\u5bfc\u822a\u63a7\u5236\u529f\u80fd\u3002</p> <p>\u6ce8\u610f\uff1a1. \u4fdd\u6301\u6025\u505c\u6309\u94ae\u4e3a\u6253\u5f00\u72b6\u6001\uff1b2. \u786e\u4fdd\u673a\u5668\u4eba\u9644\u8fd12\u7c73\u8303\u56f4\u65e0\u906e\u6321\uff0c\u907f\u514d\u624b\u81c2\u89e6\u78b0\u969c\u788d\u7269\u51fa\u73b0\u5371\u9669\u3002</p> examples/python/tutorials/example3_robot_navigation.py<pre><code>\"\"\"\nNote: When running this example, please confirm that the robot's navigation function `/data/galbot/bin/service_navigation_plan` has been loaded;\n\"\"\"\ntry:\n    from galbot_sdk.g1  import GalbotNavigation, GalbotRobot\nexcept ImportError:\n    print(\"Failed to import galbot_sdk, please install it first or check if it's in PYTHONPATH\")\n    exit(1)\n\nimport os\n\ntry:\n    import numpy as np\nexcept ImportError:\n    os.system(\"pip install numpy\")\n    import numpy as np\n\ntry:\n    from scipy.spatial.transform import Rotation as R\nexcept ImportError:\n    os.system(\"pip install scipy\")\n    from scipy.spatial.transform import Rotation as R\n\nimport time\nfrom typing import Sequence, Dict\n\ndef quat_normalize(q: np.ndarray) -&gt; np.ndarray:\n    q = np.array(q, dtype=np.float64)\n    return q / np.linalg.norm(q)\n\ndef quat_conjugate(q: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the conjugate of a quaternion\n\n    Parameters:\n        q (np.ndarray): Input quaternion [x, y, z, w]\n\n    Returns:\n        np.ndarray: Conjugate of the quaternion [x, y, z, w]\n    \"\"\"\n    qx, qy, qz, qw = q\n    return np.array([-qx, -qy, -qz, qw])\n\ndef quat_multiply(q1: np.ndarray, q2: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the product of two quaternions\n\n    Parameters:\n        q1 (np.ndarray): First quaternion [x, y, z, w]\n        q2 (np.ndarray): Second quaternion [x, y, z, w]\n\n    Returns:\n        np.ndarray: Product of the two quaternions [x, y, z, w]\n    \"\"\"\n    x1, y1, z1, w1 = q1\n    x2, y2, z2, w2 = q2\n    return np.array([\n        w1*x2 + x1*w2 + y1*z2 - z1*y2,\n        w1*y2 - x1*z2 + y1*w2 + z1*x2,\n        w1*z2 + x1*y2 - y1*x2 + z1*w2,\n        w1*w2 - x1*x2 - y1*y2 - z1*z2\n    ])\n\ndef orientation_error_angle(A: np.ndarray, B: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculate the rotation angle error between two quaternions (in radians)\n\n    Parameters:\n        A (np.ndarray): First quaternion [x, y, z, w]\n        B (np.ndarray): Second quaternion [x, y, z, w]\n\n    Returns:\n        float: Rotation angle error (in radians)\n    \"\"\"\n    qA = quat_normalize(A[3:7])\n    qB = quat_normalize(B[3:7])\n\n    q_err = quat_multiply(qB, quat_conjugate(qA))\n    q_err = quat_normalize(q_err)\n\n    # Numerically stable\n    qw = np.clip(q_err[3], -1.0, 1.0)\n\n    angle = 2 * np.arccos(qw)\n    return angle  # Unit: radians\n\n\ndef calculate_error(pose1: Sequence[float], pose2: Sequence[float]) -&gt; Dict[str, float]:\n    \"\"\"\n    Calculate the position error and rotation error between two poses (in radians)\n\n    Parameters:\n        pose1 (Sequence[float]): First pose, [x, y, z, qx, qy, qz, qw]\n        pose2 (Sequence[float]): Second pose, [x, y, z, qx, qy, qz, qw]\n\n    Returns:\n        dict: Dictionary containing position error (in meters) and rotation error (in radians)\n    \"\"\"\n    A, B = np.array(pose1), np.array(pose2)\n    pos_err = np.linalg.norm(A[:3] - B[:3])\n    rot_err = orientation_error_angle(A, B)\n\n    return {\n        \"position_error_norm\": pos_err,\n        \"orientation_error_rad\": rot_err,\n        \"orientation_error_deg\": np.degrees(rot_err)\n    }\n\ndef local_pose_to_global(start_pose: Sequence[float], local_pose: Sequence[float]):\n    \"\"\"\n    Convert local pose to global pose\n\n    Parameters:\n        start_pose (Sequence[float]): Start pose, [x, y, z, qx, qy, qz, qw]\n        local_pose (Sequence[float]): Local pose, [x, y, z, qx, qy, qz, qw]\n\n    Returns:\n        Sequence[float]: Global pose, [x, y, z, qx, qy, qz, qw]\n    \"\"\"\n    start_mat = np.eye(4)\n    start_mat[:3, :3] = R.from_quat([start_pose[3], start_pose[4], start_pose[5], start_pose[6]]).as_matrix()\n    start_mat[:3, 3] = [start_pose[0], start_pose[1], start_pose[2]]\n\n    local_mat = np.eye(4)\n    local_mat[:3, :3] = R.from_quat([local_pose[3], local_pose[4], local_pose[5], local_pose[6]]).as_matrix()\n    local_mat[:3, 3] = [local_pose[0], local_pose[1], local_pose[2]]\n\n    global_mat = start_mat @ local_mat\n\n    return global_mat[:3, 3].tolist() + R.from_matrix(global_mat[:3, :3]).as_quat().tolist()\n\ndef demo_square_move(robot: GalbotRobot, nav: GalbotNavigation):\n    \"\"\"\n    Demonstrate robot moving in a square pattern in navigation environment\n\n    Parameters:\n        robot (GalbotRobot): Robot instance\n        nav (GalbotNavigation): Navigation instance\n    \"\"\"\n    try:\n        start_pose = nav.get_current_pose()\n    except Exception as e:\n        print(f\"Failed to get current pose: {e}\")\n        return\n\n    # Move forward 0.5m, turn left 90 degrees\n    local_pose = [0.5, 0.0, 0.0, 0.0, 0.0, 0.707, 0.707] \n\n    try:\n        # Move forward 0.5m each time, turn left 90 degrees, repeat 4 times to form a square\n        for _ in range(4):\n            # Calculate target pose\n            cur_pose = nav.get_current_pose()\n            goal_pose = local_pose_to_global(cur_pose, local_pose)\n\n            # Check if path is reachable\n            if nav.check_path_reachability(goal_pose, cur_pose):\n                # Navigate to target pose\n                retry_cnt = 3\n                while True:\n                    status = nav.navigate_to_goal(goal_pose, enable_collision_check=True, is_blocking=True, timeout=30)\n                    time.sleep(0.5)\n                    retry_cnt -= 1\n                    if nav.check_goal_arrival() or retry_cnt &lt; 0:\n                        break\n                    else:\n                        print(f\"Navigation failed, retrying...{retry_cnt}\")\n                print(\"navigate_to_goal return status:\", status)\n                print(\"Has arrived:\", nav.check_goal_arrival())\n            else:\n                print(\"Path unreachable or unsafe\")\n\n        cur_pose = nav.get_current_pose()\n        print(f\"Current pose: {cur_pose}, Error from start pose: {calculate_error(cur_pose, start_pose)}\")\n    except Exception as e:\n        print(f\"Exception occurred during navigation: {e}\")\n\ndef move_to_original(robot: GalbotRobot, nav: GalbotNavigation):\n    \"\"\"\n    Demonstrate robot returning to start pose in navigation environment\n\n    Parameters:\n        robot (GalbotRobot): Robot instance\n        nav (GalbotNavigation): Navigation instance\n    \"\"\"\n    cur_pose = nav.get_current_pose()\n    goal_pose = [0, 0, 0, 0, 0, 0, 1]\n\n    try:\n        if nav.check_path_reachability(goal_pose, cur_pose):\n            retry_cnt = 3\n            while True:\n                status = nav.navigate_to_goal(goal_pose, enable_collision_check=True, is_blocking=True, timeout=30)\n                time.sleep(0.5)\n                retry_cnt -= 1\n                if nav.check_goal_arrival() or retry_cnt &lt; 0:\n                    break\n                else:\n                    print(f\"Navigation failed, retrying...{retry_cnt}\")\n            print(\"navigate_to_goal return status:\", status)\n            print(\"Has arrived:\", nav.check_goal_arrival())\n        else:\n            print(\"Path unreachable or unsafe\")\n    except Exception as e:\n        print(f\"Exception occurred during navigation: {e}\")\n\ndef check_robot_safety():\n    \"\"\"Check if robot is safe\"\"\"\n    # Prompt important notes\n    print(\"\u26a0\ufe0f  Note: 1. Please ensure the emergency stop button of the robot is released; 2. Please ensure there are no obstructions around the robot to avoid unexpected situations; 3. Please ensure the area around the robot is clear of obstacles.\")\n    while True:\n        key = input(\"Please confirm that the robot's emergency stop button is released and there are no obstructions, continue? (y/n)...\")\n        if key == 'y':\n            print(\"User confirmed, continuing...\")\n            break\n        elif key == 'n':\n            print(\"User did not confirm, exiting program...\")\n            exit(1)\n        else:\n            print(\"Invalid input, please enter 'y' or 'n'\")\n\ndef main():\n    check_robot_safety()\n    try:\n        # Get robot instance\n        robot = GalbotRobot.get_instance()\n        # Get navigation instance\n        nav = GalbotNavigation.get_instance()\n\n        # Initialize robot\n        if robot.init():\n            print(\"Robot initialization successful\")\n        else:\n            print(\"Robot initialization failed\")\n        # Initialize navigation\n        if nav.init():  \n            print(\"Navigation initialization successful\")\n        else:\n            print(\"Navigation initialization failed\")\n\n        # Wait for data preparation\n        time.sleep(1)\n\n        # Check initial localization status\n        is_localized = nav.is_localized()\n        if not is_localized:\n            print(\"Localization failed, attempting to re-localize: Please move the robot to the origin of the map!\")\n        time.sleep(3)\n        while not is_localized:\n            nav.relocalize([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n            time.sleep(0.5)\n            is_localized = nav.is_localized()\n\n        # square_move\n        demo_square_move(robot, nav)\n\n    except Exception as e:\n        print(f\"Exception occurred: {e}\")\n    finally:\n        robot.request_shutdown()\n        robot.wait_for_shutdown()\n        robot.destroy()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/#example4","title":"Example4. \u4f20\u611f\u5668\u6570\u636e\u83b7\u53d6","text":"<p>\u672c\u793a\u4f8b\u5c55\u793a\u4e86GALBOT\u673a\u5668\u4eba\u7684\u4f20\u611f\u5668\u6570\u636e\u91c7\u96c6\u529f\u80fd\u3002\u901a\u8fc7\u521d\u59cb\u5316\u673a\u5668\u4eba\u5e76\u542f\u7528\u5de6\u81c2\u76f8\u673a\u3001\u6df1\u5ea6\u76f8\u673a\u3001\u5e95\u5ea7\u6fc0\u5149\u96f7\u8fbe\u548c\u8eaf\u5e72IMU\u7b49\u4f20\u611f\u5668\uff0c\u7a0b\u5e8f\u83b7\u53d6\u5e76\u5904\u7406RGB\u56fe\u50cf\u3001\u6df1\u5ea6\u56fe\u50cf\u3001\u6fc0\u5149\u96f7\u8fbe\u70b9\u4e91\u6570\u636e\u548cIMU\u6570\u636e\uff0c\u5bf9\u56fe\u50cf\u8fdb\u884c\u89e3\u7801\u548c\u53ef\u89c6\u5316\uff0c\u5c06\u70b9\u4e91\u6570\u636e\u8f6c\u6362\u5e76\u4fdd\u5b58\u4e3aPCD\u683c\u5f0f\u6587\u4ef6\uff0c\u540c\u65f6\u5b9e\u73b0\u6df1\u5ea6\u56fe\u4e0eRGB\u56fe\u50cf\u878d\u5408\u751f\u6210\u5f69\u8272\u70b9\u4e91\u7684\u529f\u80fd\u3002</p> <p>\u6ce8\u610f\uff1a1. \u4fdd\u6301\u6025\u505c\u6309\u94ae\u4e3a\u6253\u5f00\u72b6\u6001\uff1b2. \u786e\u4fdd\u673a\u5668\u4eba\u9644\u8fd12\u7c73\u8303\u56f4\u65e0\u906e\u6321\uff0c\u907f\u514d\u624b\u81c2\u89e6\u78b0\u969c\u788d\u7269\u51fa\u73b0\u5371\u9669\u3002</p> examples/python/tutorials/example4_sensor_data_collect.py<pre><code>\"\"\"\nNote: When running this example, please confirm that the robot's left arm camera driver `/data/galbot/bin/left_arm_camera_capture`\n    and radar driver `/data/galbot/bin/service_livox_capture` have been loaded;\n\"\"\"\ntry:\n    from galbot_sdk.g1  import GalbotRobot, SensorType\nexcept ImportError:\n    print(\"import galbot_sdk failed, please install it first or check if it is in the PYTHONPATH\")\n    exit(1)\n\nimport os\n\ntry:\n    import open3d as o3d\nexcept ImportError:\n    os.system(\"pip install open3d\")\n    import open3d as o3d\n\ntry:\n    import cv2\nexcept ImportError:\n    os.system(\"pip install opencv-python\")\n    import cv2\n\ntry:\n    import numpy as np\nexcept ImportError:\n    os.system(\"pip install numpy\")\n    import numpy as np\n\nimport time\nfrom typing import Dict\n\n\ndef convert_pointcloud(cloud):\n    \"\"\"\n    Convert cloud dict to NumPy array dictionary\n\n    Parameters:\n        cloud (dict): PointCloud2 protobuf message object\n\n    Returns:\n        Dictionary: {field_name: NumPy array}\n        - Single-element fields: shape (N,)\n        - Multi-element fields: shape (N, count) or (N,)\n        - N = width * height (total number of points)\n    \"\"\"\n\n    if not cloud:\n        return {}\n\n    num_points = cloud[\"height\"] * cloud[\"width\"]\n    if num_points == 0:\n        return {}\n\n    DTYPE_MAP = {\n        1: np.int8,\n        2: np.uint8,\n        3: np.int16,\n        4: np.uint16,\n        5: np.int32,\n        6: np.uint32,\n        7: np.float32,\n        8: np.float64\n    }\n    dtype_list = []\n    for field in cloud[\"fields\"]:\n        # Get base data type\n        np_dtype_class = DTYPE_MAP.get(field[\"datatype\"])\n        if np_dtype_class is None:\n            raise ValueError(f\"Unsupported data type: {field['datatype']}\")\n\n        dtype_inst = np.dtype(np_dtype_class)\n\n        # Handle byte order (endianness)\n        if dtype_inst.itemsize &gt; 1:\n            byteorder = '&gt;' if cloud[\"is_bigendian\"] else '&lt;'\n            dtype_inst = dtype_inst.newbyteorder(byteorder)\n\n        # Add to dtype list\n        if field[\"count\"] == 1:\n            dtype_list.append((field[\"name\"], dtype_inst))\n        else:\n            # Multi-element fields (e.g., rgb)\n            dtype_list.append((field[\"name\"], dtype_inst, field[\"count\"]))\n\n    # Create structured dtype\n    dtype = np.dtype(dtype_list)\n\n    # Data integrity check\n    expected_size = num_points * cloud[\"point_step\"]\n    if len(cloud[\"data\"]) &lt; expected_size:\n        raise ValueError(\n            f\"Insufficient data length: expected {expected_size} bytes, \"\n            f\"actual {len(cloud['data'])} bytes\"\n        )\n\n    # Create NumPy structured array from binary data\n    # count parameter ensures only expected number of points are read\n    arr = np.frombuffer(cloud[\"data\"], dtype=dtype, count=num_points)\n\n    # Convert to regular dictionary (copy data to avoid modifying original)\n    result = {}\n    for field in cloud[\"fields\"]:\n        field_data = arr[field[\"name\"]]\n\n        # Handle shape of multi-element fields\n        if field[\"count\"] == 1:\n            result[field[\"name\"]] = field_data.copy()\n        else:\n            # Keep original shape or flatten, choose according to needs\n            result[field[\"name\"]] = field_data.copy()\n\n    return result\n\n\ndef get_xyz_array(pointcloud_dict: Dict[str, np.ndarray], \n                remove_nan: bool = False) -&gt; np.ndarray:\n    \"\"\"\n    Extract XYZ coordinate array from converted point cloud dictionary\n\n    Parameters:\n        pointcloud_dict (Dict[str, np.ndarray]): Dictionary returned by pointcloud2_to_numpy()\n        remove_nan (bool, optional): Whether to remove points containing NaN (for FLOAT32/FLOAT64 types). Defaults to False.\n\n    Returns:\n        Nx3 point coordinate array\n    \"\"\"\n    required = ['x', 'y', 'z']\n    if not all(k in pointcloud_dict for k in required):\n        raise ValueError(\"Point cloud data missing required xyz fields\")\n\n    points = np.stack([pointcloud_dict['x'], \n                    pointcloud_dict['y'], \n                    pointcloud_dict['z']], axis=1)\n\n    if remove_nan:\n        mask = ~np.isnan(points).any(axis=1)\n        points = points[mask]\n\n    return points\n\ndef save_xyz_to_pcd(xyz_array: np.ndarray, filename: str, binary: bool = False) -&gt; None:\n    \"\"\"\n    Save XYZ coordinates to PCD file format (simplest option for coordinate-only data)\n\n    Parameters:\n        xyz_array (np.ndarray): Nx3 array of XYZ coordinates\n        filename (str): Output PCD file path\n        binary (bool, optional): If True, saves in binary format; otherwise ASCII. Defaults to False.\n    \"\"\"\n    if xyz_array.ndim != 2 or xyz_array.shape[1] != 3:\n        raise ValueError(f\"xyz_array must have shape (N, 3), got {xyz_array.shape}\")\n\n    num_points = xyz_array.shape[0]\n    header = [\n        \"# .PCD v0.7 - Point Cloud Data file format\",\n        \"VERSION 0.7\",\n        \"FIELDS x y z\",\n        \"SIZE 4 4 4\",\n        \"TYPE F F F\",  # F = float32\n        \"COUNT 1 1 1\",\n        f\"WIDTH {num_points}\",\n        \"HEIGHT 1\",\n        \"VIEWPOINT 0 0 0 1 0 0 0\",\n        f\"POINTS {num_points}\",\n        f\"DATA {'binary' if binary else 'ascii'}\"\n    ]\n\n    if binary:\n        with open(filename, 'wb') as f:\n            f.write(('\\n'.join(header) + '\\n').encode('ascii'))\n            f.write(xyz_array.astype(np.float32).tobytes())\n    else:\n        with open(filename, 'w') as f:\n            f.write('\\n'.join(header) + '\\n')\n            np.savetxt(f, xyz_array, fmt='%f')\n\n\ndef decode_compressed_image(compressed_image):\n    \"\"\"\n    decode CompressedImage image\n\n    Parameters:\n        compressed_image (dict): image dict, keys:[header, format, data, \"depth_scale\"]\n\n    Returns:\n        numpy.ndarray: decoded image\n    \"\"\"\n    image_data = compressed_image[\"data\"]\n    if compressed_image[\"format\"] == \"rgb8\":\n        return decode_rgb_image(image_data)\n    elif compressed_image[\"format\"] == \"16UC1\":\n        return decode_depth_image(compressed_image)\n    else:\n        raise ValueError(f\"Unsupport data format: {compressed_image['format']}\")\n\ndef decode_rgb_image(image_data):\n    \"\"\"decode rgb image\"\"\"\n    nparr = np.frombuffer(image_data, np.uint8)\n    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n    if img is None:\n        raise ValueError(\"Fail to Decode RGB Image\")\n    return img\n\ndef decode_depth_image(image_data):\n    \"\"\"decode depth image\"\"\"\n    depth_img = np.frombuffer(image_data[\"data\"], dtype=np.uint16).copy()\n\n    # Check if height and width exist\n    if \"height\" not in image_data or \"width\" not in image_data:\n        raise ValueError(\"Missing 'height' or 'width' in depth image metadata.\")\n    if image_data[\"height\"] == 0 or image_data[\"width\"] == 0:\n        raise ValueError(f\"Invalid 'height' ({image_data['height']}) or 'width' ({image_data['width']}) in depth image metadata.\")\n\n    # Parse depth image\n    depth_img = depth_img.reshape((image_data[\"height\"], image_data[\"width\"]))\n    depth_img = depth_img.astype(np.float32) / image_data[\"depth_scale\"]\n\n    return depth_img\n\ndef depth_rgb_to_pointcloud(depth, rgb, fx, fy, cx, cy, depth_scale=1.0):\n    \"\"\"\n    Convert depth map and RGB image to point cloud\n\n    Parameters:\n        depth: (H, W) depth map\n        rgb:   (H, W, 3) RGB image\n        depth_scale: Depth unit scaling (use 0.001 for mm-&gt;m conversion)\n\n    Returns:\n        points: (N, 3) point cloud coordinate array\n        colors: (N, 3) point cloud color array (0-1 range)\n    \"\"\"\n    assert depth.shape[:2] == rgb.shape[:2]\n\n    H, W = depth.shape\n\n    # Pixel coordinates\n    u, v = np.meshgrid(np.arange(W), np.arange(H))\n\n    # Depth (converted to meters)\n    Z = depth.astype(np.float32) * depth_scale\n\n    # Filter invalid depths\n    valid = Z &gt; 0\n\n    X = (u - cx) * Z / fx\n    Y = (v - cy) * Z / fy\n\n    points = np.stack((X, Y, Z), axis=-1)\n    colors = rgb.astype(np.float32) / 255.0\n\n    # Keep only valid points\n    points = points[valid]\n    colors = colors[valid]\n\n    return points, colors\n\ndef check_robot_safety():\n    \"\"\"Check if robot is safe\"\"\"\n    # Prompt important notes\n    print(\"\u26a0\ufe0f  Note: 1. Please ensure the emergency stop button of the robot is released; 2. Please ensure there are no obstructions around the robot to avoid unexpected situations.\")\n    while True:\n        key = input(\"Please confirm that the robot's emergency stop button is released and there are no obstructions, continue? (y/n)...\")\n        if key == 'y':\n            print(\"User confirmed, continuing...\")\n            break\n        elif key == 'n':\n            print(\"User did not confirm, exiting program...\")\n            exit(1)\n        else:\n            print(\"Invalid input, please enter 'y' or 'n'\")\n\ndef main():\n    check_robot_safety()\n    try:\n        # Get and initialize the GalbotRobot singleton\n        robot = GalbotRobot.get_instance()\n\n        # Get RGB and depth images from the left arm, depth images from the right arm, \n        # base LiDAR data, and torso IMU data\n        enable_sensor_set = {SensorType.LEFT_ARM_CAMERA, # Left arm depth camera\n                            SensorType.LEFT_ARM_DEPTH_CAMERA, # Left arm RGB camera\n                            SensorType.BASE_LIDAR,} # Base LiDAR\n\n        # To save resource overhead, only cameras and radar sensors passed during initialization can acquire data\n        robot.init(enable_sensor_set)\n        print(\"Initialization successful\")\n        # Program starts immediately, wait for data readiness\n        time.sleep(5)\n\n        # Get RGB image from the left arm\n        rgb_image_data = robot.get_rgb_data(SensorType.LEFT_ARM_CAMERA)\n        if not rgb_image_data:\n            print(\"No rgb image data!\")\n        else:\n            print(\"get rgb image suceess\")\n            print(rgb_image_data['header'])\n            img = decode_compressed_image(rgb_image_data)\n\n            # Save RGB image\n            cv2.imwrite(\"rgb_image_data.jpg\", img)\n            # Visualize RGB image\n            cv2.namedWindow(\"rgb image\", cv2.WINDOW_NORMAL)\n            cv2.imshow(\"rgb image\", img)\n            cv2.waitKey(0)\n            cv2.destroyAllWindows()\n\n        # Get depth image from the left arm\n        depth_data = robot.get_depth_data(SensorType.LEFT_ARM_DEPTH_CAMERA)\n        if not depth_data or \"data\" not in depth_data:\n            print(\"Depth camera not ready\")\n        else:\n            print(\"get depth data suceess\")\n            print(depth_data['header'])\n            depth_img_raw = decode_compressed_image(depth_data)\n            depth_img = cv2.normalize(depth_img_raw, None, 0, 255, cv2.NORM_MINMAX) # Normalize, mapping depth values to 0-1 range\n            depth_img = depth_img.astype(np.uint8)\n\n            # Save depth image\n            cv2.imwrite(\"depth_data.jpg\", depth_img)\n            # Visualize depth image\n            cv2.namedWindow(\"depth image\", cv2.WINDOW_NORMAL)\n            cv2.imshow(\"depth image\", depth_img)\n            cv2.waitKey(0)\n            cv2.destroyAllWindows()\n\n        # Get base LiDAR data\n        lidar_data = robot.get_lidar_data(SensorType.BASE_LIDAR)\n        if not lidar_data:\n            print(\"No lidar data!\")\n        else:\n            pointcloud_dict = convert_pointcloud(lidar_data)\n            xyz_points = get_xyz_array(pointcloud_dict)\n            save_xyz_to_pcd(xyz_points, \"output_xyz.pcd\")\n            print(pointcloud_dict)\n            print(\"get lidar data success\")\n\n            # Visualize LiDAR point cloud\n            vis = o3d.visualization.Visualizer()\n            vis.create_window()\n            pcd = o3d.geometry.PointCloud()\n            pcd.points = o3d.utility.Vector3dVector(xyz_points)\n            vis.add_geometry(pcd)\n            vis.run()\n            vis.destroy_window()\n\n        # Get torso IMU data\n        imu_data = robot.get_imu_data(SensorType.TORSO_IMU)\n        if not imu_data:\n            print(\"No imu data!\")\n        else:\n            print(\"get imu data suceess\")\n\n        try:\n            camera_info = robot.get_camera_intrinsic(SensorType.LEFT_ARM_DEPTH_CAMERA)\n            if not camera_info:\n                print(\"No camera info!\")\n            else:\n                print(camera_info)\n        except Exception as e:\n            camera_info = {\n                \"width\": 1280,\n                \"height\": 720,\n                \"distortion_model\": \"plumb_bob\",\n                \"camera_type\": \"D405\",\n                \"k\": [653.4349365234375, 0.0, 639.95159912109375, \n                    0.0, 652.48858642578125, 365.29425048828125, \n                    0.0, 0.0, 1.0],\n            }\n\n        # Convert depth map and RGB image to point cloud and save\n        if depth_data and rgb_image_data:\n            points, colors = depth_rgb_to_pointcloud(\n                depth_img_raw,\n                img,\n                fx=camera_info['k'][0],\n                fy=camera_info['k'][4],\n                cx=camera_info['k'][2],\n                cy=camera_info['k'][5],\n                depth_scale=0.1   # If depth is in mm, set to 0.001\n            )\n            save_xyz_to_pcd(points, \"left_arm_camera_pointcloud.pcd\", binary=True)\n            print(f\"RGB fused depth map point cloud saved to left_arm_camera_pointcloud.pcd, number of points: {points.shape[0]}\")\n    except Exception as e:\n        print(f\"\u274c Exception occurred: {e}\")\n    finally:\n        # Actively send SIGINT exit signal\n        robot.request_shutdown()\n        # Wait to enter shutdown state\n        robot.wait_for_shutdown()\n        # Release SDK resources\n        robot.destroy()\n        print('Resource release successful')\n\n\nif __name__==\"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/#example5","title":"Example5. \u6293\u53d6\u548c\u653e\u7f6e\u7269\u4f53","text":"<p>\u672c\u793a\u4f8b\u5c55\u793a\u4e86\u673a\u5668\u4eba\u7684\u6293\u53d6\u548c\u653e\u7f6e\u7269\u4f53\u529f\u80fd\uff0c\u6267\u884c\u672c\u7a0b\u5e8f\u540e\u673a\u5668\u4eba\u5c06\u79fb\u52a8\u5230\u5176\u5de6\u540e\u65b9\u7ea61\u7c73\u4f4d\u7f6e\u5904\uff0c\u5c1d\u8bd5\u865a\u7a7a\u6293\u53d6\u7269\u4f53\u3002\u901a\u8fc7\u521d\u59cb\u5316\u673a\u5668\u4eba\u3001\u5bfc\u822a\u3001\u8fd0\u52a8\u63a7\u5236\u5b9e\u4f8b\u4ee5\u53ca\u591a\u4e2a\u4f20\u611f\u5668\uff0c\u7a0b\u5e8f\u9996\u5148\u5bfc\u822a\u5230\u76ee\u6807\u533a\u57df\uff0c\u7136\u540e\u62ac\u8d77\u76f8\u673a\u5230\u5408\u9002\u9ad8\u5ea6\uff0c\u5229\u7528\u89c6\u89c9\u7cfb\u7edf\u68c0\u6d4b\u76ee\u6807\u7269\u4f53\u5e76\u5c06\u5176\u4f4d\u59ff\u8f6c\u6362\u5230\u5e95\u76d8\u5750\u6807\u7cfb\uff0c\u63a5\u7740\u63a7\u5236\u673a\u68b0\u81c2\u79fb\u52a8\u5230\u76ee\u6807\u4f4d\u7f6e\u8fdb\u884c\u6293\u53d6\uff0c\u5b8c\u6210\u6293\u53d6\u540e\u5bfc\u822a\u56de\u5230\u521d\u59cb\u4f4d\u7f6e\u5e76\u5c06\u7269\u4f53\u653e\u4e0b\uff0c\u6574\u4e2a\u8fc7\u7a0b\u96c6\u6210\u4e86\u5bfc\u822a\u3001\u89c6\u89c9\u8bc6\u522b\u3001\u673a\u68b0\u81c2\u63a7\u5236\u548c\u5939\u722a\u64cd\u4f5c\u7b49\u591a\u79cd\u529f\u80fd\u3002</p> <p>\u6ce8\u610f\uff1a1. \u4fdd\u6301\u6025\u505c\u6309\u94ae\u4e3a\u6253\u5f00\u72b6\u6001\uff1b2. \u786e\u4fdd\u673a\u5668\u4eba\u9644\u8fd12\u7c73\u8303\u56f4\u65e0\u906e\u6321\uff0c\u907f\u514d\u624b\u81c2\u89e6\u78b0\u969c\u788d\u7269\u51fa\u73b0\u5371\u9669\u3002</p> examples/python/tutorials/example5_pick_and_place.py<pre><code>\"\"\"\nNote: When running this example, please confirm that the robot's motion control service `/data/galbot/bin/service_motion_plan`,\n    robot state publishing service `/data/galbot/bin/robot_state_publish`,\n    navigation service `/data/galbot/bin/service_navigation_plan`\n    and hand-eye calibration publishing service `/data/galbot/bin/eyehand_calib_publish` have been loaded;\n\"\"\"\ntry:\n    import galbot_sdk.g1 as gm\n    from galbot_sdk.g1  import GalbotNavigation, GalbotRobot, GalbotMotion, JointGroup, SensorType\nexcept ImportError:\n    print(\"Import galbot_sdk failed, please install it first or check if it is in the PYTHONPATH\")\n    exit(1)\n\nimport os\n\ntry:\n    import numpy as np\nexcept ImportError:\n    os.system(\"pip install numpy\")\n    import numpy as np\n\ntry:\n    from scipy.spatial.transform import Rotation as R\nexcept ImportError:\n    os.system(\"pip install scipy\")\n    from scipy.spatial.transform import Rotation as R\n\ntry:\n    import cv2\nexcept ImportError:\n    os.system(\"pip install opencv-python\")\n    import cv2\n\nimport time\nfrom typing import Sequence\n\ndef decode_compressed_image(compressed_image, camera_info={}):\n    \"\"\"\n    decode CompressedImage image\n\n    Parameters:\n        compressed_image (dict): image dict, keys:[header, format, data, \"depth_scale\"]\n\n    Returns:\n        numpy.ndarray: decoded image\n    \"\"\"\n    image_data = compressed_image[\"data\"]\n    if compressed_image[\"format\"] == \"rgb8\":\n        return decode_rgb_image(image_data)\n    elif compressed_image[\"format\"] == \"16UC1\":\n        return decode_depth_image(image_data, compressed_image[\"depth_scale\"], camera_info)\n    else:\n        raise ValueError(f\"Unsupport data format: {compressed_image['format']}\")\n\ndef decode_rgb_image(image_data):\n    \"\"\"decode rgb image\"\"\"\n    nparr = np.frombuffer(image_data, np.uint8)\n    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\n    if img is None:\n        raise ValueError(\"Fail to Decode RGB Image\")\n    return img\n\ndef decode_depth_image(image_data, depth_scale, camera_info):\n    \"\"\"decode depth image\"\"\"\n    depth_img = np.frombuffer(image_data, dtype=np.uint16).copy()\n\n    if not camera_info:\n        depth_img = depth_img.reshape((720, 1280))\n    else:\n        depth_img = depth_img.reshape((camera_info[\"height\"], camera_info[\"width\"]))\n    depth_img = depth_img.astype(np.float32) / depth_scale\n\n    return depth_img\n\ndef print_gripper_state(joint_group, gripper_state):\n    \"\"\"\n    Print gripper state\n\n    Parameters:\n        joint_group (JointGroup): JointGroup enum\n        gripper_state (object): Contains timestamp_ns, width, velocity, effort, is_moving\n    \"\"\"\n    print(f\"Timestamp (ns): {gripper_state.timestamp_ns}\")\n    print(\n        f\"width {gripper_state.width} \"\n        f\"velocity {gripper_state.velocity} \"\n        f\"effort {gripper_state.effort} \"\n        f\"is moving {gripper_state.is_moving}\"\n    )\n\ndef get_navigation_pose(object_goal_pose: Sequence[float], motion: GalbotMotion, arm: str = \"left_arm\"):\n    \"\"\"\n    Get navigation target pose\n\n    Parameters:\n        object_goal_pose (Sequence[float]): Target pose [x, y, z, qx, qy, qz, qw]\n        motion (GalbotMotion): Motion control instance\n        arm (str, optional): End effector name. Defaults to \"left_arm\".\n\n    Returns:\n        Sequence[float]: Navigation target pose [x, y, z, qx, qy, qz, qw]\n    \"\"\"\n    assert arm in [\"left_arm\", \"right_arm\"], \"arm must be left_arm or right_arm\"\n\n    try:\n        status, ee_pose_in_base = motion.get_end_effector_pose(\n            end_effector_frame=f\"{arm}_end_effector_mount_link\",\n            reference_frame=\"base_link\"\n        )\n        if status != gm.MotionStatus.SUCCESS:\n            print(f\"Failed to get end effector pose: status={status}\")\n            offset_y = ee_pose_in_base[1]\n        else:\n            print(f\"Successfully got end effector pose: pose={ee_pose_in_base}\")\n            offset_y = 0.3\n\n        # Set chassis pose to the same z coordinate as the target pose\n        base_goal_pose_mat = np.eye(4)\n        base_goal_pose_mat[:3, :3] = R.from_quat(object_goal_pose[3:]).as_matrix()\n        base_goal_pose_mat[:3, 3] = np.array([object_goal_pose[0], object_goal_pose[1], 0])\n\n        # According to the relative position of the chassis and camera, move the camera navigation target 0.6m backward in the local coordinate to leave observation space for the camera\n        base_goal_pose_mat = base_goal_pose_mat @ np.array([[1,0,0,-0.6],[0,1,0,-offset_y],[0,0,1,0],[0,0,0,1]])\n        print(base_goal_pose_mat)\n\n        base_goal_pose_quat = R.from_matrix(base_goal_pose_mat[:3, :3]).as_quat()\n        base_goal_pose_pos = base_goal_pose_mat[:3, 3]\n\n        return base_goal_pose_pos.tolist() + base_goal_pose_quat.tolist()\n\n    except Exception as e:\n        print(\"Failed to get navigation target pose:\", e)\n\n\ndef navigation_to_goal(nav: GalbotNavigation, goal_pose: Sequence[float], retry_cnt: int = 3):\n    \"\"\"\n    Navigate to target pose\n\n    Parameters:\n        nav (GalbotNavigation): Navigation instance\n        goal_pose (Sequence[float]): Target pose [x, y, z, qx, qy, qz, qw]\n        retry_cnt (int, optional): Number of retries. Defaults to 3.\n    \"\"\"\n    try:\n        cur_pose = nav.get_current_pose()\n        print(f\"Current pose: {cur_pose}\")\n        if nav.check_path_reachability(goal_pose, cur_pose):\n            retry_cnt = 3\n            while True:\n                status = nav.navigate_to_goal(goal_pose, enable_collision_check=True, is_blocking=True, timeout=20)\n                time.sleep(0.5)\n                retry_cnt -= 1\n                if nav.check_goal_arrival() or retry_cnt &lt; 0:\n                    break\n                else:\n                    print(f\"Navigation failed: status={status}, retrying: {retry_cnt}\")\n            print(\"navigate_to_goal return status:\", status)\n            print(\"Has arrived:\", nav.check_goal_arrival())\n        else:\n            print(\"Path unreachable or unsafe\")\n    except Exception as e:\n        print(f\"Exception occurred during navigation: {e}\")\n\ndef lift_camera_up(motion: GalbotMotion, target_pose: Sequence[float], target_chain: str, reference_frame: str):\n    \"\"\"\n    Lift camera to target height\n\n    Parameters:\n        motion (GalbotMotion): Motion control instance\n        target_pose (Sequence[float]): Target pose [x, y, z, qx, qy, qz, qw]\n        target_chain (str): End effector name\n        reference_frame (str): Reference frame\n    \"\"\"\n    try:\n        retry_cnt = 3\n        while True:\n            status, cur_ee_pose = motion.get_end_effector_pose_on_chain(\n                chain_name=target_chain,\n                frame_id=\"EndEffector\",\n                reference_frame=reference_frame\n            )\n            time.sleep(0.5)\n            retry_cnt -= 1\n\n            if status == gm.MotionStatus.SUCCESS or retry_cnt &lt; 0:\n                print(f\"Current end effector pose: {cur_ee_pose}\")\n                break\n            else:\n                print(f\"Failed to get end effector pose: status={status}, retrying: {retry_cnt}\")\n\n        tgt_ee_pose = cur_ee_pose.copy()\n        tgt_ee_pose[2] = target_pose[2] - 0.1\n        print(f\"Target end effector pose: {tgt_ee_pose}\")\n\n        retry_cnt = 3\n        while True:\n            status = motion.set_end_effector_pose(\n                target_pose=tgt_ee_pose,\n                end_effector_frame=target_chain,\n                reference_frame=reference_frame,\n                enable_collision_check=False,\n                is_blocking=True,\n                timeout=5.0,\n                params=gm.Parameter()\n            )\n            time.sleep(0.5)\n            retry_cnt -= 1\n            if status == gm.MotionStatus.SUCCESS or retry_cnt &lt; 0:\n                print(f\"\u2705 Successfully set end effector pose: status={status}\")\n                break\n            else:\n                print(f\"Failed to set end effector pose: status={status}, retrying: {retry_cnt}\")\n    except Exception as e:\n        print(f\"\u274c Failed to lift camera: {e}\")\n\ndef detect_target(img: np.ndarray, depth_img: np.ndarray) -&gt; Sequence[float]:\n    \"\"\"\n    Detection target function. Input RGB image and depth image, output target pose.\n\n    Parameters:\n        img (np.ndarray): RGB image\n        depth_img (np.ndarray): Depth image\n\n    Returns:\n        Sequence[float]: Target pose [x, y, z, qx, qy, qz, qw]\n    \"\"\"\n    try:\n\n        ############### NOTE ###############\n        # This function is a placeholder. In a real-world scenario, you would implement\n        # target detection using computer vision techniques. For this example, we assume\n        # a default pose.\n        ####################################\n\n        # Assume detected target pose is [-0.05, -0.1, 0.12, 0.0, 0.0, 0.0, 1.0]\n        # Indicates the target is 0.12m in front of the camera, 0.05m to the left, 0.1m in height, facing the default camera direction\n        default_pose = [-0.05, -0.1, 0.12, 0.0, 0.0, 0.0, 1.0]\n\n        return default_pose\n    except Exception as e:\n        print(f\"Target detection exception: {e}\")\n        return None\n\ndef pose_camera_to_base(robot: GalbotRobot, pose_camera: Sequence[float]) -&gt; Sequence[float]:\n    \"\"\"\n    Transform camera pose to chassis coordinate system\n\n    Parameters:\n        robot (GalbotRobot): Robot instance\n        pose_camera (Sequence[float]): Camera pose [x, y, z, qx, qy, qz, qw]\n\n    Returns:\n        Sequence[float]: Chassis pose [x, y, z, qx, qy, qz, qw]\n    \"\"\"\n    source_frame=\"left_arm_camera_color_optical_frame\"\n    target_frame=\"base_link\"\n    base_to_cam = robot.get_transform(target_frame, source_frame)[0]\n    if base_to_cam is None:\n        print(\"Failed to get transform from camera to chassis\")\n        return None\n    else:\n        print(\"base_to_cam: \", base_to_cam)\n\n    base_to_cam_mat = np.eye(4)\n    base_to_cam_mat[:3, :3] = R.from_quat(base_to_cam[3:]).as_matrix()\n    base_to_cam_mat[:3, 3] = np.array(base_to_cam[:3])\n\n    pose_camera_mat = np.eye(4)\n    pose_camera_mat[:3, :3] = R.from_quat(pose_camera[3:]).as_matrix()\n    pose_camera_mat[:3, 3] = np.array(pose_camera[:3])\n\n    pose_base_mat = base_to_cam_mat @ pose_camera_mat[:, 3:]\n    print(\"pose_base_mat: \", pose_base_mat)\n\n    return pose_base_mat.flatten()[:3].tolist() + [0, 0, 0, 1]\n\ndef detect_object(robot: GalbotRobot, arm: str = \"left_arm\"):\n    try:\n        # Get camera image data\n        if arm == \"left_arm\":\n            rgb_image_data = robot.get_rgb_data(SensorType.LEFT_ARM_CAMERA)\n            depth_data = robot.get_depth_data(SensorType.LEFT_ARM_DEPTH_CAMERA)\n        elif arm == \"right_arm\":\n            rgb_image_data = robot.get_rgb_data(SensorType.RIGHT_ARM_CAMERA)\n            depth_data = robot.get_depth_data(SensorType.RIGHT_ARM_DEPTH_CAMERA)\n        else:\n            raise ValueError(\"arm must be left_arm or right_arm\")\n\n        # Decode image data\n        if not rgb_image_data:\n            print(\"No rgb image data!\")\n        else:\n            print(\"get rgb image suceess\")\n            img = decode_compressed_image(rgb_image_data)\n\n        if not depth_data:\n            print(\"No depth_data!\")\n        else:\n            depth_img = decode_compressed_image(depth_data)\n            print(\"get depth data suceess\")\n\n        # Detect target\n        object_pose_camera = detect_target(img, depth_img)\n        if object_pose_camera is None:\n            print(\"Target detection failed\")\n            return None\n        else:\n            print(f\"object_pose_camera: {object_pose_camera}\")\n\n        # Calculate target pose in chassis coordinate system\n        object_pose_base = pose_camera_to_base(robot, object_pose_camera)\n        print(f\"Target pose in chassis coordinate system: {object_pose_base}\")\n\n    except Exception as e:\n        print(f\"Target detection exception: {e}\")\n\n    return object_pose_base\n\ndef check_robot_safety():\n    \"\"\"Check if robot is safe\"\"\"\n    # Prompt important notes\n    print(\"\u26a0\ufe0f  Note: 1. Please ensure the emergency stop button of the robot is released; 2. Please ensure there are no obstructions around the robot to avoid unexpected situations. 3. Please ensure the area around the robot is clear of obstacles.\")\n    while True:\n        key = input(\"Please confirm that the robot's emergency stop button is released and there are no obstructions, continue? (y/n)...\")\n        if key == 'y':\n            print(\"User confirmed, continuing...\")\n            break\n        elif key == 'n':\n            print(\"User did not confirm, exiting program...\")\n            exit(1)\n        else:\n            print(\"Invalid input, please enter 'y' or 'n'\")\n\ndef pick_and_place(robot: GalbotRobot, \n                   nav: GalbotNavigation, \n                   motion: GalbotMotion, \n                   object_pose_base: Sequence[float], \n                   target_chain: str, \n                   reference_frame: str):\n    try:\n        # Open left gripper\n        # Set left gripper width to 0.1m, speed to 0.05m, force to 10N, will block until gripper reaches position\n        status = robot.set_gripper_command(\n            JointGroup.LEFT_GRIPPER, 0.1, 0.05, 10, True\n        )\n        time.sleep(0.5)\n\n        print(\"object_pose_base: \", object_pose_base)\n\n        # Reach to target position\n        retry_cnt = 3\n        while True:\n            status = motion.set_end_effector_pose(\n                target_pose=object_pose_base,\n                end_effector_frame=target_chain,\n                reference_frame=reference_frame,\n                enable_collision_check=False,\n                is_blocking=True,\n                timeout=5.0,\n                params=gm.Parameter()\n            )\n            time.sleep(1)\n            retry_cnt -= 1\n            if status == gm.MotionStatus.SUCCESS or retry_cnt &lt; 0:\n                break\n            else:\n                print(f\"Failed to set end effector pose: status={status}, retry count: {retry_cnt}\")\n\n        assert status == gm.MotionStatus.SUCCESS, \"Failed to set end effector pose\"\n        print(f\"\u2705 Successfully set end effector pose: status={status}\")\n\n        # Close gripper to grasp object\n        status = robot.set_gripper_command(\n            JointGroup.LEFT_GRIPPER, 0.02, 0.05, 10, True\n        )\n        time.sleep(0.5)\n\n        # Return to initial position\n        navigation_to_goal(nav, [0, 0, 0, 0, 0, 0, 1])\n        time.sleep(2)\n\n        # Release target\n        status = robot.set_gripper_command(\n            JointGroup.LEFT_GRIPPER, 0.1, 0.05, 10, True\n        )\n        time.sleep(0.5)\n    except Exception as e:\n        print(f\"Exception occurred during pick_and_place: {e}\")\n        return None\n\n\ndef main():\n    check_robot_safety()\n    try:\n        # Get robot instance\n        robot = GalbotRobot.get_instance()\n        # Get GalbotMotion instance\n        motion = GalbotMotion.get_instance()\n        # Get navigation instance\n        nav = GalbotNavigation.get_instance()\n\n        # Get RGB and depth images from left arm, depth images from right arm, \n        # base LiDAR data, and torso IMU data\n        enable_sensor_set = {SensorType.LEFT_ARM_CAMERA, # Left arm depth camera\n                            SensorType.LEFT_ARM_DEPTH_CAMERA, # Left arm RGB camera\n                            SensorType.BASE_LIDAR, # Base LiDAR\n                            SensorType.TORSO_IMU} # Torso IMU sensor\n\n        # Initialize robot\n        if robot.init(enable_sensor_set):\n            print(\"GalbotRobot initialization successful\")\n        else:\n            print(\"GalbotRobot initialization failed\")\n        if motion.init():\n            print(\"GalbotMotion initialization successful\")\n        else:\n            print(\"GalbotMotion initialization failed\")\n        if nav.init():\n            print(\"GalbotNavigation initialization successful\")\n        else:\n            print(\"GalbotNavigation initialization failed\")\n\n        # Program starts immediately, wait for data readiness\n        time.sleep(1)\n\n        # Calculate navigation target pose\n        object_goal_pose = [-1, 0.33, 0.90, 0, 0, 1, 0]\n        base_goal_pose = [0, 0, 0, 0, 0, 0, 1]\n        base_goal_pose = get_navigation_pose(object_goal_pose, motion)\n\n        # Navigate to target pose\n        navigation_to_goal(nav, base_goal_pose)\n\n        target_chain = \"left_arm\"\n        reference_frame = \"base_link\"\n\n        # Get current end effector pose for subsequent restoration\n        try:\n            status, original_pose = motion.get_end_effector_pose_on_chain(\n                chain_name=target_chain,\n                frame_id=\"EndEffector\",\n                reference_frame=reference_frame\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Failed to get end effector pose\"\n            print(f\"\u2705 Successfully got {target_chain} end effector pose: {original_pose}\")\n            time.sleep(1)\n        except Exception as e:\n            print(f\"\u274c {target_chain} end effector pose exception: {e}\")\n\n        # Lift camera\n        lift_camera_up(motion, object_goal_pose, \"left_arm\", \"base_link\")\n\n        # Detect target\n        object_pose_base = detect_object(robot, arm=\"left_arm\")\n        if object_pose_base is None:\n            print(\"Target detection failed\")\n            return None\n        else:\n            print(f\"Detected target pose: {object_pose_base}\")\n\n        # Grasp and return to initial position\n        pick_and_place(robot, nav, motion, object_pose_base, \"left_arm\", \"base_link\")\n\n        # After grasping target, restore posture\n        try:\n            time.sleep(2)\n            status = motion.set_end_effector_pose(\n                target_pose=original_pose,\n                end_effector_frame=target_chain,\n                reference_frame=reference_frame,\n                enable_collision_check=False,\n                is_blocking=True,\n                timeout=5.0,\n                params=gm.Parameter()\n            )\n            assert status == gm.MotionStatus.SUCCESS, \"Failed to set end effector pose\"\n            print(f\"\u2705 Successfully set end effector pose: status={status}\")\n            time.sleep(1)\n        except Exception as e:\n            print(f\"\u274c {target_chain} end effector pose exception: {e}\")\n\n    except Exception as e:\n        print(f\"Exception occurred: {e}\")\n    finally:\n        # Actively send SIGINT exit signal\n        robot.request_shutdown()\n        # Wait to enter shutdown state\n        robot.wait_for_shutdown()\n        # Release SDK resources\n        robot.destroy()\n        print('Resource release successful')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"galbotCpp/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"galbotCpp/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p>"},{"location":"galbotCpp/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"galbotCpp/classes/","title":"Class Index","text":""},{"location":"galbotCpp/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"galbotCpp/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"galbotCpp/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"galbotCpp/class_members/","title":"Class Members","text":""},{"location":"galbotCpp/class_member_functions/","title":"Class Member Functions","text":""},{"location":"galbotCpp/class_member_variables/","title":"Class Member Variables","text":""},{"location":"galbotCpp/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"galbotCpp/class_member_enums/","title":"Class Member Enums","text":""},{"location":"galbotCpp/namespace_members/","title":"Namespace Members","text":""},{"location":"galbotCpp/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"galbotCpp/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"galbotCpp/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"galbotCpp/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"galbotCpp/functions/","title":"Functions","text":""},{"location":"galbotCpp/macros/","title":"Macros","text":""},{"location":"galbotCpp/variables/","title":"Variables","text":""},{"location":"galbotCpp/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}