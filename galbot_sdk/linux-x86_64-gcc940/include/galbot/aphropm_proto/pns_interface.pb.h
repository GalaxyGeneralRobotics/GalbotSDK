// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: galbot/aphropm_proto/pns_interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "galbot/aphropm_proto/common_def.pb.h"
#include "galbot/aphropm_proto/common_interface.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
namespace galbot {
namespace aphropm_proto {
class EvaluateGoalAvailabilityReq;
class EvaluateGoalAvailabilityReqDefaultTypeInternal;
extern EvaluateGoalAvailabilityReqDefaultTypeInternal _EvaluateGoalAvailabilityReq_default_instance_;
class EvaluateGoalAvailabilityResponse;
class EvaluateGoalAvailabilityResponseDefaultTypeInternal;
extern EvaluateGoalAvailabilityResponseDefaultTypeInternal _EvaluateGoalAvailabilityResponse_default_instance_;
class LoadEnvReq;
class LoadEnvReqDefaultTypeInternal;
extern LoadEnvReqDefaultTypeInternal _LoadEnvReq_default_instance_;
class MoveTrajectoryReq;
class MoveTrajectoryReqDefaultTypeInternal;
extern MoveTrajectoryReqDefaultTypeInternal _MoveTrajectoryReq_default_instance_;
class NavigationException;
class NavigationExceptionDefaultTypeInternal;
extern NavigationExceptionDefaultTypeInternal _NavigationException_default_instance_;
class NavigationMotionPlanReq;
class NavigationMotionPlanReqDefaultTypeInternal;
extern NavigationMotionPlanReqDefaultTypeInternal _NavigationMotionPlanReq_default_instance_;
class NavigationRequest;
class NavigationRequestDefaultTypeInternal;
extern NavigationRequestDefaultTypeInternal _NavigationRequest_default_instance_;
class NavigationResponse;
class NavigationResponseDefaultTypeInternal;
extern NavigationResponseDefaultTypeInternal _NavigationResponse_default_instance_;
class NavigationResult;
class NavigationResultDefaultTypeInternal;
extern NavigationResultDefaultTypeInternal _NavigationResult_default_instance_;
class PoseAvailability;
class PoseAvailabilityDefaultTypeInternal;
extern PoseAvailabilityDefaultTypeInternal _PoseAvailability_default_instance_;
class StopNavigationReq;
class StopNavigationReqDefaultTypeInternal;
extern StopNavigationReqDefaultTypeInternal _StopNavigationReq_default_instance_;
}  // namespace aphropm_proto
}  // namespace galbot
PROTOBUF_NAMESPACE_OPEN
template<> ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* Arena::CreateMaybeMessage<::galbot::aphropm_proto::EvaluateGoalAvailabilityReq>(Arena*);
template<> ::galbot::aphropm_proto::EvaluateGoalAvailabilityResponse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::EvaluateGoalAvailabilityResponse>(Arena*);
template<> ::galbot::aphropm_proto::LoadEnvReq* Arena::CreateMaybeMessage<::galbot::aphropm_proto::LoadEnvReq>(Arena*);
template<> ::galbot::aphropm_proto::MoveTrajectoryReq* Arena::CreateMaybeMessage<::galbot::aphropm_proto::MoveTrajectoryReq>(Arena*);
template<> ::galbot::aphropm_proto::NavigationException* Arena::CreateMaybeMessage<::galbot::aphropm_proto::NavigationException>(Arena*);
template<> ::galbot::aphropm_proto::NavigationMotionPlanReq* Arena::CreateMaybeMessage<::galbot::aphropm_proto::NavigationMotionPlanReq>(Arena*);
template<> ::galbot::aphropm_proto::NavigationRequest* Arena::CreateMaybeMessage<::galbot::aphropm_proto::NavigationRequest>(Arena*);
template<> ::galbot::aphropm_proto::NavigationResponse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::NavigationResponse>(Arena*);
template<> ::galbot::aphropm_proto::NavigationResult* Arena::CreateMaybeMessage<::galbot::aphropm_proto::NavigationResult>(Arena*);
template<> ::galbot::aphropm_proto::PoseAvailability* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PoseAvailability>(Arena*);
template<> ::galbot::aphropm_proto::StopNavigationReq* Arena::CreateMaybeMessage<::galbot::aphropm_proto::StopNavigationReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace galbot {
namespace aphropm_proto {

enum LoadEnvReq_EnvType : int {
  LoadEnvReq_EnvType_PointCloud = 0,
  LoadEnvReq_EnvType_ESDF = 1,
  LoadEnvReq_EnvType_LoadEnvReq_EnvType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoadEnvReq_EnvType_LoadEnvReq_EnvType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoadEnvReq_EnvType_IsValid(int value);
constexpr LoadEnvReq_EnvType LoadEnvReq_EnvType_EnvType_MIN = LoadEnvReq_EnvType_PointCloud;
constexpr LoadEnvReq_EnvType LoadEnvReq_EnvType_EnvType_MAX = LoadEnvReq_EnvType_ESDF;
constexpr int LoadEnvReq_EnvType_EnvType_ARRAYSIZE = LoadEnvReq_EnvType_EnvType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoadEnvReq_EnvType_descriptor();
template<typename T>
inline const std::string& LoadEnvReq_EnvType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoadEnvReq_EnvType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoadEnvReq_EnvType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoadEnvReq_EnvType_descriptor(), enum_t_value);
}
inline bool LoadEnvReq_EnvType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoadEnvReq_EnvType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoadEnvReq_EnvType>(
    LoadEnvReq_EnvType_descriptor(), name, value);
}
enum MoveTrajectoryReq_HeadingDirection : int {
  MoveTrajectoryReq_HeadingDirection_Origin = 0,
  MoveTrajectoryReq_HeadingDirection_Heading = 1,
  MoveTrajectoryReq_HeadingDirection_Omni = 2,
  MoveTrajectoryReq_HeadingDirection_MoveTrajectoryReq_HeadingDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MoveTrajectoryReq_HeadingDirection_MoveTrajectoryReq_HeadingDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MoveTrajectoryReq_HeadingDirection_IsValid(int value);
constexpr MoveTrajectoryReq_HeadingDirection MoveTrajectoryReq_HeadingDirection_HeadingDirection_MIN = MoveTrajectoryReq_HeadingDirection_Origin;
constexpr MoveTrajectoryReq_HeadingDirection MoveTrajectoryReq_HeadingDirection_HeadingDirection_MAX = MoveTrajectoryReq_HeadingDirection_Omni;
constexpr int MoveTrajectoryReq_HeadingDirection_HeadingDirection_ARRAYSIZE = MoveTrajectoryReq_HeadingDirection_HeadingDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveTrajectoryReq_HeadingDirection_descriptor();
template<typename T>
inline const std::string& MoveTrajectoryReq_HeadingDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveTrajectoryReq_HeadingDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveTrajectoryReq_HeadingDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveTrajectoryReq_HeadingDirection_descriptor(), enum_t_value);
}
inline bool MoveTrajectoryReq_HeadingDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveTrajectoryReq_HeadingDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveTrajectoryReq_HeadingDirection>(
    MoveTrajectoryReq_HeadingDirection_descriptor(), name, value);
}
enum NavigationResponse_Status : int {
  NavigationResponse_Status_UNKNOWN = 0,
  NavigationResponse_Status_SUCCESS = 1,
  NavigationResponse_Status_FAILED = 2,
  NavigationResponse_Status_NavigationResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavigationResponse_Status_NavigationResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavigationResponse_Status_IsValid(int value);
constexpr NavigationResponse_Status NavigationResponse_Status_Status_MIN = NavigationResponse_Status_UNKNOWN;
constexpr NavigationResponse_Status NavigationResponse_Status_Status_MAX = NavigationResponse_Status_FAILED;
constexpr int NavigationResponse_Status_Status_ARRAYSIZE = NavigationResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationResponse_Status_descriptor();
template<typename T>
inline const std::string& NavigationResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationResponse_Status_descriptor(), enum_t_value);
}
inline bool NavigationResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationResponse_Status>(
    NavigationResponse_Status_descriptor(), name, value);
}
enum NavigationResult_TaskStatus : int {
  NavigationResult_TaskStatus_UNKNOWN = 0,
  NavigationResult_TaskStatus_RUNNING = 1,
  NavigationResult_TaskStatus_SUCCESS = 2,
  NavigationResult_TaskStatus_FAILED = 3,
  NavigationResult_TaskStatus_NavigationResult_TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavigationResult_TaskStatus_NavigationResult_TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavigationResult_TaskStatus_IsValid(int value);
constexpr NavigationResult_TaskStatus NavigationResult_TaskStatus_TaskStatus_MIN = NavigationResult_TaskStatus_UNKNOWN;
constexpr NavigationResult_TaskStatus NavigationResult_TaskStatus_TaskStatus_MAX = NavigationResult_TaskStatus_FAILED;
constexpr int NavigationResult_TaskStatus_TaskStatus_ARRAYSIZE = NavigationResult_TaskStatus_TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationResult_TaskStatus_descriptor();
template<typename T>
inline const std::string& NavigationResult_TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationResult_TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationResult_TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationResult_TaskStatus_descriptor(), enum_t_value);
}
inline bool NavigationResult_TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationResult_TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationResult_TaskStatus>(
    NavigationResult_TaskStatus_descriptor(), name, value);
}
enum NavigationException_Exception : int {
  NavigationException_Exception_UNKNOWN = 0,
  NavigationException_Exception_INIT_FAIL = 1,
  NavigationException_Exception_NavigationException_Exception_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavigationException_Exception_NavigationException_Exception_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavigationException_Exception_IsValid(int value);
constexpr NavigationException_Exception NavigationException_Exception_Exception_MIN = NavigationException_Exception_UNKNOWN;
constexpr NavigationException_Exception NavigationException_Exception_Exception_MAX = NavigationException_Exception_INIT_FAIL;
constexpr int NavigationException_Exception_Exception_ARRAYSIZE = NavigationException_Exception_Exception_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationException_Exception_descriptor();
template<typename T>
inline const std::string& NavigationException_Exception_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationException_Exception>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationException_Exception_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationException_Exception_descriptor(), enum_t_value);
}
inline bool NavigationException_Exception_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationException_Exception* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationException_Exception>(
    NavigationException_Exception_descriptor(), name, value);
}
enum NavigationException_SerLevel : int {
  NavigationException_SerLevel_CRITICAL = 0,
  NavigationException_SerLevel_NORMAL = 1,
  NavigationException_SerLevel_NavigationException_SerLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavigationException_SerLevel_NavigationException_SerLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavigationException_SerLevel_IsValid(int value);
constexpr NavigationException_SerLevel NavigationException_SerLevel_SerLevel_MIN = NavigationException_SerLevel_CRITICAL;
constexpr NavigationException_SerLevel NavigationException_SerLevel_SerLevel_MAX = NavigationException_SerLevel_NORMAL;
constexpr int NavigationException_SerLevel_SerLevel_ARRAYSIZE = NavigationException_SerLevel_SerLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavigationException_SerLevel_descriptor();
template<typename T>
inline const std::string& NavigationException_SerLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavigationException_SerLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavigationException_SerLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavigationException_SerLevel_descriptor(), enum_t_value);
}
inline bool NavigationException_SerLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NavigationException_SerLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavigationException_SerLevel>(
    NavigationException_SerLevel_descriptor(), name, value);
}
// ===================================================================

class NavigationMotionPlanReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.NavigationMotionPlanReq) */ {
 public:
  inline NavigationMotionPlanReq() : NavigationMotionPlanReq(nullptr) {}
  virtual ~NavigationMotionPlanReq();

  NavigationMotionPlanReq(const NavigationMotionPlanReq& from);
  NavigationMotionPlanReq(NavigationMotionPlanReq&& from) noexcept
    : NavigationMotionPlanReq() {
    *this = ::std::move(from);
  }

  inline NavigationMotionPlanReq& operator=(const NavigationMotionPlanReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationMotionPlanReq& operator=(NavigationMotionPlanReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationMotionPlanReq& default_instance();

  static inline const NavigationMotionPlanReq* internal_default_instance() {
    return reinterpret_cast<const NavigationMotionPlanReq*>(
               &_NavigationMotionPlanReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NavigationMotionPlanReq& a, NavigationMotionPlanReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationMotionPlanReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationMotionPlanReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationMotionPlanReq* New() const final {
    return CreateMaybeMessage<NavigationMotionPlanReq>(nullptr);
  }

  NavigationMotionPlanReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationMotionPlanReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationMotionPlanReq& from);
  void MergeFrom(const NavigationMotionPlanReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationMotionPlanReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.NavigationMotionPlanReq";
  }
  protected:
  explicit NavigationMotionPlanReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoalStateFieldNumber = 1,
    kDisableCollisionCheckFieldNumber = 3,
    kOminiPlanFieldNumber = 4,
  };
  // .galbot.aphropm_proto.RobotStates goal_state = 1;
  bool has_goal_state() const;
  private:
  bool _internal_has_goal_state() const;
  public:
  void clear_goal_state();
  const ::galbot::aphropm_proto::RobotStates& goal_state() const;
  ::galbot::aphropm_proto::RobotStates* release_goal_state();
  ::galbot::aphropm_proto::RobotStates* mutable_goal_state();
  void set_allocated_goal_state(::galbot::aphropm_proto::RobotStates* goal_state);
  private:
  const ::galbot::aphropm_proto::RobotStates& _internal_goal_state() const;
  ::galbot::aphropm_proto::RobotStates* _internal_mutable_goal_state();
  public:
  void unsafe_arena_set_allocated_goal_state(
      ::galbot::aphropm_proto::RobotStates* goal_state);
  ::galbot::aphropm_proto::RobotStates* unsafe_arena_release_goal_state();

  // bool disable_collision_check = 3;
  void clear_disable_collision_check();
  bool disable_collision_check() const;
  void set_disable_collision_check(bool value);
  private:
  bool _internal_disable_collision_check() const;
  void _internal_set_disable_collision_check(bool value);
  public:

  // bool omini_plan = 4;
  void clear_omini_plan();
  bool omini_plan() const;
  void set_omini_plan(bool value);
  private:
  bool _internal_omini_plan() const;
  void _internal_set_omini_plan(bool value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.NavigationMotionPlanReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::RobotStates* goal_state_;
  bool disable_collision_check_;
  bool omini_plan_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class LoadEnvReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.LoadEnvReq) */ {
 public:
  inline LoadEnvReq() : LoadEnvReq(nullptr) {}
  virtual ~LoadEnvReq();

  LoadEnvReq(const LoadEnvReq& from);
  LoadEnvReq(LoadEnvReq&& from) noexcept
    : LoadEnvReq() {
    *this = ::std::move(from);
  }

  inline LoadEnvReq& operator=(const LoadEnvReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadEnvReq& operator=(LoadEnvReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoadEnvReq& default_instance();

  static inline const LoadEnvReq* internal_default_instance() {
    return reinterpret_cast<const LoadEnvReq*>(
               &_LoadEnvReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoadEnvReq& a, LoadEnvReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadEnvReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadEnvReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadEnvReq* New() const final {
    return CreateMaybeMessage<LoadEnvReq>(nullptr);
  }

  LoadEnvReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadEnvReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoadEnvReq& from);
  void MergeFrom(const LoadEnvReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadEnvReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.LoadEnvReq";
  }
  protected:
  explicit LoadEnvReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LoadEnvReq_EnvType EnvType;
  static constexpr EnvType PointCloud =
    LoadEnvReq_EnvType_PointCloud;
  static constexpr EnvType ESDF =
    LoadEnvReq_EnvType_ESDF;
  static inline bool EnvType_IsValid(int value) {
    return LoadEnvReq_EnvType_IsValid(value);
  }
  static constexpr EnvType EnvType_MIN =
    LoadEnvReq_EnvType_EnvType_MIN;
  static constexpr EnvType EnvType_MAX =
    LoadEnvReq_EnvType_EnvType_MAX;
  static constexpr int EnvType_ARRAYSIZE =
    LoadEnvReq_EnvType_EnvType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EnvType_descriptor() {
    return LoadEnvReq_EnvType_descriptor();
  }
  template<typename T>
  static inline const std::string& EnvType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnvType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnvType_Name.");
    return LoadEnvReq_EnvType_Name(enum_t_value);
  }
  static inline bool EnvType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnvType* value) {
    return LoadEnvReq_EnvType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvFilePathFieldNumber = 2,
    kSaveFilePathFieldNumber = 3,
    kResolutionFieldNumber = 4,
    kEnvTypeFieldNumber = 1,
  };
  // string env_file_path = 2;
  void clear_env_file_path();
  const std::string& env_file_path() const;
  void set_env_file_path(const std::string& value);
  void set_env_file_path(std::string&& value);
  void set_env_file_path(const char* value);
  void set_env_file_path(const char* value, size_t size);
  std::string* mutable_env_file_path();
  std::string* release_env_file_path();
  void set_allocated_env_file_path(std::string* env_file_path);
  private:
  const std::string& _internal_env_file_path() const;
  void _internal_set_env_file_path(const std::string& value);
  std::string* _internal_mutable_env_file_path();
  public:

  // string save_file_path = 3;
  void clear_save_file_path();
  const std::string& save_file_path() const;
  void set_save_file_path(const std::string& value);
  void set_save_file_path(std::string&& value);
  void set_save_file_path(const char* value);
  void set_save_file_path(const char* value, size_t size);
  std::string* mutable_save_file_path();
  std::string* release_save_file_path();
  void set_allocated_save_file_path(std::string* save_file_path);
  private:
  const std::string& _internal_save_file_path() const;
  void _internal_set_save_file_path(const std::string& value);
  std::string* _internal_mutable_save_file_path();
  public:

  // double resolution = 4;
  void clear_resolution();
  double resolution() const;
  void set_resolution(double value);
  private:
  double _internal_resolution() const;
  void _internal_set_resolution(double value);
  public:

  // .galbot.aphropm_proto.LoadEnvReq.EnvType env_type = 1;
  void clear_env_type();
  ::galbot::aphropm_proto::LoadEnvReq_EnvType env_type() const;
  void set_env_type(::galbot::aphropm_proto::LoadEnvReq_EnvType value);
  private:
  ::galbot::aphropm_proto::LoadEnvReq_EnvType _internal_env_type() const;
  void _internal_set_env_type(::galbot::aphropm_proto::LoadEnvReq_EnvType value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.LoadEnvReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr env_file_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr save_file_path_;
  double resolution_;
  int env_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class EvaluateGoalAvailabilityReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.EvaluateGoalAvailabilityReq) */ {
 public:
  inline EvaluateGoalAvailabilityReq() : EvaluateGoalAvailabilityReq(nullptr) {}
  virtual ~EvaluateGoalAvailabilityReq();

  EvaluateGoalAvailabilityReq(const EvaluateGoalAvailabilityReq& from);
  EvaluateGoalAvailabilityReq(EvaluateGoalAvailabilityReq&& from) noexcept
    : EvaluateGoalAvailabilityReq() {
    *this = ::std::move(from);
  }

  inline EvaluateGoalAvailabilityReq& operator=(const EvaluateGoalAvailabilityReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvaluateGoalAvailabilityReq& operator=(EvaluateGoalAvailabilityReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EvaluateGoalAvailabilityReq& default_instance();

  static inline const EvaluateGoalAvailabilityReq* internal_default_instance() {
    return reinterpret_cast<const EvaluateGoalAvailabilityReq*>(
               &_EvaluateGoalAvailabilityReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EvaluateGoalAvailabilityReq& a, EvaluateGoalAvailabilityReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EvaluateGoalAvailabilityReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvaluateGoalAvailabilityReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EvaluateGoalAvailabilityReq* New() const final {
    return CreateMaybeMessage<EvaluateGoalAvailabilityReq>(nullptr);
  }

  EvaluateGoalAvailabilityReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EvaluateGoalAvailabilityReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EvaluateGoalAvailabilityReq& from);
  void MergeFrom(const EvaluateGoalAvailabilityReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvaluateGoalAvailabilityReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.EvaluateGoalAvailabilityReq";
  }
  protected:
  explicit EvaluateGoalAvailabilityReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartStateFieldNumber = 1,
    kGoalStateFieldNumber = 2,
    kUseStartStateFieldNumber = 3,
  };
  // .galbot.aphropm_proto.RobotStates start_state = 1;
  bool has_start_state() const;
  private:
  bool _internal_has_start_state() const;
  public:
  void clear_start_state();
  const ::galbot::aphropm_proto::RobotStates& start_state() const;
  ::galbot::aphropm_proto::RobotStates* release_start_state();
  ::galbot::aphropm_proto::RobotStates* mutable_start_state();
  void set_allocated_start_state(::galbot::aphropm_proto::RobotStates* start_state);
  private:
  const ::galbot::aphropm_proto::RobotStates& _internal_start_state() const;
  ::galbot::aphropm_proto::RobotStates* _internal_mutable_start_state();
  public:
  void unsafe_arena_set_allocated_start_state(
      ::galbot::aphropm_proto::RobotStates* start_state);
  ::galbot::aphropm_proto::RobotStates* unsafe_arena_release_start_state();

  // .galbot.aphropm_proto.RobotStates goal_state = 2;
  bool has_goal_state() const;
  private:
  bool _internal_has_goal_state() const;
  public:
  void clear_goal_state();
  const ::galbot::aphropm_proto::RobotStates& goal_state() const;
  ::galbot::aphropm_proto::RobotStates* release_goal_state();
  ::galbot::aphropm_proto::RobotStates* mutable_goal_state();
  void set_allocated_goal_state(::galbot::aphropm_proto::RobotStates* goal_state);
  private:
  const ::galbot::aphropm_proto::RobotStates& _internal_goal_state() const;
  ::galbot::aphropm_proto::RobotStates* _internal_mutable_goal_state();
  public:
  void unsafe_arena_set_allocated_goal_state(
      ::galbot::aphropm_proto::RobotStates* goal_state);
  ::galbot::aphropm_proto::RobotStates* unsafe_arena_release_goal_state();

  // bool use_start_state = 3;
  void clear_use_start_state();
  bool use_start_state() const;
  void set_use_start_state(bool value);
  private:
  bool _internal_use_start_state() const;
  void _internal_set_use_start_state(bool value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.EvaluateGoalAvailabilityReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::RobotStates* start_state_;
  ::galbot::aphropm_proto::RobotStates* goal_state_;
  bool use_start_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class StopNavigationReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.StopNavigationReq) */ {
 public:
  inline StopNavigationReq() : StopNavigationReq(nullptr) {}
  virtual ~StopNavigationReq();

  StopNavigationReq(const StopNavigationReq& from);
  StopNavigationReq(StopNavigationReq&& from) noexcept
    : StopNavigationReq() {
    *this = ::std::move(from);
  }

  inline StopNavigationReq& operator=(const StopNavigationReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopNavigationReq& operator=(StopNavigationReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopNavigationReq& default_instance();

  static inline const StopNavigationReq* internal_default_instance() {
    return reinterpret_cast<const StopNavigationReq*>(
               &_StopNavigationReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StopNavigationReq& a, StopNavigationReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StopNavigationReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopNavigationReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopNavigationReq* New() const final {
    return CreateMaybeMessage<StopNavigationReq>(nullptr);
  }

  StopNavigationReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopNavigationReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopNavigationReq& from);
  void MergeFrom(const StopNavigationReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopNavigationReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.StopNavigationReq";
  }
  protected:
  explicit StopNavigationReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.StopNavigationReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class MoveTrajectoryReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.MoveTrajectoryReq) */ {
 public:
  inline MoveTrajectoryReq() : MoveTrajectoryReq(nullptr) {}
  virtual ~MoveTrajectoryReq();

  MoveTrajectoryReq(const MoveTrajectoryReq& from);
  MoveTrajectoryReq(MoveTrajectoryReq&& from) noexcept
    : MoveTrajectoryReq() {
    *this = ::std::move(from);
  }

  inline MoveTrajectoryReq& operator=(const MoveTrajectoryReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveTrajectoryReq& operator=(MoveTrajectoryReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveTrajectoryReq& default_instance();

  static inline const MoveTrajectoryReq* internal_default_instance() {
    return reinterpret_cast<const MoveTrajectoryReq*>(
               &_MoveTrajectoryReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MoveTrajectoryReq& a, MoveTrajectoryReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveTrajectoryReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveTrajectoryReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveTrajectoryReq* New() const final {
    return CreateMaybeMessage<MoveTrajectoryReq>(nullptr);
  }

  MoveTrajectoryReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveTrajectoryReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveTrajectoryReq& from);
  void MergeFrom(const MoveTrajectoryReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveTrajectoryReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.MoveTrajectoryReq";
  }
  protected:
  explicit MoveTrajectoryReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MoveTrajectoryReq_HeadingDirection HeadingDirection;
  static constexpr HeadingDirection Origin =
    MoveTrajectoryReq_HeadingDirection_Origin;
  static constexpr HeadingDirection Heading =
    MoveTrajectoryReq_HeadingDirection_Heading;
  static constexpr HeadingDirection Omni =
    MoveTrajectoryReq_HeadingDirection_Omni;
  static inline bool HeadingDirection_IsValid(int value) {
    return MoveTrajectoryReq_HeadingDirection_IsValid(value);
  }
  static constexpr HeadingDirection HeadingDirection_MIN =
    MoveTrajectoryReq_HeadingDirection_HeadingDirection_MIN;
  static constexpr HeadingDirection HeadingDirection_MAX =
    MoveTrajectoryReq_HeadingDirection_HeadingDirection_MAX;
  static constexpr int HeadingDirection_ARRAYSIZE =
    MoveTrajectoryReq_HeadingDirection_HeadingDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HeadingDirection_descriptor() {
    return MoveTrajectoryReq_HeadingDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& HeadingDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HeadingDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HeadingDirection_Name.");
    return MoveTrajectoryReq_HeadingDirection_Name(enum_t_value);
  }
  static inline bool HeadingDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HeadingDirection* value) {
    return MoveTrajectoryReq_HeadingDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoryFieldNumber = 1,
    kPlanTrajFieldNumber = 10,
    kOptimizeTrajFieldNumber = 11,
    kCheckValidFieldNumber = 12,
    kHeadingDirectionFieldNumber = 20,
  };
  // .galbot.aphropm_proto.RobotTrajectory trajectory = 1;
  bool has_trajectory() const;
  private:
  bool _internal_has_trajectory() const;
  public:
  void clear_trajectory();
  const ::galbot::aphropm_proto::RobotTrajectory& trajectory() const;
  ::galbot::aphropm_proto::RobotTrajectory* release_trajectory();
  ::galbot::aphropm_proto::RobotTrajectory* mutable_trajectory();
  void set_allocated_trajectory(::galbot::aphropm_proto::RobotTrajectory* trajectory);
  private:
  const ::galbot::aphropm_proto::RobotTrajectory& _internal_trajectory() const;
  ::galbot::aphropm_proto::RobotTrajectory* _internal_mutable_trajectory();
  public:
  void unsafe_arena_set_allocated_trajectory(
      ::galbot::aphropm_proto::RobotTrajectory* trajectory);
  ::galbot::aphropm_proto::RobotTrajectory* unsafe_arena_release_trajectory();

  // bool plan_traj = 10;
  void clear_plan_traj();
  bool plan_traj() const;
  void set_plan_traj(bool value);
  private:
  bool _internal_plan_traj() const;
  void _internal_set_plan_traj(bool value);
  public:

  // bool optimize_traj = 11;
  void clear_optimize_traj();
  bool optimize_traj() const;
  void set_optimize_traj(bool value);
  private:
  bool _internal_optimize_traj() const;
  void _internal_set_optimize_traj(bool value);
  public:

  // bool check_valid = 12;
  void clear_check_valid();
  bool check_valid() const;
  void set_check_valid(bool value);
  private:
  bool _internal_check_valid() const;
  void _internal_set_check_valid(bool value);
  public:

  // .galbot.aphropm_proto.MoveTrajectoryReq.HeadingDirection heading_direction = 20;
  void clear_heading_direction();
  ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection heading_direction() const;
  void set_heading_direction(::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection value);
  private:
  ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection _internal_heading_direction() const;
  void _internal_set_heading_direction(::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.MoveTrajectoryReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::RobotTrajectory* trajectory_;
  bool plan_traj_;
  bool optimize_traj_;
  bool check_valid_;
  int heading_direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class NavigationRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.NavigationRequest) */ {
 public:
  inline NavigationRequest() : NavigationRequest(nullptr) {}
  virtual ~NavigationRequest();

  NavigationRequest(const NavigationRequest& from);
  NavigationRequest(NavigationRequest&& from) noexcept
    : NavigationRequest() {
    *this = ::std::move(from);
  }

  inline NavigationRequest& operator=(const NavigationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationRequest& operator=(NavigationRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationRequest& default_instance();

  enum RequestTypeCase {
    kMotionPlan = 2,
    kLoadEnvReq = 3,
    kStopNavigationReq = 4,
    kEvaluateGoalAvailabilityReq = 5,
    kMoveTrajectoryReq = 6,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const NavigationRequest* internal_default_instance() {
    return reinterpret_cast<const NavigationRequest*>(
               &_NavigationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NavigationRequest& a, NavigationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationRequest* New() const final {
    return CreateMaybeMessage<NavigationRequest>(nullptr);
  }

  NavigationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationRequest& from);
  void MergeFrom(const NavigationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.NavigationRequest";
  }
  protected:
  explicit NavigationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kMotionPlanFieldNumber = 2,
    kLoadEnvReqFieldNumber = 3,
    kStopNavigationReqFieldNumber = 4,
    kEvaluateGoalAvailabilityReqFieldNumber = 5,
    kMoveTrajectoryReqFieldNumber = 6,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .galbot.aphropm_proto.NavigationMotionPlanReq motion_plan = 2;
  bool has_motion_plan() const;
  private:
  bool _internal_has_motion_plan() const;
  public:
  void clear_motion_plan();
  const ::galbot::aphropm_proto::NavigationMotionPlanReq& motion_plan() const;
  ::galbot::aphropm_proto::NavigationMotionPlanReq* release_motion_plan();
  ::galbot::aphropm_proto::NavigationMotionPlanReq* mutable_motion_plan();
  void set_allocated_motion_plan(::galbot::aphropm_proto::NavigationMotionPlanReq* motion_plan);
  private:
  const ::galbot::aphropm_proto::NavigationMotionPlanReq& _internal_motion_plan() const;
  ::galbot::aphropm_proto::NavigationMotionPlanReq* _internal_mutable_motion_plan();
  public:
  void unsafe_arena_set_allocated_motion_plan(
      ::galbot::aphropm_proto::NavigationMotionPlanReq* motion_plan);
  ::galbot::aphropm_proto::NavigationMotionPlanReq* unsafe_arena_release_motion_plan();

  // .galbot.aphropm_proto.LoadEnvReq load_env_req = 3;
  bool has_load_env_req() const;
  private:
  bool _internal_has_load_env_req() const;
  public:
  void clear_load_env_req();
  const ::galbot::aphropm_proto::LoadEnvReq& load_env_req() const;
  ::galbot::aphropm_proto::LoadEnvReq* release_load_env_req();
  ::galbot::aphropm_proto::LoadEnvReq* mutable_load_env_req();
  void set_allocated_load_env_req(::galbot::aphropm_proto::LoadEnvReq* load_env_req);
  private:
  const ::galbot::aphropm_proto::LoadEnvReq& _internal_load_env_req() const;
  ::galbot::aphropm_proto::LoadEnvReq* _internal_mutable_load_env_req();
  public:
  void unsafe_arena_set_allocated_load_env_req(
      ::galbot::aphropm_proto::LoadEnvReq* load_env_req);
  ::galbot::aphropm_proto::LoadEnvReq* unsafe_arena_release_load_env_req();

  // .galbot.aphropm_proto.StopNavigationReq stop_navigation_req = 4;
  bool has_stop_navigation_req() const;
  private:
  bool _internal_has_stop_navigation_req() const;
  public:
  void clear_stop_navigation_req();
  const ::galbot::aphropm_proto::StopNavigationReq& stop_navigation_req() const;
  ::galbot::aphropm_proto::StopNavigationReq* release_stop_navigation_req();
  ::galbot::aphropm_proto::StopNavigationReq* mutable_stop_navigation_req();
  void set_allocated_stop_navigation_req(::galbot::aphropm_proto::StopNavigationReq* stop_navigation_req);
  private:
  const ::galbot::aphropm_proto::StopNavigationReq& _internal_stop_navigation_req() const;
  ::galbot::aphropm_proto::StopNavigationReq* _internal_mutable_stop_navigation_req();
  public:
  void unsafe_arena_set_allocated_stop_navigation_req(
      ::galbot::aphropm_proto::StopNavigationReq* stop_navigation_req);
  ::galbot::aphropm_proto::StopNavigationReq* unsafe_arena_release_stop_navigation_req();

  // .galbot.aphropm_proto.EvaluateGoalAvailabilityReq evaluate_goal_availability_req = 5;
  bool has_evaluate_goal_availability_req() const;
  private:
  bool _internal_has_evaluate_goal_availability_req() const;
  public:
  void clear_evaluate_goal_availability_req();
  const ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq& evaluate_goal_availability_req() const;
  ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* release_evaluate_goal_availability_req();
  ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* mutable_evaluate_goal_availability_req();
  void set_allocated_evaluate_goal_availability_req(::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* evaluate_goal_availability_req);
  private:
  const ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq& _internal_evaluate_goal_availability_req() const;
  ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* _internal_mutable_evaluate_goal_availability_req();
  public:
  void unsafe_arena_set_allocated_evaluate_goal_availability_req(
      ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* evaluate_goal_availability_req);
  ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* unsafe_arena_release_evaluate_goal_availability_req();

  // .galbot.aphropm_proto.MoveTrajectoryReq move_trajectory_req = 6;
  bool has_move_trajectory_req() const;
  private:
  bool _internal_has_move_trajectory_req() const;
  public:
  void clear_move_trajectory_req();
  const ::galbot::aphropm_proto::MoveTrajectoryReq& move_trajectory_req() const;
  ::galbot::aphropm_proto::MoveTrajectoryReq* release_move_trajectory_req();
  ::galbot::aphropm_proto::MoveTrajectoryReq* mutable_move_trajectory_req();
  void set_allocated_move_trajectory_req(::galbot::aphropm_proto::MoveTrajectoryReq* move_trajectory_req);
  private:
  const ::galbot::aphropm_proto::MoveTrajectoryReq& _internal_move_trajectory_req() const;
  ::galbot::aphropm_proto::MoveTrajectoryReq* _internal_mutable_move_trajectory_req();
  public:
  void unsafe_arena_set_allocated_move_trajectory_req(
      ::galbot::aphropm_proto::MoveTrajectoryReq* move_trajectory_req);
  ::galbot::aphropm_proto::MoveTrajectoryReq* unsafe_arena_release_move_trajectory_req();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.NavigationRequest)
 private:
  class _Internal;
  void set_has_motion_plan();
  void set_has_load_env_req();
  void set_has_stop_navigation_req();
  void set_has_evaluate_goal_availability_req();
  void set_has_move_trajectory_req();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  union RequestTypeUnion {
    RequestTypeUnion() {}
    ::galbot::aphropm_proto::NavigationMotionPlanReq* motion_plan_;
    ::galbot::aphropm_proto::LoadEnvReq* load_env_req_;
    ::galbot::aphropm_proto::StopNavigationReq* stop_navigation_req_;
    ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* evaluate_goal_availability_req_;
    ::galbot::aphropm_proto::MoveTrajectoryReq* move_trajectory_req_;
  } request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class NavigationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.NavigationResponse) */ {
 public:
  inline NavigationResponse() : NavigationResponse(nullptr) {}
  virtual ~NavigationResponse();

  NavigationResponse(const NavigationResponse& from);
  NavigationResponse(NavigationResponse&& from) noexcept
    : NavigationResponse() {
    *this = ::std::move(from);
  }

  inline NavigationResponse& operator=(const NavigationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationResponse& operator=(NavigationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationResponse& default_instance();

  static inline const NavigationResponse* internal_default_instance() {
    return reinterpret_cast<const NavigationResponse*>(
               &_NavigationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NavigationResponse& a, NavigationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationResponse* New() const final {
    return CreateMaybeMessage<NavigationResponse>(nullptr);
  }

  NavigationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationResponse& from);
  void MergeFrom(const NavigationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.NavigationResponse";
  }
  protected:
  explicit NavigationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NavigationResponse_Status Status;
  static constexpr Status UNKNOWN =
    NavigationResponse_Status_UNKNOWN;
  static constexpr Status SUCCESS =
    NavigationResponse_Status_SUCCESS;
  static constexpr Status FAILED =
    NavigationResponse_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return NavigationResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    NavigationResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    NavigationResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    NavigationResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return NavigationResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return NavigationResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return NavigationResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .galbot.aphropm_proto.NavigationResponse.Status status = 2;
  void clear_status();
  ::galbot::aphropm_proto::NavigationResponse_Status status() const;
  void set_status(::galbot::aphropm_proto::NavigationResponse_Status value);
  private:
  ::galbot::aphropm_proto::NavigationResponse_Status _internal_status() const;
  void _internal_set_status(::galbot::aphropm_proto::NavigationResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.NavigationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class NavigationResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.NavigationResult) */ {
 public:
  inline NavigationResult() : NavigationResult(nullptr) {}
  virtual ~NavigationResult();

  NavigationResult(const NavigationResult& from);
  NavigationResult(NavigationResult&& from) noexcept
    : NavigationResult() {
    *this = ::std::move(from);
  }

  inline NavigationResult& operator=(const NavigationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationResult& operator=(NavigationResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationResult& default_instance();

  static inline const NavigationResult* internal_default_instance() {
    return reinterpret_cast<const NavigationResult*>(
               &_NavigationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NavigationResult& a, NavigationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationResult* New() const final {
    return CreateMaybeMessage<NavigationResult>(nullptr);
  }

  NavigationResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationResult& from);
  void MergeFrom(const NavigationResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.NavigationResult";
  }
  protected:
  explicit NavigationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NavigationResult_TaskStatus TaskStatus;
  static constexpr TaskStatus UNKNOWN =
    NavigationResult_TaskStatus_UNKNOWN;
  static constexpr TaskStatus RUNNING =
    NavigationResult_TaskStatus_RUNNING;
  static constexpr TaskStatus SUCCESS =
    NavigationResult_TaskStatus_SUCCESS;
  static constexpr TaskStatus FAILED =
    NavigationResult_TaskStatus_FAILED;
  static inline bool TaskStatus_IsValid(int value) {
    return NavigationResult_TaskStatus_IsValid(value);
  }
  static constexpr TaskStatus TaskStatus_MIN =
    NavigationResult_TaskStatus_TaskStatus_MIN;
  static constexpr TaskStatus TaskStatus_MAX =
    NavigationResult_TaskStatus_TaskStatus_MAX;
  static constexpr int TaskStatus_ARRAYSIZE =
    NavigationResult_TaskStatus_TaskStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskStatus_descriptor() {
    return NavigationResult_TaskStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskStatus_Name.");
    return NavigationResult_TaskStatus_Name(enum_t_value);
  }
  static inline bool TaskStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskStatus* value) {
    return NavigationResult_TaskStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .galbot.aphropm_proto.NavigationResult.TaskStatus status = 2;
  void clear_status();
  ::galbot::aphropm_proto::NavigationResult_TaskStatus status() const;
  void set_status(::galbot::aphropm_proto::NavigationResult_TaskStatus value);
  private:
  ::galbot::aphropm_proto::NavigationResult_TaskStatus _internal_status() const;
  void _internal_set_status(::galbot::aphropm_proto::NavigationResult_TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.NavigationResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class NavigationException PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.NavigationException) */ {
 public:
  inline NavigationException() : NavigationException(nullptr) {}
  virtual ~NavigationException();

  NavigationException(const NavigationException& from);
  NavigationException(NavigationException&& from) noexcept
    : NavigationException() {
    *this = ::std::move(from);
  }

  inline NavigationException& operator=(const NavigationException& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationException& operator=(NavigationException&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationException& default_instance();

  static inline const NavigationException* internal_default_instance() {
    return reinterpret_cast<const NavigationException*>(
               &_NavigationException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NavigationException& a, NavigationException& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationException* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationException* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationException* New() const final {
    return CreateMaybeMessage<NavigationException>(nullptr);
  }

  NavigationException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationException>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationException& from);
  void MergeFrom(const NavigationException& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationException* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.NavigationException";
  }
  protected:
  explicit NavigationException(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NavigationException_Exception Exception;
  static constexpr Exception UNKNOWN =
    NavigationException_Exception_UNKNOWN;
  static constexpr Exception INIT_FAIL =
    NavigationException_Exception_INIT_FAIL;
  static inline bool Exception_IsValid(int value) {
    return NavigationException_Exception_IsValid(value);
  }
  static constexpr Exception Exception_MIN =
    NavigationException_Exception_Exception_MIN;
  static constexpr Exception Exception_MAX =
    NavigationException_Exception_Exception_MAX;
  static constexpr int Exception_ARRAYSIZE =
    NavigationException_Exception_Exception_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Exception_descriptor() {
    return NavigationException_Exception_descriptor();
  }
  template<typename T>
  static inline const std::string& Exception_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Exception>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Exception_Name.");
    return NavigationException_Exception_Name(enum_t_value);
  }
  static inline bool Exception_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Exception* value) {
    return NavigationException_Exception_Parse(name, value);
  }

  typedef NavigationException_SerLevel SerLevel;
  static constexpr SerLevel CRITICAL =
    NavigationException_SerLevel_CRITICAL;
  static constexpr SerLevel NORMAL =
    NavigationException_SerLevel_NORMAL;
  static inline bool SerLevel_IsValid(int value) {
    return NavigationException_SerLevel_IsValid(value);
  }
  static constexpr SerLevel SerLevel_MIN =
    NavigationException_SerLevel_SerLevel_MIN;
  static constexpr SerLevel SerLevel_MAX =
    NavigationException_SerLevel_SerLevel_MAX;
  static constexpr int SerLevel_ARRAYSIZE =
    NavigationException_SerLevel_SerLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SerLevel_descriptor() {
    return NavigationException_SerLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& SerLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SerLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SerLevel_Name.");
    return NavigationException_SerLevel_Name(enum_t_value);
  }
  static inline bool SerLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SerLevel* value) {
    return NavigationException_SerLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrMsgFieldNumber = 11,
    kExceptionFieldNumber = 3,
    kLevelFieldNumber = 4,
    kErrCodeFieldNumber = 10,
  };
  // string err_msg = 11;
  void clear_err_msg();
  const std::string& err_msg() const;
  void set_err_msg(const std::string& value);
  void set_err_msg(std::string&& value);
  void set_err_msg(const char* value);
  void set_err_msg(const char* value, size_t size);
  std::string* mutable_err_msg();
  std::string* release_err_msg();
  void set_allocated_err_msg(std::string* err_msg);
  private:
  const std::string& _internal_err_msg() const;
  void _internal_set_err_msg(const std::string& value);
  std::string* _internal_mutable_err_msg();
  public:

  // .galbot.aphropm_proto.NavigationException.Exception exception = 3;
  void clear_exception();
  ::galbot::aphropm_proto::NavigationException_Exception exception() const;
  void set_exception(::galbot::aphropm_proto::NavigationException_Exception value);
  private:
  ::galbot::aphropm_proto::NavigationException_Exception _internal_exception() const;
  void _internal_set_exception(::galbot::aphropm_proto::NavigationException_Exception value);
  public:

  // .galbot.aphropm_proto.NavigationException.SerLevel level = 4;
  void clear_level();
  ::galbot::aphropm_proto::NavigationException_SerLevel level() const;
  void set_level(::galbot::aphropm_proto::NavigationException_SerLevel value);
  private:
  ::galbot::aphropm_proto::NavigationException_SerLevel _internal_level() const;
  void _internal_set_level(::galbot::aphropm_proto::NavigationException_SerLevel value);
  public:

  // int32 err_code = 10;
  void clear_err_code();
  ::PROTOBUF_NAMESPACE_ID::int32 err_code() const;
  void set_err_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_err_code() const;
  void _internal_set_err_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.NavigationException)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr err_msg_;
  int exception_;
  int level_;
  ::PROTOBUF_NAMESPACE_ID::int32 err_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class PoseAvailability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.PoseAvailability) */ {
 public:
  inline PoseAvailability() : PoseAvailability(nullptr) {}
  virtual ~PoseAvailability();

  PoseAvailability(const PoseAvailability& from);
  PoseAvailability(PoseAvailability&& from) noexcept
    : PoseAvailability() {
    *this = ::std::move(from);
  }

  inline PoseAvailability& operator=(const PoseAvailability& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseAvailability& operator=(PoseAvailability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PoseAvailability& default_instance();

  static inline const PoseAvailability* internal_default_instance() {
    return reinterpret_cast<const PoseAvailability*>(
               &_PoseAvailability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PoseAvailability& a, PoseAvailability& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseAvailability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseAvailability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PoseAvailability* New() const final {
    return CreateMaybeMessage<PoseAvailability>(nullptr);
  }

  PoseAvailability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PoseAvailability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PoseAvailability& from);
  void MergeFrom(const PoseAvailability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseAvailability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.PoseAvailability";
  }
  protected:
  explicit PoseAvailability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradFieldNumber = 3,
    kDistanceFieldNumber = 2,
    kAvailableFieldNumber = 1,
  };
  // repeated double grad = 3;
  int grad_size() const;
  private:
  int _internal_grad_size() const;
  public:
  void clear_grad();
  private:
  double _internal_grad(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_grad() const;
  void _internal_add_grad(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_grad();
  public:
  double grad(int index) const;
  void set_grad(int index, double value);
  void add_grad(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      grad() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_grad();

  // double distance = 2;
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // bool available = 1;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.PoseAvailability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > grad_;
  mutable std::atomic<int> _grad_cached_byte_size_;
  double distance_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// -------------------------------------------------------------------

class EvaluateGoalAvailabilityResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse) */ {
 public:
  inline EvaluateGoalAvailabilityResponse() : EvaluateGoalAvailabilityResponse(nullptr) {}
  virtual ~EvaluateGoalAvailabilityResponse();

  EvaluateGoalAvailabilityResponse(const EvaluateGoalAvailabilityResponse& from);
  EvaluateGoalAvailabilityResponse(EvaluateGoalAvailabilityResponse&& from) noexcept
    : EvaluateGoalAvailabilityResponse() {
    *this = ::std::move(from);
  }

  inline EvaluateGoalAvailabilityResponse& operator=(const EvaluateGoalAvailabilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvaluateGoalAvailabilityResponse& operator=(EvaluateGoalAvailabilityResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EvaluateGoalAvailabilityResponse& default_instance();

  static inline const EvaluateGoalAvailabilityResponse* internal_default_instance() {
    return reinterpret_cast<const EvaluateGoalAvailabilityResponse*>(
               &_EvaluateGoalAvailabilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EvaluateGoalAvailabilityResponse& a, EvaluateGoalAvailabilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EvaluateGoalAvailabilityResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvaluateGoalAvailabilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EvaluateGoalAvailabilityResponse* New() const final {
    return CreateMaybeMessage<EvaluateGoalAvailabilityResponse>(nullptr);
  }

  EvaluateGoalAvailabilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EvaluateGoalAvailabilityResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EvaluateGoalAvailabilityResponse& from);
  void MergeFrom(const EvaluateGoalAvailabilityResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvaluateGoalAvailabilityResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.EvaluateGoalAvailabilityResponse";
  }
  protected:
  explicit EvaluateGoalAvailabilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kStartPoseFieldNumber = 2,
    kGoalPoseFieldNumber = 3,
    kHasSolutionFieldNumber = 4,
    kPathCollisionFieldNumber = 5,
    kAvailableFieldNumber = 6,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // .galbot.aphropm_proto.PoseAvailability start_pose = 2;
  bool has_start_pose() const;
  private:
  bool _internal_has_start_pose() const;
  public:
  void clear_start_pose();
  const ::galbot::aphropm_proto::PoseAvailability& start_pose() const;
  ::galbot::aphropm_proto::PoseAvailability* release_start_pose();
  ::galbot::aphropm_proto::PoseAvailability* mutable_start_pose();
  void set_allocated_start_pose(::galbot::aphropm_proto::PoseAvailability* start_pose);
  private:
  const ::galbot::aphropm_proto::PoseAvailability& _internal_start_pose() const;
  ::galbot::aphropm_proto::PoseAvailability* _internal_mutable_start_pose();
  public:
  void unsafe_arena_set_allocated_start_pose(
      ::galbot::aphropm_proto::PoseAvailability* start_pose);
  ::galbot::aphropm_proto::PoseAvailability* unsafe_arena_release_start_pose();

  // .galbot.aphropm_proto.PoseAvailability goal_pose = 3;
  bool has_goal_pose() const;
  private:
  bool _internal_has_goal_pose() const;
  public:
  void clear_goal_pose();
  const ::galbot::aphropm_proto::PoseAvailability& goal_pose() const;
  ::galbot::aphropm_proto::PoseAvailability* release_goal_pose();
  ::galbot::aphropm_proto::PoseAvailability* mutable_goal_pose();
  void set_allocated_goal_pose(::galbot::aphropm_proto::PoseAvailability* goal_pose);
  private:
  const ::galbot::aphropm_proto::PoseAvailability& _internal_goal_pose() const;
  ::galbot::aphropm_proto::PoseAvailability* _internal_mutable_goal_pose();
  public:
  void unsafe_arena_set_allocated_goal_pose(
      ::galbot::aphropm_proto::PoseAvailability* goal_pose);
  ::galbot::aphropm_proto::PoseAvailability* unsafe_arena_release_goal_pose();

  // bool has_solution = 4;
  void clear_has_solution();
  bool has_solution() const;
  void set_has_solution(bool value);
  private:
  bool _internal_has_solution() const;
  void _internal_set_has_solution(bool value);
  public:

  // bool path_collision = 5;
  void clear_path_collision();
  bool path_collision() const;
  void set_path_collision(bool value);
  private:
  bool _internal_path_collision() const;
  void _internal_set_path_collision(bool value);
  public:

  // bool available = 6;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::galbot::aphropm_proto::PoseAvailability* start_pose_;
  ::galbot::aphropm_proto::PoseAvailability* goal_pose_;
  bool has_solution_;
  bool path_collision_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NavigationMotionPlanReq

// .galbot.aphropm_proto.RobotStates goal_state = 1;
inline bool NavigationMotionPlanReq::_internal_has_goal_state() const {
  return this != internal_default_instance() && goal_state_ != nullptr;
}
inline bool NavigationMotionPlanReq::has_goal_state() const {
  return _internal_has_goal_state();
}
inline const ::galbot::aphropm_proto::RobotStates& NavigationMotionPlanReq::_internal_goal_state() const {
  const ::galbot::aphropm_proto::RobotStates* p = goal_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::RobotStates&>(
      ::galbot::aphropm_proto::_RobotStates_default_instance_);
}
inline const ::galbot::aphropm_proto::RobotStates& NavigationMotionPlanReq::goal_state() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationMotionPlanReq.goal_state)
  return _internal_goal_state();
}
inline void NavigationMotionPlanReq::unsafe_arena_set_allocated_goal_state(
    ::galbot::aphropm_proto::RobotStates* goal_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state_);
  }
  goal_state_ = goal_state;
  if (goal_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationMotionPlanReq.goal_state)
}
inline ::galbot::aphropm_proto::RobotStates* NavigationMotionPlanReq::release_goal_state() {
  
  ::galbot::aphropm_proto::RobotStates* temp = goal_state_;
  goal_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* NavigationMotionPlanReq::unsafe_arena_release_goal_state() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationMotionPlanReq.goal_state)
  
  ::galbot::aphropm_proto::RobotStates* temp = goal_state_;
  goal_state_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* NavigationMotionPlanReq::_internal_mutable_goal_state() {
  
  if (goal_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::RobotStates>(GetArena());
    goal_state_ = p;
  }
  return goal_state_;
}
inline ::galbot::aphropm_proto::RobotStates* NavigationMotionPlanReq::mutable_goal_state() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationMotionPlanReq.goal_state)
  return _internal_mutable_goal_state();
}
inline void NavigationMotionPlanReq::set_allocated_goal_state(::galbot::aphropm_proto::RobotStates* goal_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state_);
  }
  if (goal_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state)->GetArena();
    if (message_arena != submessage_arena) {
      goal_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goal_state, submessage_arena);
    }
    
  } else {
    
  }
  goal_state_ = goal_state;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.NavigationMotionPlanReq.goal_state)
}

// bool disable_collision_check = 3;
inline void NavigationMotionPlanReq::clear_disable_collision_check() {
  disable_collision_check_ = false;
}
inline bool NavigationMotionPlanReq::_internal_disable_collision_check() const {
  return disable_collision_check_;
}
inline bool NavigationMotionPlanReq::disable_collision_check() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationMotionPlanReq.disable_collision_check)
  return _internal_disable_collision_check();
}
inline void NavigationMotionPlanReq::_internal_set_disable_collision_check(bool value) {
  
  disable_collision_check_ = value;
}
inline void NavigationMotionPlanReq::set_disable_collision_check(bool value) {
  _internal_set_disable_collision_check(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationMotionPlanReq.disable_collision_check)
}

// bool omini_plan = 4;
inline void NavigationMotionPlanReq::clear_omini_plan() {
  omini_plan_ = false;
}
inline bool NavigationMotionPlanReq::_internal_omini_plan() const {
  return omini_plan_;
}
inline bool NavigationMotionPlanReq::omini_plan() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationMotionPlanReq.omini_plan)
  return _internal_omini_plan();
}
inline void NavigationMotionPlanReq::_internal_set_omini_plan(bool value) {
  
  omini_plan_ = value;
}
inline void NavigationMotionPlanReq::set_omini_plan(bool value) {
  _internal_set_omini_plan(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationMotionPlanReq.omini_plan)
}

// -------------------------------------------------------------------

// LoadEnvReq

// .galbot.aphropm_proto.LoadEnvReq.EnvType env_type = 1;
inline void LoadEnvReq::clear_env_type() {
  env_type_ = 0;
}
inline ::galbot::aphropm_proto::LoadEnvReq_EnvType LoadEnvReq::_internal_env_type() const {
  return static_cast< ::galbot::aphropm_proto::LoadEnvReq_EnvType >(env_type_);
}
inline ::galbot::aphropm_proto::LoadEnvReq_EnvType LoadEnvReq::env_type() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.LoadEnvReq.env_type)
  return _internal_env_type();
}
inline void LoadEnvReq::_internal_set_env_type(::galbot::aphropm_proto::LoadEnvReq_EnvType value) {
  
  env_type_ = value;
}
inline void LoadEnvReq::set_env_type(::galbot::aphropm_proto::LoadEnvReq_EnvType value) {
  _internal_set_env_type(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.LoadEnvReq.env_type)
}

// string env_file_path = 2;
inline void LoadEnvReq::clear_env_file_path() {
  env_file_path_.ClearToEmpty();
}
inline const std::string& LoadEnvReq::env_file_path() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.LoadEnvReq.env_file_path)
  return _internal_env_file_path();
}
inline void LoadEnvReq::set_env_file_path(const std::string& value) {
  _internal_set_env_file_path(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.LoadEnvReq.env_file_path)
}
inline std::string* LoadEnvReq::mutable_env_file_path() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.LoadEnvReq.env_file_path)
  return _internal_mutable_env_file_path();
}
inline const std::string& LoadEnvReq::_internal_env_file_path() const {
  return env_file_path_.Get();
}
inline void LoadEnvReq::_internal_set_env_file_path(const std::string& value) {
  
  env_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadEnvReq::set_env_file_path(std::string&& value) {
  
  env_file_path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.LoadEnvReq.env_file_path)
}
inline void LoadEnvReq::set_env_file_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  env_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.LoadEnvReq.env_file_path)
}
inline void LoadEnvReq::set_env_file_path(const char* value,
    size_t size) {
  
  env_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.LoadEnvReq.env_file_path)
}
inline std::string* LoadEnvReq::_internal_mutable_env_file_path() {
  
  return env_file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadEnvReq::release_env_file_path() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.LoadEnvReq.env_file_path)
  return env_file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadEnvReq::set_allocated_env_file_path(std::string* env_file_path) {
  if (env_file_path != nullptr) {
    
  } else {
    
  }
  env_file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), env_file_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.LoadEnvReq.env_file_path)
}

// string save_file_path = 3;
inline void LoadEnvReq::clear_save_file_path() {
  save_file_path_.ClearToEmpty();
}
inline const std::string& LoadEnvReq::save_file_path() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.LoadEnvReq.save_file_path)
  return _internal_save_file_path();
}
inline void LoadEnvReq::set_save_file_path(const std::string& value) {
  _internal_set_save_file_path(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.LoadEnvReq.save_file_path)
}
inline std::string* LoadEnvReq::mutable_save_file_path() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.LoadEnvReq.save_file_path)
  return _internal_mutable_save_file_path();
}
inline const std::string& LoadEnvReq::_internal_save_file_path() const {
  return save_file_path_.Get();
}
inline void LoadEnvReq::_internal_set_save_file_path(const std::string& value) {
  
  save_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoadEnvReq::set_save_file_path(std::string&& value) {
  
  save_file_path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.LoadEnvReq.save_file_path)
}
inline void LoadEnvReq::set_save_file_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  save_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.LoadEnvReq.save_file_path)
}
inline void LoadEnvReq::set_save_file_path(const char* value,
    size_t size) {
  
  save_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.LoadEnvReq.save_file_path)
}
inline std::string* LoadEnvReq::_internal_mutable_save_file_path() {
  
  return save_file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoadEnvReq::release_save_file_path() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.LoadEnvReq.save_file_path)
  return save_file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoadEnvReq::set_allocated_save_file_path(std::string* save_file_path) {
  if (save_file_path != nullptr) {
    
  } else {
    
  }
  save_file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), save_file_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.LoadEnvReq.save_file_path)
}

// double resolution = 4;
inline void LoadEnvReq::clear_resolution() {
  resolution_ = 0;
}
inline double LoadEnvReq::_internal_resolution() const {
  return resolution_;
}
inline double LoadEnvReq::resolution() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.LoadEnvReq.resolution)
  return _internal_resolution();
}
inline void LoadEnvReq::_internal_set_resolution(double value) {
  
  resolution_ = value;
}
inline void LoadEnvReq::set_resolution(double value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.LoadEnvReq.resolution)
}

// -------------------------------------------------------------------

// EvaluateGoalAvailabilityReq

// .galbot.aphropm_proto.RobotStates start_state = 1;
inline bool EvaluateGoalAvailabilityReq::_internal_has_start_state() const {
  return this != internal_default_instance() && start_state_ != nullptr;
}
inline bool EvaluateGoalAvailabilityReq::has_start_state() const {
  return _internal_has_start_state();
}
inline const ::galbot::aphropm_proto::RobotStates& EvaluateGoalAvailabilityReq::_internal_start_state() const {
  const ::galbot::aphropm_proto::RobotStates* p = start_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::RobotStates&>(
      ::galbot::aphropm_proto::_RobotStates_default_instance_);
}
inline const ::galbot::aphropm_proto::RobotStates& EvaluateGoalAvailabilityReq::start_state() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.start_state)
  return _internal_start_state();
}
inline void EvaluateGoalAvailabilityReq::unsafe_arena_set_allocated_start_state(
    ::galbot::aphropm_proto::RobotStates* start_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_state_);
  }
  start_state_ = start_state;
  if (start_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.start_state)
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::release_start_state() {
  
  ::galbot::aphropm_proto::RobotStates* temp = start_state_;
  start_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::unsafe_arena_release_start_state() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.start_state)
  
  ::galbot::aphropm_proto::RobotStates* temp = start_state_;
  start_state_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::_internal_mutable_start_state() {
  
  if (start_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::RobotStates>(GetArena());
    start_state_ = p;
  }
  return start_state_;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::mutable_start_state() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.start_state)
  return _internal_mutable_start_state();
}
inline void EvaluateGoalAvailabilityReq::set_allocated_start_state(::galbot::aphropm_proto::RobotStates* start_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_state_);
  }
  if (start_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_state)->GetArena();
    if (message_arena != submessage_arena) {
      start_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_state, submessage_arena);
    }
    
  } else {
    
  }
  start_state_ = start_state;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.start_state)
}

// .galbot.aphropm_proto.RobotStates goal_state = 2;
inline bool EvaluateGoalAvailabilityReq::_internal_has_goal_state() const {
  return this != internal_default_instance() && goal_state_ != nullptr;
}
inline bool EvaluateGoalAvailabilityReq::has_goal_state() const {
  return _internal_has_goal_state();
}
inline const ::galbot::aphropm_proto::RobotStates& EvaluateGoalAvailabilityReq::_internal_goal_state() const {
  const ::galbot::aphropm_proto::RobotStates* p = goal_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::RobotStates&>(
      ::galbot::aphropm_proto::_RobotStates_default_instance_);
}
inline const ::galbot::aphropm_proto::RobotStates& EvaluateGoalAvailabilityReq::goal_state() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.goal_state)
  return _internal_goal_state();
}
inline void EvaluateGoalAvailabilityReq::unsafe_arena_set_allocated_goal_state(
    ::galbot::aphropm_proto::RobotStates* goal_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state_);
  }
  goal_state_ = goal_state;
  if (goal_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.goal_state)
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::release_goal_state() {
  
  ::galbot::aphropm_proto::RobotStates* temp = goal_state_;
  goal_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::unsafe_arena_release_goal_state() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.goal_state)
  
  ::galbot::aphropm_proto::RobotStates* temp = goal_state_;
  goal_state_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::_internal_mutable_goal_state() {
  
  if (goal_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::RobotStates>(GetArena());
    goal_state_ = p;
  }
  return goal_state_;
}
inline ::galbot::aphropm_proto::RobotStates* EvaluateGoalAvailabilityReq::mutable_goal_state() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.goal_state)
  return _internal_mutable_goal_state();
}
inline void EvaluateGoalAvailabilityReq::set_allocated_goal_state(::galbot::aphropm_proto::RobotStates* goal_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state_);
  }
  if (goal_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_state)->GetArena();
    if (message_arena != submessage_arena) {
      goal_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goal_state, submessage_arena);
    }
    
  } else {
    
  }
  goal_state_ = goal_state;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.goal_state)
}

// bool use_start_state = 3;
inline void EvaluateGoalAvailabilityReq::clear_use_start_state() {
  use_start_state_ = false;
}
inline bool EvaluateGoalAvailabilityReq::_internal_use_start_state() const {
  return use_start_state_;
}
inline bool EvaluateGoalAvailabilityReq::use_start_state() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.use_start_state)
  return _internal_use_start_state();
}
inline void EvaluateGoalAvailabilityReq::_internal_set_use_start_state(bool value) {
  
  use_start_state_ = value;
}
inline void EvaluateGoalAvailabilityReq::set_use_start_state(bool value) {
  _internal_set_use_start_state(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.EvaluateGoalAvailabilityReq.use_start_state)
}

// -------------------------------------------------------------------

// StopNavigationReq

// -------------------------------------------------------------------

// MoveTrajectoryReq

// .galbot.aphropm_proto.RobotTrajectory trajectory = 1;
inline bool MoveTrajectoryReq::_internal_has_trajectory() const {
  return this != internal_default_instance() && trajectory_ != nullptr;
}
inline bool MoveTrajectoryReq::has_trajectory() const {
  return _internal_has_trajectory();
}
inline const ::galbot::aphropm_proto::RobotTrajectory& MoveTrajectoryReq::_internal_trajectory() const {
  const ::galbot::aphropm_proto::RobotTrajectory* p = trajectory_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::RobotTrajectory&>(
      ::galbot::aphropm_proto::_RobotTrajectory_default_instance_);
}
inline const ::galbot::aphropm_proto::RobotTrajectory& MoveTrajectoryReq::trajectory() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MoveTrajectoryReq.trajectory)
  return _internal_trajectory();
}
inline void MoveTrajectoryReq::unsafe_arena_set_allocated_trajectory(
    ::galbot::aphropm_proto::RobotTrajectory* trajectory) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trajectory_);
  }
  trajectory_ = trajectory;
  if (trajectory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.MoveTrajectoryReq.trajectory)
}
inline ::galbot::aphropm_proto::RobotTrajectory* MoveTrajectoryReq::release_trajectory() {
  
  ::galbot::aphropm_proto::RobotTrajectory* temp = trajectory_;
  trajectory_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::RobotTrajectory* MoveTrajectoryReq::unsafe_arena_release_trajectory() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.MoveTrajectoryReq.trajectory)
  
  ::galbot::aphropm_proto::RobotTrajectory* temp = trajectory_;
  trajectory_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::RobotTrajectory* MoveTrajectoryReq::_internal_mutable_trajectory() {
  
  if (trajectory_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::RobotTrajectory>(GetArena());
    trajectory_ = p;
  }
  return trajectory_;
}
inline ::galbot::aphropm_proto::RobotTrajectory* MoveTrajectoryReq::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.MoveTrajectoryReq.trajectory)
  return _internal_mutable_trajectory();
}
inline void MoveTrajectoryReq::set_allocated_trajectory(::galbot::aphropm_proto::RobotTrajectory* trajectory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(trajectory_);
  }
  if (trajectory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trajectory)->GetArena();
    if (message_arena != submessage_arena) {
      trajectory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    
  } else {
    
  }
  trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.MoveTrajectoryReq.trajectory)
}

// bool plan_traj = 10;
inline void MoveTrajectoryReq::clear_plan_traj() {
  plan_traj_ = false;
}
inline bool MoveTrajectoryReq::_internal_plan_traj() const {
  return plan_traj_;
}
inline bool MoveTrajectoryReq::plan_traj() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MoveTrajectoryReq.plan_traj)
  return _internal_plan_traj();
}
inline void MoveTrajectoryReq::_internal_set_plan_traj(bool value) {
  
  plan_traj_ = value;
}
inline void MoveTrajectoryReq::set_plan_traj(bool value) {
  _internal_set_plan_traj(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MoveTrajectoryReq.plan_traj)
}

// bool optimize_traj = 11;
inline void MoveTrajectoryReq::clear_optimize_traj() {
  optimize_traj_ = false;
}
inline bool MoveTrajectoryReq::_internal_optimize_traj() const {
  return optimize_traj_;
}
inline bool MoveTrajectoryReq::optimize_traj() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MoveTrajectoryReq.optimize_traj)
  return _internal_optimize_traj();
}
inline void MoveTrajectoryReq::_internal_set_optimize_traj(bool value) {
  
  optimize_traj_ = value;
}
inline void MoveTrajectoryReq::set_optimize_traj(bool value) {
  _internal_set_optimize_traj(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MoveTrajectoryReq.optimize_traj)
}

// bool check_valid = 12;
inline void MoveTrajectoryReq::clear_check_valid() {
  check_valid_ = false;
}
inline bool MoveTrajectoryReq::_internal_check_valid() const {
  return check_valid_;
}
inline bool MoveTrajectoryReq::check_valid() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MoveTrajectoryReq.check_valid)
  return _internal_check_valid();
}
inline void MoveTrajectoryReq::_internal_set_check_valid(bool value) {
  
  check_valid_ = value;
}
inline void MoveTrajectoryReq::set_check_valid(bool value) {
  _internal_set_check_valid(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MoveTrajectoryReq.check_valid)
}

// .galbot.aphropm_proto.MoveTrajectoryReq.HeadingDirection heading_direction = 20;
inline void MoveTrajectoryReq::clear_heading_direction() {
  heading_direction_ = 0;
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection MoveTrajectoryReq::_internal_heading_direction() const {
  return static_cast< ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection >(heading_direction_);
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection MoveTrajectoryReq::heading_direction() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MoveTrajectoryReq.heading_direction)
  return _internal_heading_direction();
}
inline void MoveTrajectoryReq::_internal_set_heading_direction(::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection value) {
  
  heading_direction_ = value;
}
inline void MoveTrajectoryReq::set_heading_direction(::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection value) {
  _internal_set_heading_direction(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MoveTrajectoryReq.heading_direction)
}

// -------------------------------------------------------------------

// NavigationRequest

// string task_id = 1;
inline void NavigationRequest::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& NavigationRequest::task_id() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.task_id)
  return _internal_task_id();
}
inline void NavigationRequest::set_task_id(const std::string& value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationRequest.task_id)
}
inline std::string* NavigationRequest::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.task_id)
  return _internal_mutable_task_id();
}
inline const std::string& NavigationRequest::_internal_task_id() const {
  return task_id_.Get();
}
inline void NavigationRequest::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NavigationRequest::set_task_id(std::string&& value) {
  
  task_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.NavigationRequest.task_id)
}
inline void NavigationRequest::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.NavigationRequest.task_id)
}
inline void NavigationRequest::set_task_id(const char* value,
    size_t size) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.NavigationRequest.task_id)
}
inline std::string* NavigationRequest::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NavigationRequest::release_task_id() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationRequest::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.NavigationRequest.task_id)
}

// .galbot.aphropm_proto.NavigationMotionPlanReq motion_plan = 2;
inline bool NavigationRequest::_internal_has_motion_plan() const {
  return request_type_case() == kMotionPlan;
}
inline bool NavigationRequest::has_motion_plan() const {
  return _internal_has_motion_plan();
}
inline void NavigationRequest::set_has_motion_plan() {
  _oneof_case_[0] = kMotionPlan;
}
inline void NavigationRequest::clear_motion_plan() {
  if (_internal_has_motion_plan()) {
    if (GetArena() == nullptr) {
      delete request_type_.motion_plan_;
    }
    clear_has_request_type();
  }
}
inline ::galbot::aphropm_proto::NavigationMotionPlanReq* NavigationRequest::release_motion_plan() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.motion_plan)
  if (_internal_has_motion_plan()) {
    clear_has_request_type();
      ::galbot::aphropm_proto::NavigationMotionPlanReq* temp = request_type_.motion_plan_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.motion_plan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::NavigationMotionPlanReq& NavigationRequest::_internal_motion_plan() const {
  return _internal_has_motion_plan()
      ? *request_type_.motion_plan_
      : reinterpret_cast< ::galbot::aphropm_proto::NavigationMotionPlanReq&>(::galbot::aphropm_proto::_NavigationMotionPlanReq_default_instance_);
}
inline const ::galbot::aphropm_proto::NavigationMotionPlanReq& NavigationRequest::motion_plan() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.motion_plan)
  return _internal_motion_plan();
}
inline ::galbot::aphropm_proto::NavigationMotionPlanReq* NavigationRequest::unsafe_arena_release_motion_plan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.NavigationRequest.motion_plan)
  if (_internal_has_motion_plan()) {
    clear_has_request_type();
    ::galbot::aphropm_proto::NavigationMotionPlanReq* temp = request_type_.motion_plan_;
    request_type_.motion_plan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NavigationRequest::unsafe_arena_set_allocated_motion_plan(::galbot::aphropm_proto::NavigationMotionPlanReq* motion_plan) {
  clear_request_type();
  if (motion_plan) {
    set_has_motion_plan();
    request_type_.motion_plan_ = motion_plan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationRequest.motion_plan)
}
inline ::galbot::aphropm_proto::NavigationMotionPlanReq* NavigationRequest::_internal_mutable_motion_plan() {
  if (!_internal_has_motion_plan()) {
    clear_request_type();
    set_has_motion_plan();
    request_type_.motion_plan_ = CreateMaybeMessage< ::galbot::aphropm_proto::NavigationMotionPlanReq >(GetArena());
  }
  return request_type_.motion_plan_;
}
inline ::galbot::aphropm_proto::NavigationMotionPlanReq* NavigationRequest::mutable_motion_plan() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.motion_plan)
  return _internal_mutable_motion_plan();
}

// .galbot.aphropm_proto.LoadEnvReq load_env_req = 3;
inline bool NavigationRequest::_internal_has_load_env_req() const {
  return request_type_case() == kLoadEnvReq;
}
inline bool NavigationRequest::has_load_env_req() const {
  return _internal_has_load_env_req();
}
inline void NavigationRequest::set_has_load_env_req() {
  _oneof_case_[0] = kLoadEnvReq;
}
inline void NavigationRequest::clear_load_env_req() {
  if (_internal_has_load_env_req()) {
    if (GetArena() == nullptr) {
      delete request_type_.load_env_req_;
    }
    clear_has_request_type();
  }
}
inline ::galbot::aphropm_proto::LoadEnvReq* NavigationRequest::release_load_env_req() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.load_env_req)
  if (_internal_has_load_env_req()) {
    clear_has_request_type();
      ::galbot::aphropm_proto::LoadEnvReq* temp = request_type_.load_env_req_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.load_env_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::LoadEnvReq& NavigationRequest::_internal_load_env_req() const {
  return _internal_has_load_env_req()
      ? *request_type_.load_env_req_
      : reinterpret_cast< ::galbot::aphropm_proto::LoadEnvReq&>(::galbot::aphropm_proto::_LoadEnvReq_default_instance_);
}
inline const ::galbot::aphropm_proto::LoadEnvReq& NavigationRequest::load_env_req() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.load_env_req)
  return _internal_load_env_req();
}
inline ::galbot::aphropm_proto::LoadEnvReq* NavigationRequest::unsafe_arena_release_load_env_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.NavigationRequest.load_env_req)
  if (_internal_has_load_env_req()) {
    clear_has_request_type();
    ::galbot::aphropm_proto::LoadEnvReq* temp = request_type_.load_env_req_;
    request_type_.load_env_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NavigationRequest::unsafe_arena_set_allocated_load_env_req(::galbot::aphropm_proto::LoadEnvReq* load_env_req) {
  clear_request_type();
  if (load_env_req) {
    set_has_load_env_req();
    request_type_.load_env_req_ = load_env_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationRequest.load_env_req)
}
inline ::galbot::aphropm_proto::LoadEnvReq* NavigationRequest::_internal_mutable_load_env_req() {
  if (!_internal_has_load_env_req()) {
    clear_request_type();
    set_has_load_env_req();
    request_type_.load_env_req_ = CreateMaybeMessage< ::galbot::aphropm_proto::LoadEnvReq >(GetArena());
  }
  return request_type_.load_env_req_;
}
inline ::galbot::aphropm_proto::LoadEnvReq* NavigationRequest::mutable_load_env_req() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.load_env_req)
  return _internal_mutable_load_env_req();
}

// .galbot.aphropm_proto.StopNavigationReq stop_navigation_req = 4;
inline bool NavigationRequest::_internal_has_stop_navigation_req() const {
  return request_type_case() == kStopNavigationReq;
}
inline bool NavigationRequest::has_stop_navigation_req() const {
  return _internal_has_stop_navigation_req();
}
inline void NavigationRequest::set_has_stop_navigation_req() {
  _oneof_case_[0] = kStopNavigationReq;
}
inline void NavigationRequest::clear_stop_navigation_req() {
  if (_internal_has_stop_navigation_req()) {
    if (GetArena() == nullptr) {
      delete request_type_.stop_navigation_req_;
    }
    clear_has_request_type();
  }
}
inline ::galbot::aphropm_proto::StopNavigationReq* NavigationRequest::release_stop_navigation_req() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.stop_navigation_req)
  if (_internal_has_stop_navigation_req()) {
    clear_has_request_type();
      ::galbot::aphropm_proto::StopNavigationReq* temp = request_type_.stop_navigation_req_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.stop_navigation_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::StopNavigationReq& NavigationRequest::_internal_stop_navigation_req() const {
  return _internal_has_stop_navigation_req()
      ? *request_type_.stop_navigation_req_
      : reinterpret_cast< ::galbot::aphropm_proto::StopNavigationReq&>(::galbot::aphropm_proto::_StopNavigationReq_default_instance_);
}
inline const ::galbot::aphropm_proto::StopNavigationReq& NavigationRequest::stop_navigation_req() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.stop_navigation_req)
  return _internal_stop_navigation_req();
}
inline ::galbot::aphropm_proto::StopNavigationReq* NavigationRequest::unsafe_arena_release_stop_navigation_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.NavigationRequest.stop_navigation_req)
  if (_internal_has_stop_navigation_req()) {
    clear_has_request_type();
    ::galbot::aphropm_proto::StopNavigationReq* temp = request_type_.stop_navigation_req_;
    request_type_.stop_navigation_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NavigationRequest::unsafe_arena_set_allocated_stop_navigation_req(::galbot::aphropm_proto::StopNavigationReq* stop_navigation_req) {
  clear_request_type();
  if (stop_navigation_req) {
    set_has_stop_navigation_req();
    request_type_.stop_navigation_req_ = stop_navigation_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationRequest.stop_navigation_req)
}
inline ::galbot::aphropm_proto::StopNavigationReq* NavigationRequest::_internal_mutable_stop_navigation_req() {
  if (!_internal_has_stop_navigation_req()) {
    clear_request_type();
    set_has_stop_navigation_req();
    request_type_.stop_navigation_req_ = CreateMaybeMessage< ::galbot::aphropm_proto::StopNavigationReq >(GetArena());
  }
  return request_type_.stop_navigation_req_;
}
inline ::galbot::aphropm_proto::StopNavigationReq* NavigationRequest::mutable_stop_navigation_req() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.stop_navigation_req)
  return _internal_mutable_stop_navigation_req();
}

// .galbot.aphropm_proto.EvaluateGoalAvailabilityReq evaluate_goal_availability_req = 5;
inline bool NavigationRequest::_internal_has_evaluate_goal_availability_req() const {
  return request_type_case() == kEvaluateGoalAvailabilityReq;
}
inline bool NavigationRequest::has_evaluate_goal_availability_req() const {
  return _internal_has_evaluate_goal_availability_req();
}
inline void NavigationRequest::set_has_evaluate_goal_availability_req() {
  _oneof_case_[0] = kEvaluateGoalAvailabilityReq;
}
inline void NavigationRequest::clear_evaluate_goal_availability_req() {
  if (_internal_has_evaluate_goal_availability_req()) {
    if (GetArena() == nullptr) {
      delete request_type_.evaluate_goal_availability_req_;
    }
    clear_has_request_type();
  }
}
inline ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* NavigationRequest::release_evaluate_goal_availability_req() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.evaluate_goal_availability_req)
  if (_internal_has_evaluate_goal_availability_req()) {
    clear_has_request_type();
      ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* temp = request_type_.evaluate_goal_availability_req_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.evaluate_goal_availability_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq& NavigationRequest::_internal_evaluate_goal_availability_req() const {
  return _internal_has_evaluate_goal_availability_req()
      ? *request_type_.evaluate_goal_availability_req_
      : reinterpret_cast< ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq&>(::galbot::aphropm_proto::_EvaluateGoalAvailabilityReq_default_instance_);
}
inline const ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq& NavigationRequest::evaluate_goal_availability_req() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.evaluate_goal_availability_req)
  return _internal_evaluate_goal_availability_req();
}
inline ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* NavigationRequest::unsafe_arena_release_evaluate_goal_availability_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.NavigationRequest.evaluate_goal_availability_req)
  if (_internal_has_evaluate_goal_availability_req()) {
    clear_has_request_type();
    ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* temp = request_type_.evaluate_goal_availability_req_;
    request_type_.evaluate_goal_availability_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NavigationRequest::unsafe_arena_set_allocated_evaluate_goal_availability_req(::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* evaluate_goal_availability_req) {
  clear_request_type();
  if (evaluate_goal_availability_req) {
    set_has_evaluate_goal_availability_req();
    request_type_.evaluate_goal_availability_req_ = evaluate_goal_availability_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationRequest.evaluate_goal_availability_req)
}
inline ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* NavigationRequest::_internal_mutable_evaluate_goal_availability_req() {
  if (!_internal_has_evaluate_goal_availability_req()) {
    clear_request_type();
    set_has_evaluate_goal_availability_req();
    request_type_.evaluate_goal_availability_req_ = CreateMaybeMessage< ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq >(GetArena());
  }
  return request_type_.evaluate_goal_availability_req_;
}
inline ::galbot::aphropm_proto::EvaluateGoalAvailabilityReq* NavigationRequest::mutable_evaluate_goal_availability_req() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.evaluate_goal_availability_req)
  return _internal_mutable_evaluate_goal_availability_req();
}

// .galbot.aphropm_proto.MoveTrajectoryReq move_trajectory_req = 6;
inline bool NavigationRequest::_internal_has_move_trajectory_req() const {
  return request_type_case() == kMoveTrajectoryReq;
}
inline bool NavigationRequest::has_move_trajectory_req() const {
  return _internal_has_move_trajectory_req();
}
inline void NavigationRequest::set_has_move_trajectory_req() {
  _oneof_case_[0] = kMoveTrajectoryReq;
}
inline void NavigationRequest::clear_move_trajectory_req() {
  if (_internal_has_move_trajectory_req()) {
    if (GetArena() == nullptr) {
      delete request_type_.move_trajectory_req_;
    }
    clear_has_request_type();
  }
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq* NavigationRequest::release_move_trajectory_req() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationRequest.move_trajectory_req)
  if (_internal_has_move_trajectory_req()) {
    clear_has_request_type();
      ::galbot::aphropm_proto::MoveTrajectoryReq* temp = request_type_.move_trajectory_req_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.move_trajectory_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::MoveTrajectoryReq& NavigationRequest::_internal_move_trajectory_req() const {
  return _internal_has_move_trajectory_req()
      ? *request_type_.move_trajectory_req_
      : reinterpret_cast< ::galbot::aphropm_proto::MoveTrajectoryReq&>(::galbot::aphropm_proto::_MoveTrajectoryReq_default_instance_);
}
inline const ::galbot::aphropm_proto::MoveTrajectoryReq& NavigationRequest::move_trajectory_req() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationRequest.move_trajectory_req)
  return _internal_move_trajectory_req();
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq* NavigationRequest::unsafe_arena_release_move_trajectory_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.NavigationRequest.move_trajectory_req)
  if (_internal_has_move_trajectory_req()) {
    clear_has_request_type();
    ::galbot::aphropm_proto::MoveTrajectoryReq* temp = request_type_.move_trajectory_req_;
    request_type_.move_trajectory_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NavigationRequest::unsafe_arena_set_allocated_move_trajectory_req(::galbot::aphropm_proto::MoveTrajectoryReq* move_trajectory_req) {
  clear_request_type();
  if (move_trajectory_req) {
    set_has_move_trajectory_req();
    request_type_.move_trajectory_req_ = move_trajectory_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.NavigationRequest.move_trajectory_req)
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq* NavigationRequest::_internal_mutable_move_trajectory_req() {
  if (!_internal_has_move_trajectory_req()) {
    clear_request_type();
    set_has_move_trajectory_req();
    request_type_.move_trajectory_req_ = CreateMaybeMessage< ::galbot::aphropm_proto::MoveTrajectoryReq >(GetArena());
  }
  return request_type_.move_trajectory_req_;
}
inline ::galbot::aphropm_proto::MoveTrajectoryReq* NavigationRequest::mutable_move_trajectory_req() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationRequest.move_trajectory_req)
  return _internal_mutable_move_trajectory_req();
}

inline bool NavigationRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void NavigationRequest::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline NavigationRequest::RequestTypeCase NavigationRequest::request_type_case() const {
  return NavigationRequest::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NavigationResponse

// string task_id = 1;
inline void NavigationResponse::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& NavigationResponse::task_id() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationResponse.task_id)
  return _internal_task_id();
}
inline void NavigationResponse::set_task_id(const std::string& value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationResponse.task_id)
}
inline std::string* NavigationResponse::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationResponse.task_id)
  return _internal_mutable_task_id();
}
inline const std::string& NavigationResponse::_internal_task_id() const {
  return task_id_.Get();
}
inline void NavigationResponse::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NavigationResponse::set_task_id(std::string&& value) {
  
  task_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.NavigationResponse.task_id)
}
inline void NavigationResponse::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.NavigationResponse.task_id)
}
inline void NavigationResponse::set_task_id(const char* value,
    size_t size) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.NavigationResponse.task_id)
}
inline std::string* NavigationResponse::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NavigationResponse::release_task_id() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationResponse.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationResponse::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.NavigationResponse.task_id)
}

// .galbot.aphropm_proto.NavigationResponse.Status status = 2;
inline void NavigationResponse::clear_status() {
  status_ = 0;
}
inline ::galbot::aphropm_proto::NavigationResponse_Status NavigationResponse::_internal_status() const {
  return static_cast< ::galbot::aphropm_proto::NavigationResponse_Status >(status_);
}
inline ::galbot::aphropm_proto::NavigationResponse_Status NavigationResponse::status() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationResponse.status)
  return _internal_status();
}
inline void NavigationResponse::_internal_set_status(::galbot::aphropm_proto::NavigationResponse_Status value) {
  
  status_ = value;
}
inline void NavigationResponse::set_status(::galbot::aphropm_proto::NavigationResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationResponse.status)
}

// -------------------------------------------------------------------

// NavigationResult

// string task_id = 1;
inline void NavigationResult::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& NavigationResult::task_id() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationResult.task_id)
  return _internal_task_id();
}
inline void NavigationResult::set_task_id(const std::string& value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationResult.task_id)
}
inline std::string* NavigationResult::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationResult.task_id)
  return _internal_mutable_task_id();
}
inline const std::string& NavigationResult::_internal_task_id() const {
  return task_id_.Get();
}
inline void NavigationResult::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NavigationResult::set_task_id(std::string&& value) {
  
  task_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.NavigationResult.task_id)
}
inline void NavigationResult::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.NavigationResult.task_id)
}
inline void NavigationResult::set_task_id(const char* value,
    size_t size) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.NavigationResult.task_id)
}
inline std::string* NavigationResult::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NavigationResult::release_task_id() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationResult.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationResult::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.NavigationResult.task_id)
}

// .galbot.aphropm_proto.NavigationResult.TaskStatus status = 2;
inline void NavigationResult::clear_status() {
  status_ = 0;
}
inline ::galbot::aphropm_proto::NavigationResult_TaskStatus NavigationResult::_internal_status() const {
  return static_cast< ::galbot::aphropm_proto::NavigationResult_TaskStatus >(status_);
}
inline ::galbot::aphropm_proto::NavigationResult_TaskStatus NavigationResult::status() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationResult.status)
  return _internal_status();
}
inline void NavigationResult::_internal_set_status(::galbot::aphropm_proto::NavigationResult_TaskStatus value) {
  
  status_ = value;
}
inline void NavigationResult::set_status(::galbot::aphropm_proto::NavigationResult_TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationResult.status)
}

// -------------------------------------------------------------------

// NavigationException

// .galbot.aphropm_proto.NavigationException.Exception exception = 3;
inline void NavigationException::clear_exception() {
  exception_ = 0;
}
inline ::galbot::aphropm_proto::NavigationException_Exception NavigationException::_internal_exception() const {
  return static_cast< ::galbot::aphropm_proto::NavigationException_Exception >(exception_);
}
inline ::galbot::aphropm_proto::NavigationException_Exception NavigationException::exception() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationException.exception)
  return _internal_exception();
}
inline void NavigationException::_internal_set_exception(::galbot::aphropm_proto::NavigationException_Exception value) {
  
  exception_ = value;
}
inline void NavigationException::set_exception(::galbot::aphropm_proto::NavigationException_Exception value) {
  _internal_set_exception(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationException.exception)
}

// .galbot.aphropm_proto.NavigationException.SerLevel level = 4;
inline void NavigationException::clear_level() {
  level_ = 0;
}
inline ::galbot::aphropm_proto::NavigationException_SerLevel NavigationException::_internal_level() const {
  return static_cast< ::galbot::aphropm_proto::NavigationException_SerLevel >(level_);
}
inline ::galbot::aphropm_proto::NavigationException_SerLevel NavigationException::level() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationException.level)
  return _internal_level();
}
inline void NavigationException::_internal_set_level(::galbot::aphropm_proto::NavigationException_SerLevel value) {
  
  level_ = value;
}
inline void NavigationException::set_level(::galbot::aphropm_proto::NavigationException_SerLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationException.level)
}

// int32 err_code = 10;
inline void NavigationException::clear_err_code() {
  err_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NavigationException::_internal_err_code() const {
  return err_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NavigationException::err_code() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationException.err_code)
  return _internal_err_code();
}
inline void NavigationException::_internal_set_err_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  err_code_ = value;
}
inline void NavigationException::set_err_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_err_code(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationException.err_code)
}

// string err_msg = 11;
inline void NavigationException::clear_err_msg() {
  err_msg_.ClearToEmpty();
}
inline const std::string& NavigationException::err_msg() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.NavigationException.err_msg)
  return _internal_err_msg();
}
inline void NavigationException::set_err_msg(const std::string& value) {
  _internal_set_err_msg(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.NavigationException.err_msg)
}
inline std::string* NavigationException::mutable_err_msg() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.NavigationException.err_msg)
  return _internal_mutable_err_msg();
}
inline const std::string& NavigationException::_internal_err_msg() const {
  return err_msg_.Get();
}
inline void NavigationException::_internal_set_err_msg(const std::string& value) {
  
  err_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void NavigationException::set_err_msg(std::string&& value) {
  
  err_msg_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.NavigationException.err_msg)
}
inline void NavigationException::set_err_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  err_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.NavigationException.err_msg)
}
inline void NavigationException::set_err_msg(const char* value,
    size_t size) {
  
  err_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.NavigationException.err_msg)
}
inline std::string* NavigationException::_internal_mutable_err_msg() {
  
  return err_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* NavigationException::release_err_msg() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.NavigationException.err_msg)
  return err_msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NavigationException::set_allocated_err_msg(std::string* err_msg) {
  if (err_msg != nullptr) {
    
  } else {
    
  }
  err_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), err_msg,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.NavigationException.err_msg)
}

// -------------------------------------------------------------------

// PoseAvailability

// bool available = 1;
inline void PoseAvailability::clear_available() {
  available_ = false;
}
inline bool PoseAvailability::_internal_available() const {
  return available_;
}
inline bool PoseAvailability::available() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseAvailability.available)
  return _internal_available();
}
inline void PoseAvailability::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void PoseAvailability::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PoseAvailability.available)
}

// double distance = 2;
inline void PoseAvailability::clear_distance() {
  distance_ = 0;
}
inline double PoseAvailability::_internal_distance() const {
  return distance_;
}
inline double PoseAvailability::distance() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseAvailability.distance)
  return _internal_distance();
}
inline void PoseAvailability::_internal_set_distance(double value) {
  
  distance_ = value;
}
inline void PoseAvailability::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PoseAvailability.distance)
}

// repeated double grad = 3;
inline int PoseAvailability::_internal_grad_size() const {
  return grad_.size();
}
inline int PoseAvailability::grad_size() const {
  return _internal_grad_size();
}
inline void PoseAvailability::clear_grad() {
  grad_.Clear();
}
inline double PoseAvailability::_internal_grad(int index) const {
  return grad_.Get(index);
}
inline double PoseAvailability::grad(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseAvailability.grad)
  return _internal_grad(index);
}
inline void PoseAvailability::set_grad(int index, double value) {
  grad_.Set(index, value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PoseAvailability.grad)
}
inline void PoseAvailability::_internal_add_grad(double value) {
  grad_.Add(value);
}
inline void PoseAvailability::add_grad(double value) {
  _internal_add_grad(value);
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.PoseAvailability.grad)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PoseAvailability::_internal_grad() const {
  return grad_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
PoseAvailability::grad() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.PoseAvailability.grad)
  return _internal_grad();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PoseAvailability::_internal_mutable_grad() {
  return &grad_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
PoseAvailability::mutable_grad() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.PoseAvailability.grad)
  return _internal_mutable_grad();
}

// -------------------------------------------------------------------

// EvaluateGoalAvailabilityResponse

// string task_id = 1;
inline void EvaluateGoalAvailabilityResponse::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& EvaluateGoalAvailabilityResponse::task_id() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
  return _internal_task_id();
}
inline void EvaluateGoalAvailabilityResponse::set_task_id(const std::string& value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
}
inline std::string* EvaluateGoalAvailabilityResponse::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
  return _internal_mutable_task_id();
}
inline const std::string& EvaluateGoalAvailabilityResponse::_internal_task_id() const {
  return task_id_.Get();
}
inline void EvaluateGoalAvailabilityResponse::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void EvaluateGoalAvailabilityResponse::set_task_id(std::string&& value) {
  
  task_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
}
inline void EvaluateGoalAvailabilityResponse::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
}
inline void EvaluateGoalAvailabilityResponse::set_task_id(const char* value,
    size_t size) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
}
inline std::string* EvaluateGoalAvailabilityResponse::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* EvaluateGoalAvailabilityResponse::release_task_id() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EvaluateGoalAvailabilityResponse::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.task_id)
}

// .galbot.aphropm_proto.PoseAvailability start_pose = 2;
inline bool EvaluateGoalAvailabilityResponse::_internal_has_start_pose() const {
  return this != internal_default_instance() && start_pose_ != nullptr;
}
inline bool EvaluateGoalAvailabilityResponse::has_start_pose() const {
  return _internal_has_start_pose();
}
inline void EvaluateGoalAvailabilityResponse::clear_start_pose() {
  if (GetArena() == nullptr && start_pose_ != nullptr) {
    delete start_pose_;
  }
  start_pose_ = nullptr;
}
inline const ::galbot::aphropm_proto::PoseAvailability& EvaluateGoalAvailabilityResponse::_internal_start_pose() const {
  const ::galbot::aphropm_proto::PoseAvailability* p = start_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::PoseAvailability&>(
      ::galbot::aphropm_proto::_PoseAvailability_default_instance_);
}
inline const ::galbot::aphropm_proto::PoseAvailability& EvaluateGoalAvailabilityResponse::start_pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.start_pose)
  return _internal_start_pose();
}
inline void EvaluateGoalAvailabilityResponse::unsafe_arena_set_allocated_start_pose(
    ::galbot::aphropm_proto::PoseAvailability* start_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pose_);
  }
  start_pose_ = start_pose;
  if (start_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.start_pose)
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::release_start_pose() {
  
  ::galbot::aphropm_proto::PoseAvailability* temp = start_pose_;
  start_pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::unsafe_arena_release_start_pose() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.start_pose)
  
  ::galbot::aphropm_proto::PoseAvailability* temp = start_pose_;
  start_pose_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::_internal_mutable_start_pose() {
  
  if (start_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::PoseAvailability>(GetArena());
    start_pose_ = p;
  }
  return start_pose_;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::mutable_start_pose() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.start_pose)
  return _internal_mutable_start_pose();
}
inline void EvaluateGoalAvailabilityResponse::set_allocated_start_pose(::galbot::aphropm_proto::PoseAvailability* start_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_pose_;
  }
  if (start_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start_pose);
    if (message_arena != submessage_arena) {
      start_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pose, submessage_arena);
    }
    
  } else {
    
  }
  start_pose_ = start_pose;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.start_pose)
}

// .galbot.aphropm_proto.PoseAvailability goal_pose = 3;
inline bool EvaluateGoalAvailabilityResponse::_internal_has_goal_pose() const {
  return this != internal_default_instance() && goal_pose_ != nullptr;
}
inline bool EvaluateGoalAvailabilityResponse::has_goal_pose() const {
  return _internal_has_goal_pose();
}
inline void EvaluateGoalAvailabilityResponse::clear_goal_pose() {
  if (GetArena() == nullptr && goal_pose_ != nullptr) {
    delete goal_pose_;
  }
  goal_pose_ = nullptr;
}
inline const ::galbot::aphropm_proto::PoseAvailability& EvaluateGoalAvailabilityResponse::_internal_goal_pose() const {
  const ::galbot::aphropm_proto::PoseAvailability* p = goal_pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::PoseAvailability&>(
      ::galbot::aphropm_proto::_PoseAvailability_default_instance_);
}
inline const ::galbot::aphropm_proto::PoseAvailability& EvaluateGoalAvailabilityResponse::goal_pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.goal_pose)
  return _internal_goal_pose();
}
inline void EvaluateGoalAvailabilityResponse::unsafe_arena_set_allocated_goal_pose(
    ::galbot::aphropm_proto::PoseAvailability* goal_pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(goal_pose_);
  }
  goal_pose_ = goal_pose;
  if (goal_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.goal_pose)
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::release_goal_pose() {
  
  ::galbot::aphropm_proto::PoseAvailability* temp = goal_pose_;
  goal_pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::unsafe_arena_release_goal_pose() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.goal_pose)
  
  ::galbot::aphropm_proto::PoseAvailability* temp = goal_pose_;
  goal_pose_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::_internal_mutable_goal_pose() {
  
  if (goal_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::PoseAvailability>(GetArena());
    goal_pose_ = p;
  }
  return goal_pose_;
}
inline ::galbot::aphropm_proto::PoseAvailability* EvaluateGoalAvailabilityResponse::mutable_goal_pose() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.goal_pose)
  return _internal_mutable_goal_pose();
}
inline void EvaluateGoalAvailabilityResponse::set_allocated_goal_pose(::galbot::aphropm_proto::PoseAvailability* goal_pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete goal_pose_;
  }
  if (goal_pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(goal_pose);
    if (message_arena != submessage_arena) {
      goal_pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goal_pose, submessage_arena);
    }
    
  } else {
    
  }
  goal_pose_ = goal_pose;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.goal_pose)
}

// bool has_solution = 4;
inline void EvaluateGoalAvailabilityResponse::clear_has_solution() {
  has_solution_ = false;
}
inline bool EvaluateGoalAvailabilityResponse::_internal_has_solution() const {
  return has_solution_;
}
inline bool EvaluateGoalAvailabilityResponse::has_solution() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.has_solution)
  return _internal_has_solution();
}
inline void EvaluateGoalAvailabilityResponse::_internal_set_has_solution(bool value) {
  
  has_solution_ = value;
}
inline void EvaluateGoalAvailabilityResponse::set_has_solution(bool value) {
  _internal_set_has_solution(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.has_solution)
}

// bool path_collision = 5;
inline void EvaluateGoalAvailabilityResponse::clear_path_collision() {
  path_collision_ = false;
}
inline bool EvaluateGoalAvailabilityResponse::_internal_path_collision() const {
  return path_collision_;
}
inline bool EvaluateGoalAvailabilityResponse::path_collision() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.path_collision)
  return _internal_path_collision();
}
inline void EvaluateGoalAvailabilityResponse::_internal_set_path_collision(bool value) {
  
  path_collision_ = value;
}
inline void EvaluateGoalAvailabilityResponse::set_path_collision(bool value) {
  _internal_set_path_collision(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.path_collision)
}

// bool available = 6;
inline void EvaluateGoalAvailabilityResponse::clear_available() {
  available_ = false;
}
inline bool EvaluateGoalAvailabilityResponse::_internal_available() const {
  return available_;
}
inline bool EvaluateGoalAvailabilityResponse::available() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.available)
  return _internal_available();
}
inline void EvaluateGoalAvailabilityResponse::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void EvaluateGoalAvailabilityResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.EvaluateGoalAvailabilityResponse.available)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace aphropm_proto
}  // namespace galbot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::galbot::aphropm_proto::LoadEnvReq_EnvType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::LoadEnvReq_EnvType>() {
  return ::galbot::aphropm_proto::LoadEnvReq_EnvType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection>() {
  return ::galbot::aphropm_proto::MoveTrajectoryReq_HeadingDirection_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::NavigationResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::NavigationResponse_Status>() {
  return ::galbot::aphropm_proto::NavigationResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::NavigationResult_TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::NavigationResult_TaskStatus>() {
  return ::galbot::aphropm_proto::NavigationResult_TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::NavigationException_Exception> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::NavigationException_Exception>() {
  return ::galbot::aphropm_proto::NavigationException_Exception_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::NavigationException_SerLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::NavigationException_SerLevel>() {
  return ::galbot::aphropm_proto::NavigationException_SerLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fpns_5finterface_2eproto
