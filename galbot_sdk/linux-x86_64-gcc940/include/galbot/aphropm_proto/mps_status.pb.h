// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: galbot/aphropm_proto/mps_status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "galbot/singorix_proto/singorix_target.pb.h"
#include "galbot/aphropm_proto/common_planner_config.pb.h"
#include "galbot/core_proto/math.pb.h"
#include "galbot/spatial_proto/pose.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto;
namespace galbot {
namespace aphropm_proto {
class MotionPlannerOutput;
class MotionPlannerOutputDefaultTypeInternal;
extern MotionPlannerOutputDefaultTypeInternal _MotionPlannerOutput_default_instance_;
class PlannerStatus;
class PlannerStatusDefaultTypeInternal;
extern PlannerStatusDefaultTypeInternal _PlannerStatus_default_instance_;
class PlannerStatus_ForwardKinematicResultEntry_DoNotUse;
class PlannerStatus_ForwardKinematicResultEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_ForwardKinematicResultEntry_DoNotUseDefaultTypeInternal _PlannerStatus_ForwardKinematicResultEntry_DoNotUse_default_instance_;
class PlannerStatus_HardJointLowerLimitEntry_DoNotUse;
class PlannerStatus_HardJointLowerLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_HardJointLowerLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_HardJointLowerLimitEntry_DoNotUse_default_instance_;
class PlannerStatus_HardJointUpperLimitEntry_DoNotUse;
class PlannerStatus_HardJointUpperLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_HardJointUpperLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_HardJointUpperLimitEntry_DoNotUse_default_instance_;
class PlannerStatus_IkJointLowerLimitEntry_DoNotUse;
class PlannerStatus_IkJointLowerLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_IkJointLowerLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_IkJointLowerLimitEntry_DoNotUse_default_instance_;
class PlannerStatus_IkJointUpperLimitEntry_DoNotUse;
class PlannerStatus_IkJointUpperLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_IkJointUpperLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_IkJointUpperLimitEntry_DoNotUse_default_instance_;
class PlannerStatus_InverseKinematicResultEntry_DoNotUse;
class PlannerStatus_InverseKinematicResultEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_InverseKinematicResultEntry_DoNotUseDefaultTypeInternal _PlannerStatus_InverseKinematicResultEntry_DoNotUse_default_instance_;
class PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse;
class PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse_default_instance_;
class PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse;
class PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUseDefaultTypeInternal;
extern PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUseDefaultTypeInternal _PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse_default_instance_;
}  // namespace aphropm_proto
}  // namespace galbot
PROTOBUF_NAMESPACE_OPEN
template<> ::galbot::aphropm_proto::MotionPlannerOutput* Arena::CreateMaybeMessage<::galbot::aphropm_proto::MotionPlannerOutput>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_ForwardKinematicResultEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_ForwardKinematicResultEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_HardJointLowerLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_HardJointLowerLimitEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_HardJointUpperLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_HardJointUpperLimitEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_IkJointLowerLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_IkJointLowerLimitEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_IkJointUpperLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_IkJointUpperLimitEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_InverseKinematicResultEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_InverseKinematicResultEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse>(Arena*);
template<> ::galbot::aphropm_proto::PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace galbot {
namespace aphropm_proto {

enum MotionPlannerOutput_RpcErrorCode : int {
  MotionPlannerOutput_RpcErrorCode_UNKNOWN = 0,
  MotionPlannerOutput_RpcErrorCode_SUCCESS = 1,
  MotionPlannerOutput_RpcErrorCode_ERROR_TASK_IS_RUNING = 2,
  MotionPlannerOutput_RpcErrorCode_MotionPlannerOutput_RpcErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MotionPlannerOutput_RpcErrorCode_MotionPlannerOutput_RpcErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MotionPlannerOutput_RpcErrorCode_IsValid(int value);
constexpr MotionPlannerOutput_RpcErrorCode MotionPlannerOutput_RpcErrorCode_RpcErrorCode_MIN = MotionPlannerOutput_RpcErrorCode_UNKNOWN;
constexpr MotionPlannerOutput_RpcErrorCode MotionPlannerOutput_RpcErrorCode_RpcErrorCode_MAX = MotionPlannerOutput_RpcErrorCode_ERROR_TASK_IS_RUNING;
constexpr int MotionPlannerOutput_RpcErrorCode_RpcErrorCode_ARRAYSIZE = MotionPlannerOutput_RpcErrorCode_RpcErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionPlannerOutput_RpcErrorCode_descriptor();
template<typename T>
inline const std::string& MotionPlannerOutput_RpcErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionPlannerOutput_RpcErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionPlannerOutput_RpcErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionPlannerOutput_RpcErrorCode_descriptor(), enum_t_value);
}
inline bool MotionPlannerOutput_RpcErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionPlannerOutput_RpcErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionPlannerOutput_RpcErrorCode>(
    MotionPlannerOutput_RpcErrorCode_descriptor(), name, value);
}
enum PlannerStatus_ServiceStatus : int {
  PlannerStatus_ServiceStatus_SERVICE_STATUS_READY = 0,
  PlannerStatus_ServiceStatus_SERVICE_STATUS_BUSY = 1,
  PlannerStatus_ServiceStatus_SERVICE_STATUS_INITING = 2,
  PlannerStatus_ServiceStatus_SERVICE_STATUS_FINISHED = 3,
  PlannerStatus_ServiceStatus_SERVICE_STATUS_EXECUTE_FAILED = 4,
  PlannerStatus_ServiceStatus_PlannerStatus_ServiceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlannerStatus_ServiceStatus_PlannerStatus_ServiceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlannerStatus_ServiceStatus_IsValid(int value);
constexpr PlannerStatus_ServiceStatus PlannerStatus_ServiceStatus_ServiceStatus_MIN = PlannerStatus_ServiceStatus_SERVICE_STATUS_READY;
constexpr PlannerStatus_ServiceStatus PlannerStatus_ServiceStatus_ServiceStatus_MAX = PlannerStatus_ServiceStatus_SERVICE_STATUS_EXECUTE_FAILED;
constexpr int PlannerStatus_ServiceStatus_ServiceStatus_ARRAYSIZE = PlannerStatus_ServiceStatus_ServiceStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlannerStatus_ServiceStatus_descriptor();
template<typename T>
inline const std::string& PlannerStatus_ServiceStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlannerStatus_ServiceStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlannerStatus_ServiceStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlannerStatus_ServiceStatus_descriptor(), enum_t_value);
}
inline bool PlannerStatus_ServiceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlannerStatus_ServiceStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlannerStatus_ServiceStatus>(
    PlannerStatus_ServiceStatus_descriptor(), name, value);
}
enum PlannerStatus_ServiceErrorCode : int {
  PlannerStatus_ServiceErrorCode_NO_ERROR = 0,
  PlannerStatus_ServiceErrorCode_CAMERA_DEPTH_PARAM_INVALID = 1,
  PlannerStatus_ServiceErrorCode_POINT_CLOUD_INVALID = 2,
  PlannerStatus_ServiceErrorCode_PARAM_ERROR = 3,
  PlannerStatus_ServiceErrorCode_FUNTION_NOT_IMPLEMTED = 4,
  PlannerStatus_ServiceErrorCode_CURRENT_CHAIN_ATTACH_TOOL_UNSPPORTED = 6,
  PlannerStatus_ServiceErrorCode_READ_ANGLE_FROM_WBC_FAILED = 11,
  PlannerStatus_ServiceErrorCode_READ_BASE_TRANS_FROM_TF_FAILED = 12,
  PlannerStatus_ServiceErrorCode_INIT_FAIL_PLANNER_MANAGER = 13,
  PlannerStatus_ServiceErrorCode_REQUEST_SIZE_MISMATCH = 14,
  PlannerStatus_ServiceErrorCode_SET_FEASIBILITY_BOUND_FAILED = 15,
  PlannerStatus_ServiceErrorCode_PlannerStatus_ServiceErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlannerStatus_ServiceErrorCode_PlannerStatus_ServiceErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlannerStatus_ServiceErrorCode_IsValid(int value);
constexpr PlannerStatus_ServiceErrorCode PlannerStatus_ServiceErrorCode_ServiceErrorCode_MIN = PlannerStatus_ServiceErrorCode_NO_ERROR;
constexpr PlannerStatus_ServiceErrorCode PlannerStatus_ServiceErrorCode_ServiceErrorCode_MAX = PlannerStatus_ServiceErrorCode_SET_FEASIBILITY_BOUND_FAILED;
constexpr int PlannerStatus_ServiceErrorCode_ServiceErrorCode_ARRAYSIZE = PlannerStatus_ServiceErrorCode_ServiceErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlannerStatus_ServiceErrorCode_descriptor();
template<typename T>
inline const std::string& PlannerStatus_ServiceErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlannerStatus_ServiceErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlannerStatus_ServiceErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlannerStatus_ServiceErrorCode_descriptor(), enum_t_value);
}
inline bool PlannerStatus_ServiceErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlannerStatus_ServiceErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlannerStatus_ServiceErrorCode>(
    PlannerStatus_ServiceErrorCode_descriptor(), name, value);
}
// ===================================================================

class MotionPlannerOutput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.MotionPlannerOutput) */ {
 public:
  inline MotionPlannerOutput() : MotionPlannerOutput(nullptr) {}
  virtual ~MotionPlannerOutput();

  MotionPlannerOutput(const MotionPlannerOutput& from);
  MotionPlannerOutput(MotionPlannerOutput&& from) noexcept
    : MotionPlannerOutput() {
    *this = ::std::move(from);
  }

  inline MotionPlannerOutput& operator=(const MotionPlannerOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionPlannerOutput& operator=(MotionPlannerOutput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MotionPlannerOutput& default_instance();

  static inline const MotionPlannerOutput* internal_default_instance() {
    return reinterpret_cast<const MotionPlannerOutput*>(
               &_MotionPlannerOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MotionPlannerOutput& a, MotionPlannerOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionPlannerOutput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionPlannerOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionPlannerOutput* New() const final {
    return CreateMaybeMessage<MotionPlannerOutput>(nullptr);
  }

  MotionPlannerOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionPlannerOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionPlannerOutput& from);
  void MergeFrom(const MotionPlannerOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionPlannerOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.MotionPlannerOutput";
  }
  protected:
  explicit MotionPlannerOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MotionPlannerOutput_RpcErrorCode RpcErrorCode;
  static constexpr RpcErrorCode UNKNOWN =
    MotionPlannerOutput_RpcErrorCode_UNKNOWN;
  static constexpr RpcErrorCode SUCCESS =
    MotionPlannerOutput_RpcErrorCode_SUCCESS;
  static constexpr RpcErrorCode ERROR_TASK_IS_RUNING =
    MotionPlannerOutput_RpcErrorCode_ERROR_TASK_IS_RUNING;
  static inline bool RpcErrorCode_IsValid(int value) {
    return MotionPlannerOutput_RpcErrorCode_IsValid(value);
  }
  static constexpr RpcErrorCode RpcErrorCode_MIN =
    MotionPlannerOutput_RpcErrorCode_RpcErrorCode_MIN;
  static constexpr RpcErrorCode RpcErrorCode_MAX =
    MotionPlannerOutput_RpcErrorCode_RpcErrorCode_MAX;
  static constexpr int RpcErrorCode_ARRAYSIZE =
    MotionPlannerOutput_RpcErrorCode_RpcErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RpcErrorCode_descriptor() {
    return MotionPlannerOutput_RpcErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& RpcErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RpcErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RpcErrorCode_Name.");
    return MotionPlannerOutput_RpcErrorCode_Name(enum_t_value);
  }
  static inline bool RpcErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RpcErrorCode* value) {
    return MotionPlannerOutput_RpcErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDespFieldNumber = 2,
    kTimeStampFieldNumber = 3,
    kResFieldNumber = 1,
  };
  // string desp = 2;
  void clear_desp();
  const std::string& desp() const;
  void set_desp(const std::string& value);
  void set_desp(std::string&& value);
  void set_desp(const char* value);
  void set_desp(const char* value, size_t size);
  std::string* mutable_desp();
  std::string* release_desp();
  void set_allocated_desp(std::string* desp);
  private:
  const std::string& _internal_desp() const;
  void _internal_set_desp(const std::string& value);
  std::string* _internal_mutable_desp();
  public:

  // double time_stamp = 3;
  void clear_time_stamp();
  double time_stamp() const;
  void set_time_stamp(double value);
  private:
  double _internal_time_stamp() const;
  void _internal_set_time_stamp(double value);
  public:

  // int32 res = 1;
  void clear_res();
  ::PROTOBUF_NAMESPACE_ID::int32 res() const;
  void set_res(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_res() const;
  void _internal_set_res(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.MotionPlannerOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desp_;
  double time_stamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto;
};
// -------------------------------------------------------------------

class PlannerStatus_InverseKinematicResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_InverseKinematicResultEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_InverseKinematicResultEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_InverseKinematicResultEntry_DoNotUse();
  explicit PlannerStatus_InverseKinematicResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_InverseKinematicResultEntry_DoNotUse& other);
  static const PlannerStatus_InverseKinematicResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_InverseKinematicResultEntry_DoNotUse*>(&_PlannerStatus_InverseKinematicResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.InverseKinematicResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_ForwardKinematicResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_ForwardKinematicResultEntry_DoNotUse, 
    std::string, ::galbot::spatial_proto::Pose,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_ForwardKinematicResultEntry_DoNotUse, 
    std::string, ::galbot::spatial_proto::Pose,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_ForwardKinematicResultEntry_DoNotUse();
  explicit PlannerStatus_ForwardKinematicResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_ForwardKinematicResultEntry_DoNotUse& other);
  static const PlannerStatus_ForwardKinematicResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_ForwardKinematicResultEntry_DoNotUse*>(&_PlannerStatus_ForwardKinematicResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.ForwardKinematicResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_HardJointUpperLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_HardJointUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_HardJointUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_HardJointUpperLimitEntry_DoNotUse();
  explicit PlannerStatus_HardJointUpperLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_HardJointUpperLimitEntry_DoNotUse& other);
  static const PlannerStatus_HardJointUpperLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_HardJointUpperLimitEntry_DoNotUse*>(&_PlannerStatus_HardJointUpperLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.HardJointUpperLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_HardJointLowerLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_HardJointLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_HardJointLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_HardJointLowerLimitEntry_DoNotUse();
  explicit PlannerStatus_HardJointLowerLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_HardJointLowerLimitEntry_DoNotUse& other);
  static const PlannerStatus_HardJointLowerLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_HardJointLowerLimitEntry_DoNotUse*>(&_PlannerStatus_HardJointLowerLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.HardJointLowerLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[4];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_IkJointUpperLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_IkJointUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_IkJointUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_IkJointUpperLimitEntry_DoNotUse();
  explicit PlannerStatus_IkJointUpperLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_IkJointUpperLimitEntry_DoNotUse& other);
  static const PlannerStatus_IkJointUpperLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_IkJointUpperLimitEntry_DoNotUse*>(&_PlannerStatus_IkJointUpperLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.IkJointUpperLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_IkJointLowerLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_IkJointLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_IkJointLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_IkJointLowerLimitEntry_DoNotUse();
  explicit PlannerStatus_IkJointLowerLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_IkJointLowerLimitEntry_DoNotUse& other);
  static const PlannerStatus_IkJointLowerLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_IkJointLowerLimitEntry_DoNotUse*>(&_PlannerStatus_IkJointLowerLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.IkJointLowerLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse();
  explicit PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse& other);
  static const PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse*>(&_PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.SamplePlannerUpperLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse, 
    std::string, ::galbot::core_proto::Vector,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse();
  explicit PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse& other);
  static const PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse*>(&_PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "galbot.aphropm_proto.PlannerStatus.SamplePlannerLowerLimitEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class PlannerStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.PlannerStatus) */ {
 public:
  inline PlannerStatus() : PlannerStatus(nullptr) {}
  virtual ~PlannerStatus();

  PlannerStatus(const PlannerStatus& from);
  PlannerStatus(PlannerStatus&& from) noexcept
    : PlannerStatus() {
    *this = ::std::move(from);
  }

  inline PlannerStatus& operator=(const PlannerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlannerStatus& operator=(PlannerStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlannerStatus& default_instance();

  static inline const PlannerStatus* internal_default_instance() {
    return reinterpret_cast<const PlannerStatus*>(
               &_PlannerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlannerStatus& a, PlannerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlannerStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlannerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlannerStatus* New() const final {
    return CreateMaybeMessage<PlannerStatus>(nullptr);
  }

  PlannerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlannerStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlannerStatus& from);
  void MergeFrom(const PlannerStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.PlannerStatus";
  }
  protected:
  explicit PlannerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef PlannerStatus_ServiceStatus ServiceStatus;
  static constexpr ServiceStatus SERVICE_STATUS_READY =
    PlannerStatus_ServiceStatus_SERVICE_STATUS_READY;
  static constexpr ServiceStatus SERVICE_STATUS_BUSY =
    PlannerStatus_ServiceStatus_SERVICE_STATUS_BUSY;
  static constexpr ServiceStatus SERVICE_STATUS_INITING =
    PlannerStatus_ServiceStatus_SERVICE_STATUS_INITING;
  static constexpr ServiceStatus SERVICE_STATUS_FINISHED =
    PlannerStatus_ServiceStatus_SERVICE_STATUS_FINISHED;
  static constexpr ServiceStatus SERVICE_STATUS_EXECUTE_FAILED =
    PlannerStatus_ServiceStatus_SERVICE_STATUS_EXECUTE_FAILED;
  static inline bool ServiceStatus_IsValid(int value) {
    return PlannerStatus_ServiceStatus_IsValid(value);
  }
  static constexpr ServiceStatus ServiceStatus_MIN =
    PlannerStatus_ServiceStatus_ServiceStatus_MIN;
  static constexpr ServiceStatus ServiceStatus_MAX =
    PlannerStatus_ServiceStatus_ServiceStatus_MAX;
  static constexpr int ServiceStatus_ARRAYSIZE =
    PlannerStatus_ServiceStatus_ServiceStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServiceStatus_descriptor() {
    return PlannerStatus_ServiceStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ServiceStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServiceStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServiceStatus_Name.");
    return PlannerStatus_ServiceStatus_Name(enum_t_value);
  }
  static inline bool ServiceStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServiceStatus* value) {
    return PlannerStatus_ServiceStatus_Parse(name, value);
  }

  typedef PlannerStatus_ServiceErrorCode ServiceErrorCode;
  static constexpr ServiceErrorCode NO_ERROR =
    PlannerStatus_ServiceErrorCode_NO_ERROR;
  static constexpr ServiceErrorCode CAMERA_DEPTH_PARAM_INVALID =
    PlannerStatus_ServiceErrorCode_CAMERA_DEPTH_PARAM_INVALID;
  static constexpr ServiceErrorCode POINT_CLOUD_INVALID =
    PlannerStatus_ServiceErrorCode_POINT_CLOUD_INVALID;
  static constexpr ServiceErrorCode PARAM_ERROR =
    PlannerStatus_ServiceErrorCode_PARAM_ERROR;
  static constexpr ServiceErrorCode FUNTION_NOT_IMPLEMTED =
    PlannerStatus_ServiceErrorCode_FUNTION_NOT_IMPLEMTED;
  static constexpr ServiceErrorCode CURRENT_CHAIN_ATTACH_TOOL_UNSPPORTED =
    PlannerStatus_ServiceErrorCode_CURRENT_CHAIN_ATTACH_TOOL_UNSPPORTED;
  static constexpr ServiceErrorCode READ_ANGLE_FROM_WBC_FAILED =
    PlannerStatus_ServiceErrorCode_READ_ANGLE_FROM_WBC_FAILED;
  static constexpr ServiceErrorCode READ_BASE_TRANS_FROM_TF_FAILED =
    PlannerStatus_ServiceErrorCode_READ_BASE_TRANS_FROM_TF_FAILED;
  static constexpr ServiceErrorCode INIT_FAIL_PLANNER_MANAGER =
    PlannerStatus_ServiceErrorCode_INIT_FAIL_PLANNER_MANAGER;
  static constexpr ServiceErrorCode REQUEST_SIZE_MISMATCH =
    PlannerStatus_ServiceErrorCode_REQUEST_SIZE_MISMATCH;
  static constexpr ServiceErrorCode SET_FEASIBILITY_BOUND_FAILED =
    PlannerStatus_ServiceErrorCode_SET_FEASIBILITY_BOUND_FAILED;
  static inline bool ServiceErrorCode_IsValid(int value) {
    return PlannerStatus_ServiceErrorCode_IsValid(value);
  }
  static constexpr ServiceErrorCode ServiceErrorCode_MIN =
    PlannerStatus_ServiceErrorCode_ServiceErrorCode_MIN;
  static constexpr ServiceErrorCode ServiceErrorCode_MAX =
    PlannerStatus_ServiceErrorCode_ServiceErrorCode_MAX;
  static constexpr int ServiceErrorCode_ARRAYSIZE =
    PlannerStatus_ServiceErrorCode_ServiceErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServiceErrorCode_descriptor() {
    return PlannerStatus_ServiceErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& ServiceErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServiceErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServiceErrorCode_Name.");
    return PlannerStatus_ServiceErrorCode_Name(enum_t_value);
  }
  static inline bool ServiceErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServiceErrorCode* value) {
    return PlannerStatus_ServiceErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvObjsFieldNumber = 8,
    kInverseKinematicResultFieldNumber = 10,
    kForwardKinematicResultFieldNumber = 11,
    kHardJointUpperLimitFieldNumber = 12,
    kHardJointLowerLimitFieldNumber = 13,
    kIkJointUpperLimitFieldNumber = 14,
    kIkJointLowerLimitFieldNumber = 15,
    kSamplePlannerUpperLimitFieldNumber = 16,
    kSamplePlannerLowerLimitFieldNumber = 17,
    kTaskIdFieldNumber = 1,
    kErrorDespFieldNumber = 4,
    kIkSolverConfigFieldNumber = 5,
    kMotionPlannerConfigFieldNumber = 6,
    kTrajPlannerPropFieldNumber = 7,
    kSingorixTargetFieldNumber = 9,
    kCollisionResultFieldNumber = 18,
    kStatusFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
  };
  // repeated string env_objs = 8;
  int env_objs_size() const;
  private:
  int _internal_env_objs_size() const;
  public:
  void clear_env_objs();
  const std::string& env_objs(int index) const;
  std::string* mutable_env_objs(int index);
  void set_env_objs(int index, const std::string& value);
  void set_env_objs(int index, std::string&& value);
  void set_env_objs(int index, const char* value);
  void set_env_objs(int index, const char* value, size_t size);
  std::string* add_env_objs();
  void add_env_objs(const std::string& value);
  void add_env_objs(std::string&& value);
  void add_env_objs(const char* value);
  void add_env_objs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& env_objs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_env_objs();
  private:
  const std::string& _internal_env_objs(int index) const;
  std::string* _internal_add_env_objs();
  public:

  // map<string, .galbot.core_proto.Vector> inverse_kinematic_result = 10;
  int inverse_kinematic_result_size() const;
  private:
  int _internal_inverse_kinematic_result_size() const;
  public:
  void clear_inverse_kinematic_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_inverse_kinematic_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_inverse_kinematic_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      inverse_kinematic_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_inverse_kinematic_result();

  // map<string, .galbot.spatial_proto.Pose> forward_kinematic_result = 11;
  int forward_kinematic_result_size() const;
  private:
  int _internal_forward_kinematic_result_size() const;
  public:
  void clear_forward_kinematic_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >&
      _internal_forward_kinematic_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >*
      _internal_mutable_forward_kinematic_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >&
      forward_kinematic_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >*
      mutable_forward_kinematic_result();

  // map<string, .galbot.core_proto.Vector> hard_joint_upper_limit = 12;
  int hard_joint_upper_limit_size() const;
  private:
  int _internal_hard_joint_upper_limit_size() const;
  public:
  void clear_hard_joint_upper_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_hard_joint_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_hard_joint_upper_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      hard_joint_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_hard_joint_upper_limit();

  // map<string, .galbot.core_proto.Vector> hard_joint_lower_limit = 13;
  int hard_joint_lower_limit_size() const;
  private:
  int _internal_hard_joint_lower_limit_size() const;
  public:
  void clear_hard_joint_lower_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_hard_joint_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_hard_joint_lower_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      hard_joint_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_hard_joint_lower_limit();

  // map<string, .galbot.core_proto.Vector> ik_joint_upper_limit = 14;
  int ik_joint_upper_limit_size() const;
  private:
  int _internal_ik_joint_upper_limit_size() const;
  public:
  void clear_ik_joint_upper_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_ik_joint_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_ik_joint_upper_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      ik_joint_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_ik_joint_upper_limit();

  // map<string, .galbot.core_proto.Vector> ik_joint_lower_limit = 15;
  int ik_joint_lower_limit_size() const;
  private:
  int _internal_ik_joint_lower_limit_size() const;
  public:
  void clear_ik_joint_lower_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_ik_joint_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_ik_joint_lower_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      ik_joint_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_ik_joint_lower_limit();

  // map<string, .galbot.core_proto.Vector> sample_planner_upper_limit = 16;
  int sample_planner_upper_limit_size() const;
  private:
  int _internal_sample_planner_upper_limit_size() const;
  public:
  void clear_sample_planner_upper_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_sample_planner_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_sample_planner_upper_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      sample_planner_upper_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_sample_planner_upper_limit();

  // map<string, .galbot.core_proto.Vector> sample_planner_lower_limit = 17;
  int sample_planner_lower_limit_size() const;
  private:
  int _internal_sample_planner_lower_limit_size() const;
  public:
  void clear_sample_planner_lower_limit();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      _internal_sample_planner_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      _internal_mutable_sample_planner_lower_limit();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
      sample_planner_lower_limit() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
      mutable_sample_planner_lower_limit();

  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  void set_task_id(const std::string& value);
  void set_task_id(std::string&& value);
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  std::string* mutable_task_id();
  std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string error_desp = 4;
  void clear_error_desp();
  const std::string& error_desp() const;
  void set_error_desp(const std::string& value);
  void set_error_desp(std::string&& value);
  void set_error_desp(const char* value);
  void set_error_desp(const char* value, size_t size);
  std::string* mutable_error_desp();
  std::string* release_error_desp();
  void set_allocated_error_desp(std::string* error_desp);
  private:
  const std::string& _internal_error_desp() const;
  void _internal_set_error_desp(const std::string& value);
  std::string* _internal_mutable_error_desp();
  public:

  // .galbot.aphropm_proto.IKSolverConfig ik_solver_config = 5;
  bool has_ik_solver_config() const;
  private:
  bool _internal_has_ik_solver_config() const;
  public:
  void clear_ik_solver_config();
  const ::galbot::aphropm_proto::IKSolverConfig& ik_solver_config() const;
  ::galbot::aphropm_proto::IKSolverConfig* release_ik_solver_config();
  ::galbot::aphropm_proto::IKSolverConfig* mutable_ik_solver_config();
  void set_allocated_ik_solver_config(::galbot::aphropm_proto::IKSolverConfig* ik_solver_config);
  private:
  const ::galbot::aphropm_proto::IKSolverConfig& _internal_ik_solver_config() const;
  ::galbot::aphropm_proto::IKSolverConfig* _internal_mutable_ik_solver_config();
  public:
  void unsafe_arena_set_allocated_ik_solver_config(
      ::galbot::aphropm_proto::IKSolverConfig* ik_solver_config);
  ::galbot::aphropm_proto::IKSolverConfig* unsafe_arena_release_ik_solver_config();

  // .galbot.aphropm_proto.MotionPlannerConfig motion_planner_config = 6;
  bool has_motion_planner_config() const;
  private:
  bool _internal_has_motion_planner_config() const;
  public:
  void clear_motion_planner_config();
  const ::galbot::aphropm_proto::MotionPlannerConfig& motion_planner_config() const;
  ::galbot::aphropm_proto::MotionPlannerConfig* release_motion_planner_config();
  ::galbot::aphropm_proto::MotionPlannerConfig* mutable_motion_planner_config();
  void set_allocated_motion_planner_config(::galbot::aphropm_proto::MotionPlannerConfig* motion_planner_config);
  private:
  const ::galbot::aphropm_proto::MotionPlannerConfig& _internal_motion_planner_config() const;
  ::galbot::aphropm_proto::MotionPlannerConfig* _internal_mutable_motion_planner_config();
  public:
  void unsafe_arena_set_allocated_motion_planner_config(
      ::galbot::aphropm_proto::MotionPlannerConfig* motion_planner_config);
  ::galbot::aphropm_proto::MotionPlannerConfig* unsafe_arena_release_motion_planner_config();

  // .galbot.aphropm_proto.TrajPlannerProp traj_planner_prop = 7;
  bool has_traj_planner_prop() const;
  private:
  bool _internal_has_traj_planner_prop() const;
  public:
  void clear_traj_planner_prop();
  const ::galbot::aphropm_proto::TrajPlannerProp& traj_planner_prop() const;
  ::galbot::aphropm_proto::TrajPlannerProp* release_traj_planner_prop();
  ::galbot::aphropm_proto::TrajPlannerProp* mutable_traj_planner_prop();
  void set_allocated_traj_planner_prop(::galbot::aphropm_proto::TrajPlannerProp* traj_planner_prop);
  private:
  const ::galbot::aphropm_proto::TrajPlannerProp& _internal_traj_planner_prop() const;
  ::galbot::aphropm_proto::TrajPlannerProp* _internal_mutable_traj_planner_prop();
  public:
  void unsafe_arena_set_allocated_traj_planner_prop(
      ::galbot::aphropm_proto::TrajPlannerProp* traj_planner_prop);
  ::galbot::aphropm_proto::TrajPlannerProp* unsafe_arena_release_traj_planner_prop();

  // .galbot.singorix_proto.SingoriXTarget singorix_target = 9;
  bool has_singorix_target() const;
  private:
  bool _internal_has_singorix_target() const;
  public:
  void clear_singorix_target();
  const ::galbot::singorix_proto::SingoriXTarget& singorix_target() const;
  ::galbot::singorix_proto::SingoriXTarget* release_singorix_target();
  ::galbot::singorix_proto::SingoriXTarget* mutable_singorix_target();
  void set_allocated_singorix_target(::galbot::singorix_proto::SingoriXTarget* singorix_target);
  private:
  const ::galbot::singorix_proto::SingoriXTarget& _internal_singorix_target() const;
  ::galbot::singorix_proto::SingoriXTarget* _internal_mutable_singorix_target();
  public:
  void unsafe_arena_set_allocated_singorix_target(
      ::galbot::singorix_proto::SingoriXTarget* singorix_target);
  ::galbot::singorix_proto::SingoriXTarget* unsafe_arena_release_singorix_target();

  // .galbot.core_proto.Vector collision_result = 18;
  bool has_collision_result() const;
  private:
  bool _internal_has_collision_result() const;
  public:
  void clear_collision_result();
  const ::galbot::core_proto::Vector& collision_result() const;
  ::galbot::core_proto::Vector* release_collision_result();
  ::galbot::core_proto::Vector* mutable_collision_result();
  void set_allocated_collision_result(::galbot::core_proto::Vector* collision_result);
  private:
  const ::galbot::core_proto::Vector& _internal_collision_result() const;
  ::galbot::core_proto::Vector* _internal_mutable_collision_result();
  public:
  void unsafe_arena_set_allocated_collision_result(
      ::galbot::core_proto::Vector* collision_result);
  ::galbot::core_proto::Vector* unsafe_arena_release_collision_result();

  // .galbot.aphropm_proto.PlannerStatus.ServiceStatus status = 2;
  void clear_status();
  ::galbot::aphropm_proto::PlannerStatus_ServiceStatus status() const;
  void set_status(::galbot::aphropm_proto::PlannerStatus_ServiceStatus value);
  private:
  ::galbot::aphropm_proto::PlannerStatus_ServiceStatus _internal_status() const;
  void _internal_set_status(::galbot::aphropm_proto::PlannerStatus_ServiceStatus value);
  public:

  // int32 error_code = 3;
  void clear_error_code();
  ::PROTOBUF_NAMESPACE_ID::int32 error_code() const;
  void set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_error_code() const;
  void _internal_set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.PlannerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> env_objs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_InverseKinematicResultEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> inverse_kinematic_result_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_ForwardKinematicResultEntry_DoNotUse,
      std::string, ::galbot::spatial_proto::Pose,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> forward_kinematic_result_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_HardJointUpperLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> hard_joint_upper_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_HardJointLowerLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> hard_joint_lower_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_IkJointUpperLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> ik_joint_upper_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_IkJointLowerLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> ik_joint_lower_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_SamplePlannerUpperLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> sample_planner_upper_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      PlannerStatus_SamplePlannerLowerLimitEntry_DoNotUse,
      std::string, ::galbot::core_proto::Vector,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> sample_planner_lower_limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_desp_;
  ::galbot::aphropm_proto::IKSolverConfig* ik_solver_config_;
  ::galbot::aphropm_proto::MotionPlannerConfig* motion_planner_config_;
  ::galbot::aphropm_proto::TrajPlannerProp* traj_planner_prop_;
  ::galbot::singorix_proto::SingoriXTarget* singorix_target_;
  ::galbot::core_proto::Vector* collision_result_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::int32 error_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MotionPlannerOutput

// int32 res = 1;
inline void MotionPlannerOutput::clear_res() {
  res_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionPlannerOutput::_internal_res() const {
  return res_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionPlannerOutput::res() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MotionPlannerOutput.res)
  return _internal_res();
}
inline void MotionPlannerOutput::_internal_set_res(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  res_ = value;
}
inline void MotionPlannerOutput::set_res(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MotionPlannerOutput.res)
}

// string desp = 2;
inline void MotionPlannerOutput::clear_desp() {
  desp_.ClearToEmpty();
}
inline const std::string& MotionPlannerOutput::desp() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MotionPlannerOutput.desp)
  return _internal_desp();
}
inline void MotionPlannerOutput::set_desp(const std::string& value) {
  _internal_set_desp(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MotionPlannerOutput.desp)
}
inline std::string* MotionPlannerOutput::mutable_desp() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.MotionPlannerOutput.desp)
  return _internal_mutable_desp();
}
inline const std::string& MotionPlannerOutput::_internal_desp() const {
  return desp_.Get();
}
inline void MotionPlannerOutput::_internal_set_desp(const std::string& value) {
  
  desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void MotionPlannerOutput::set_desp(std::string&& value) {
  
  desp_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.MotionPlannerOutput.desp)
}
inline void MotionPlannerOutput::set_desp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.MotionPlannerOutput.desp)
}
inline void MotionPlannerOutput::set_desp(const char* value,
    size_t size) {
  
  desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.MotionPlannerOutput.desp)
}
inline std::string* MotionPlannerOutput::_internal_mutable_desp() {
  
  return desp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* MotionPlannerOutput::release_desp() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.MotionPlannerOutput.desp)
  return desp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MotionPlannerOutput::set_allocated_desp(std::string* desp) {
  if (desp != nullptr) {
    
  } else {
    
  }
  desp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desp,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.MotionPlannerOutput.desp)
}

// double time_stamp = 3;
inline void MotionPlannerOutput::clear_time_stamp() {
  time_stamp_ = 0;
}
inline double MotionPlannerOutput::_internal_time_stamp() const {
  return time_stamp_;
}
inline double MotionPlannerOutput::time_stamp() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.MotionPlannerOutput.time_stamp)
  return _internal_time_stamp();
}
inline void MotionPlannerOutput::_internal_set_time_stamp(double value) {
  
  time_stamp_ = value;
}
inline void MotionPlannerOutput::set_time_stamp(double value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.MotionPlannerOutput.time_stamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlannerStatus

// string task_id = 1;
inline void PlannerStatus::clear_task_id() {
  task_id_.ClearToEmpty();
}
inline const std::string& PlannerStatus::task_id() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.task_id)
  return _internal_task_id();
}
inline void PlannerStatus::set_task_id(const std::string& value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.task_id)
}
inline std::string* PlannerStatus::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.task_id)
  return _internal_mutable_task_id();
}
inline const std::string& PlannerStatus::_internal_task_id() const {
  return task_id_.Get();
}
inline void PlannerStatus::_internal_set_task_id(const std::string& value) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlannerStatus::set_task_id(std::string&& value) {
  
  task_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.PlannerStatus.task_id)
}
inline void PlannerStatus::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.PlannerStatus.task_id)
}
inline void PlannerStatus::set_task_id(const char* value,
    size_t size) {
  
  task_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.PlannerStatus.task_id)
}
inline std::string* PlannerStatus::_internal_mutable_task_id() {
  
  return task_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlannerStatus::release_task_id() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.task_id)
  return task_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlannerStatus::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  task_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.task_id)
}

// .galbot.aphropm_proto.PlannerStatus.ServiceStatus status = 2;
inline void PlannerStatus::clear_status() {
  status_ = 0;
}
inline ::galbot::aphropm_proto::PlannerStatus_ServiceStatus PlannerStatus::_internal_status() const {
  return static_cast< ::galbot::aphropm_proto::PlannerStatus_ServiceStatus >(status_);
}
inline ::galbot::aphropm_proto::PlannerStatus_ServiceStatus PlannerStatus::status() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.status)
  return _internal_status();
}
inline void PlannerStatus::_internal_set_status(::galbot::aphropm_proto::PlannerStatus_ServiceStatus value) {
  
  status_ = value;
}
inline void PlannerStatus::set_status(::galbot::aphropm_proto::PlannerStatus_ServiceStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.status)
}

// int32 error_code = 3;
inline void PlannerStatus::clear_error_code() {
  error_code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlannerStatus::_internal_error_code() const {
  return error_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlannerStatus::error_code() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.error_code)
  return _internal_error_code();
}
inline void PlannerStatus::_internal_set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  error_code_ = value;
}
inline void PlannerStatus::set_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.error_code)
}

// string error_desp = 4;
inline void PlannerStatus::clear_error_desp() {
  error_desp_.ClearToEmpty();
}
inline const std::string& PlannerStatus::error_desp() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.error_desp)
  return _internal_error_desp();
}
inline void PlannerStatus::set_error_desp(const std::string& value) {
  _internal_set_error_desp(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.error_desp)
}
inline std::string* PlannerStatus::mutable_error_desp() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.error_desp)
  return _internal_mutable_error_desp();
}
inline const std::string& PlannerStatus::_internal_error_desp() const {
  return error_desp_.Get();
}
inline void PlannerStatus::_internal_set_error_desp(const std::string& value) {
  
  error_desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlannerStatus::set_error_desp(std::string&& value) {
  
  error_desp_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.PlannerStatus.error_desp)
}
inline void PlannerStatus::set_error_desp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.PlannerStatus.error_desp)
}
inline void PlannerStatus::set_error_desp(const char* value,
    size_t size) {
  
  error_desp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.PlannerStatus.error_desp)
}
inline std::string* PlannerStatus::_internal_mutable_error_desp() {
  
  return error_desp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlannerStatus::release_error_desp() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.error_desp)
  return error_desp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlannerStatus::set_allocated_error_desp(std::string* error_desp) {
  if (error_desp != nullptr) {
    
  } else {
    
  }
  error_desp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_desp,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.error_desp)
}

// .galbot.aphropm_proto.IKSolverConfig ik_solver_config = 5;
inline bool PlannerStatus::_internal_has_ik_solver_config() const {
  return this != internal_default_instance() && ik_solver_config_ != nullptr;
}
inline bool PlannerStatus::has_ik_solver_config() const {
  return _internal_has_ik_solver_config();
}
inline const ::galbot::aphropm_proto::IKSolverConfig& PlannerStatus::_internal_ik_solver_config() const {
  const ::galbot::aphropm_proto::IKSolverConfig* p = ik_solver_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::IKSolverConfig&>(
      ::galbot::aphropm_proto::_IKSolverConfig_default_instance_);
}
inline const ::galbot::aphropm_proto::IKSolverConfig& PlannerStatus::ik_solver_config() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.ik_solver_config)
  return _internal_ik_solver_config();
}
inline void PlannerStatus::unsafe_arena_set_allocated_ik_solver_config(
    ::galbot::aphropm_proto::IKSolverConfig* ik_solver_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ik_solver_config_);
  }
  ik_solver_config_ = ik_solver_config;
  if (ik_solver_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PlannerStatus.ik_solver_config)
}
inline ::galbot::aphropm_proto::IKSolverConfig* PlannerStatus::release_ik_solver_config() {
  
  ::galbot::aphropm_proto::IKSolverConfig* temp = ik_solver_config_;
  ik_solver_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::IKSolverConfig* PlannerStatus::unsafe_arena_release_ik_solver_config() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.ik_solver_config)
  
  ::galbot::aphropm_proto::IKSolverConfig* temp = ik_solver_config_;
  ik_solver_config_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::IKSolverConfig* PlannerStatus::_internal_mutable_ik_solver_config() {
  
  if (ik_solver_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::IKSolverConfig>(GetArena());
    ik_solver_config_ = p;
  }
  return ik_solver_config_;
}
inline ::galbot::aphropm_proto::IKSolverConfig* PlannerStatus::mutable_ik_solver_config() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.ik_solver_config)
  return _internal_mutable_ik_solver_config();
}
inline void PlannerStatus::set_allocated_ik_solver_config(::galbot::aphropm_proto::IKSolverConfig* ik_solver_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ik_solver_config_);
  }
  if (ik_solver_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ik_solver_config)->GetArena();
    if (message_arena != submessage_arena) {
      ik_solver_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ik_solver_config, submessage_arena);
    }
    
  } else {
    
  }
  ik_solver_config_ = ik_solver_config;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.ik_solver_config)
}

// .galbot.aphropm_proto.MotionPlannerConfig motion_planner_config = 6;
inline bool PlannerStatus::_internal_has_motion_planner_config() const {
  return this != internal_default_instance() && motion_planner_config_ != nullptr;
}
inline bool PlannerStatus::has_motion_planner_config() const {
  return _internal_has_motion_planner_config();
}
inline const ::galbot::aphropm_proto::MotionPlannerConfig& PlannerStatus::_internal_motion_planner_config() const {
  const ::galbot::aphropm_proto::MotionPlannerConfig* p = motion_planner_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::MotionPlannerConfig&>(
      ::galbot::aphropm_proto::_MotionPlannerConfig_default_instance_);
}
inline const ::galbot::aphropm_proto::MotionPlannerConfig& PlannerStatus::motion_planner_config() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.motion_planner_config)
  return _internal_motion_planner_config();
}
inline void PlannerStatus::unsafe_arena_set_allocated_motion_planner_config(
    ::galbot::aphropm_proto::MotionPlannerConfig* motion_planner_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_planner_config_);
  }
  motion_planner_config_ = motion_planner_config;
  if (motion_planner_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PlannerStatus.motion_planner_config)
}
inline ::galbot::aphropm_proto::MotionPlannerConfig* PlannerStatus::release_motion_planner_config() {
  
  ::galbot::aphropm_proto::MotionPlannerConfig* temp = motion_planner_config_;
  motion_planner_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::MotionPlannerConfig* PlannerStatus::unsafe_arena_release_motion_planner_config() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.motion_planner_config)
  
  ::galbot::aphropm_proto::MotionPlannerConfig* temp = motion_planner_config_;
  motion_planner_config_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::MotionPlannerConfig* PlannerStatus::_internal_mutable_motion_planner_config() {
  
  if (motion_planner_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::MotionPlannerConfig>(GetArena());
    motion_planner_config_ = p;
  }
  return motion_planner_config_;
}
inline ::galbot::aphropm_proto::MotionPlannerConfig* PlannerStatus::mutable_motion_planner_config() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.motion_planner_config)
  return _internal_mutable_motion_planner_config();
}
inline void PlannerStatus::set_allocated_motion_planner_config(::galbot::aphropm_proto::MotionPlannerConfig* motion_planner_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_planner_config_);
  }
  if (motion_planner_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(motion_planner_config)->GetArena();
    if (message_arena != submessage_arena) {
      motion_planner_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, motion_planner_config, submessage_arena);
    }
    
  } else {
    
  }
  motion_planner_config_ = motion_planner_config;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.motion_planner_config)
}

// .galbot.aphropm_proto.TrajPlannerProp traj_planner_prop = 7;
inline bool PlannerStatus::_internal_has_traj_planner_prop() const {
  return this != internal_default_instance() && traj_planner_prop_ != nullptr;
}
inline bool PlannerStatus::has_traj_planner_prop() const {
  return _internal_has_traj_planner_prop();
}
inline const ::galbot::aphropm_proto::TrajPlannerProp& PlannerStatus::_internal_traj_planner_prop() const {
  const ::galbot::aphropm_proto::TrajPlannerProp* p = traj_planner_prop_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::TrajPlannerProp&>(
      ::galbot::aphropm_proto::_TrajPlannerProp_default_instance_);
}
inline const ::galbot::aphropm_proto::TrajPlannerProp& PlannerStatus::traj_planner_prop() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.traj_planner_prop)
  return _internal_traj_planner_prop();
}
inline void PlannerStatus::unsafe_arena_set_allocated_traj_planner_prop(
    ::galbot::aphropm_proto::TrajPlannerProp* traj_planner_prop) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traj_planner_prop_);
  }
  traj_planner_prop_ = traj_planner_prop;
  if (traj_planner_prop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PlannerStatus.traj_planner_prop)
}
inline ::galbot::aphropm_proto::TrajPlannerProp* PlannerStatus::release_traj_planner_prop() {
  
  ::galbot::aphropm_proto::TrajPlannerProp* temp = traj_planner_prop_;
  traj_planner_prop_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::TrajPlannerProp* PlannerStatus::unsafe_arena_release_traj_planner_prop() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.traj_planner_prop)
  
  ::galbot::aphropm_proto::TrajPlannerProp* temp = traj_planner_prop_;
  traj_planner_prop_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::TrajPlannerProp* PlannerStatus::_internal_mutable_traj_planner_prop() {
  
  if (traj_planner_prop_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::TrajPlannerProp>(GetArena());
    traj_planner_prop_ = p;
  }
  return traj_planner_prop_;
}
inline ::galbot::aphropm_proto::TrajPlannerProp* PlannerStatus::mutable_traj_planner_prop() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.traj_planner_prop)
  return _internal_mutable_traj_planner_prop();
}
inline void PlannerStatus::set_allocated_traj_planner_prop(::galbot::aphropm_proto::TrajPlannerProp* traj_planner_prop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(traj_planner_prop_);
  }
  if (traj_planner_prop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traj_planner_prop)->GetArena();
    if (message_arena != submessage_arena) {
      traj_planner_prop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traj_planner_prop, submessage_arena);
    }
    
  } else {
    
  }
  traj_planner_prop_ = traj_planner_prop;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.traj_planner_prop)
}

// repeated string env_objs = 8;
inline int PlannerStatus::_internal_env_objs_size() const {
  return env_objs_.size();
}
inline int PlannerStatus::env_objs_size() const {
  return _internal_env_objs_size();
}
inline void PlannerStatus::clear_env_objs() {
  env_objs_.Clear();
}
inline std::string* PlannerStatus::add_env_objs() {
  // @@protoc_insertion_point(field_add_mutable:galbot.aphropm_proto.PlannerStatus.env_objs)
  return _internal_add_env_objs();
}
inline const std::string& PlannerStatus::_internal_env_objs(int index) const {
  return env_objs_.Get(index);
}
inline const std::string& PlannerStatus::env_objs(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.env_objs)
  return _internal_env_objs(index);
}
inline std::string* PlannerStatus::mutable_env_objs(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.env_objs)
  return env_objs_.Mutable(index);
}
inline void PlannerStatus::set_env_objs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.env_objs)
  env_objs_.Mutable(index)->assign(value);
}
inline void PlannerStatus::set_env_objs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PlannerStatus.env_objs)
  env_objs_.Mutable(index)->assign(std::move(value));
}
inline void PlannerStatus::set_env_objs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  env_objs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline void PlannerStatus::set_env_objs(int index, const char* value, size_t size) {
  env_objs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline std::string* PlannerStatus::_internal_add_env_objs() {
  return env_objs_.Add();
}
inline void PlannerStatus::add_env_objs(const std::string& value) {
  env_objs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline void PlannerStatus::add_env_objs(std::string&& value) {
  env_objs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline void PlannerStatus::add_env_objs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  env_objs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline void PlannerStatus::add_env_objs(const char* value, size_t size) {
  env_objs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:galbot.aphropm_proto.PlannerStatus.env_objs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PlannerStatus::env_objs() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.PlannerStatus.env_objs)
  return env_objs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PlannerStatus::mutable_env_objs() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.PlannerStatus.env_objs)
  return &env_objs_;
}

// .galbot.singorix_proto.SingoriXTarget singorix_target = 9;
inline bool PlannerStatus::_internal_has_singorix_target() const {
  return this != internal_default_instance() && singorix_target_ != nullptr;
}
inline bool PlannerStatus::has_singorix_target() const {
  return _internal_has_singorix_target();
}
inline const ::galbot::singorix_proto::SingoriXTarget& PlannerStatus::_internal_singorix_target() const {
  const ::galbot::singorix_proto::SingoriXTarget* p = singorix_target_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::singorix_proto::SingoriXTarget&>(
      ::galbot::singorix_proto::_SingoriXTarget_default_instance_);
}
inline const ::galbot::singorix_proto::SingoriXTarget& PlannerStatus::singorix_target() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.singorix_target)
  return _internal_singorix_target();
}
inline void PlannerStatus::unsafe_arena_set_allocated_singorix_target(
    ::galbot::singorix_proto::SingoriXTarget* singorix_target) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(singorix_target_);
  }
  singorix_target_ = singorix_target;
  if (singorix_target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PlannerStatus.singorix_target)
}
inline ::galbot::singorix_proto::SingoriXTarget* PlannerStatus::release_singorix_target() {
  
  ::galbot::singorix_proto::SingoriXTarget* temp = singorix_target_;
  singorix_target_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::singorix_proto::SingoriXTarget* PlannerStatus::unsafe_arena_release_singorix_target() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.singorix_target)
  
  ::galbot::singorix_proto::SingoriXTarget* temp = singorix_target_;
  singorix_target_ = nullptr;
  return temp;
}
inline ::galbot::singorix_proto::SingoriXTarget* PlannerStatus::_internal_mutable_singorix_target() {
  
  if (singorix_target_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::singorix_proto::SingoriXTarget>(GetArena());
    singorix_target_ = p;
  }
  return singorix_target_;
}
inline ::galbot::singorix_proto::SingoriXTarget* PlannerStatus::mutable_singorix_target() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.singorix_target)
  return _internal_mutable_singorix_target();
}
inline void PlannerStatus::set_allocated_singorix_target(::galbot::singorix_proto::SingoriXTarget* singorix_target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(singorix_target_);
  }
  if (singorix_target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(singorix_target)->GetArena();
    if (message_arena != submessage_arena) {
      singorix_target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, singorix_target, submessage_arena);
    }
    
  } else {
    
  }
  singorix_target_ = singorix_target;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.singorix_target)
}

// map<string, .galbot.core_proto.Vector> inverse_kinematic_result = 10;
inline int PlannerStatus::_internal_inverse_kinematic_result_size() const {
  return inverse_kinematic_result_.size();
}
inline int PlannerStatus::inverse_kinematic_result_size() const {
  return _internal_inverse_kinematic_result_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_inverse_kinematic_result() const {
  return inverse_kinematic_result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::inverse_kinematic_result() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.inverse_kinematic_result)
  return _internal_inverse_kinematic_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_inverse_kinematic_result() {
  return inverse_kinematic_result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_inverse_kinematic_result() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.inverse_kinematic_result)
  return _internal_mutable_inverse_kinematic_result();
}

// map<string, .galbot.spatial_proto.Pose> forward_kinematic_result = 11;
inline int PlannerStatus::_internal_forward_kinematic_result_size() const {
  return forward_kinematic_result_.size();
}
inline int PlannerStatus::forward_kinematic_result_size() const {
  return _internal_forward_kinematic_result_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >&
PlannerStatus::_internal_forward_kinematic_result() const {
  return forward_kinematic_result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >&
PlannerStatus::forward_kinematic_result() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.forward_kinematic_result)
  return _internal_forward_kinematic_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >*
PlannerStatus::_internal_mutable_forward_kinematic_result() {
  return forward_kinematic_result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::spatial_proto::Pose >*
PlannerStatus::mutable_forward_kinematic_result() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.forward_kinematic_result)
  return _internal_mutable_forward_kinematic_result();
}

// map<string, .galbot.core_proto.Vector> hard_joint_upper_limit = 12;
inline int PlannerStatus::_internal_hard_joint_upper_limit_size() const {
  return hard_joint_upper_limit_.size();
}
inline int PlannerStatus::hard_joint_upper_limit_size() const {
  return _internal_hard_joint_upper_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_hard_joint_upper_limit() const {
  return hard_joint_upper_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::hard_joint_upper_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.hard_joint_upper_limit)
  return _internal_hard_joint_upper_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_hard_joint_upper_limit() {
  return hard_joint_upper_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_hard_joint_upper_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.hard_joint_upper_limit)
  return _internal_mutable_hard_joint_upper_limit();
}

// map<string, .galbot.core_proto.Vector> hard_joint_lower_limit = 13;
inline int PlannerStatus::_internal_hard_joint_lower_limit_size() const {
  return hard_joint_lower_limit_.size();
}
inline int PlannerStatus::hard_joint_lower_limit_size() const {
  return _internal_hard_joint_lower_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_hard_joint_lower_limit() const {
  return hard_joint_lower_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::hard_joint_lower_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.hard_joint_lower_limit)
  return _internal_hard_joint_lower_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_hard_joint_lower_limit() {
  return hard_joint_lower_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_hard_joint_lower_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.hard_joint_lower_limit)
  return _internal_mutable_hard_joint_lower_limit();
}

// map<string, .galbot.core_proto.Vector> ik_joint_upper_limit = 14;
inline int PlannerStatus::_internal_ik_joint_upper_limit_size() const {
  return ik_joint_upper_limit_.size();
}
inline int PlannerStatus::ik_joint_upper_limit_size() const {
  return _internal_ik_joint_upper_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_ik_joint_upper_limit() const {
  return ik_joint_upper_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::ik_joint_upper_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.ik_joint_upper_limit)
  return _internal_ik_joint_upper_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_ik_joint_upper_limit() {
  return ik_joint_upper_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_ik_joint_upper_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.ik_joint_upper_limit)
  return _internal_mutable_ik_joint_upper_limit();
}

// map<string, .galbot.core_proto.Vector> ik_joint_lower_limit = 15;
inline int PlannerStatus::_internal_ik_joint_lower_limit_size() const {
  return ik_joint_lower_limit_.size();
}
inline int PlannerStatus::ik_joint_lower_limit_size() const {
  return _internal_ik_joint_lower_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_ik_joint_lower_limit() const {
  return ik_joint_lower_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::ik_joint_lower_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.ik_joint_lower_limit)
  return _internal_ik_joint_lower_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_ik_joint_lower_limit() {
  return ik_joint_lower_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_ik_joint_lower_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.ik_joint_lower_limit)
  return _internal_mutable_ik_joint_lower_limit();
}

// map<string, .galbot.core_proto.Vector> sample_planner_upper_limit = 16;
inline int PlannerStatus::_internal_sample_planner_upper_limit_size() const {
  return sample_planner_upper_limit_.size();
}
inline int PlannerStatus::sample_planner_upper_limit_size() const {
  return _internal_sample_planner_upper_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_sample_planner_upper_limit() const {
  return sample_planner_upper_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::sample_planner_upper_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.sample_planner_upper_limit)
  return _internal_sample_planner_upper_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_sample_planner_upper_limit() {
  return sample_planner_upper_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_sample_planner_upper_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.sample_planner_upper_limit)
  return _internal_mutable_sample_planner_upper_limit();
}

// map<string, .galbot.core_proto.Vector> sample_planner_lower_limit = 17;
inline int PlannerStatus::_internal_sample_planner_lower_limit_size() const {
  return sample_planner_lower_limit_.size();
}
inline int PlannerStatus::sample_planner_lower_limit_size() const {
  return _internal_sample_planner_lower_limit_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::_internal_sample_planner_lower_limit() const {
  return sample_planner_lower_limit_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >&
PlannerStatus::sample_planner_lower_limit() const {
  // @@protoc_insertion_point(field_map:galbot.aphropm_proto.PlannerStatus.sample_planner_lower_limit)
  return _internal_sample_planner_lower_limit();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::_internal_mutable_sample_planner_lower_limit() {
  return sample_planner_lower_limit_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::galbot::core_proto::Vector >*
PlannerStatus::mutable_sample_planner_lower_limit() {
  // @@protoc_insertion_point(field_mutable_map:galbot.aphropm_proto.PlannerStatus.sample_planner_lower_limit)
  return _internal_mutable_sample_planner_lower_limit();
}

// .galbot.core_proto.Vector collision_result = 18;
inline bool PlannerStatus::_internal_has_collision_result() const {
  return this != internal_default_instance() && collision_result_ != nullptr;
}
inline bool PlannerStatus::has_collision_result() const {
  return _internal_has_collision_result();
}
inline const ::galbot::core_proto::Vector& PlannerStatus::_internal_collision_result() const {
  const ::galbot::core_proto::Vector* p = collision_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::core_proto::Vector&>(
      ::galbot::core_proto::_Vector_default_instance_);
}
inline const ::galbot::core_proto::Vector& PlannerStatus::collision_result() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PlannerStatus.collision_result)
  return _internal_collision_result();
}
inline void PlannerStatus::unsafe_arena_set_allocated_collision_result(
    ::galbot::core_proto::Vector* collision_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collision_result_);
  }
  collision_result_ = collision_result;
  if (collision_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PlannerStatus.collision_result)
}
inline ::galbot::core_proto::Vector* PlannerStatus::release_collision_result() {
  
  ::galbot::core_proto::Vector* temp = collision_result_;
  collision_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::core_proto::Vector* PlannerStatus::unsafe_arena_release_collision_result() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PlannerStatus.collision_result)
  
  ::galbot::core_proto::Vector* temp = collision_result_;
  collision_result_ = nullptr;
  return temp;
}
inline ::galbot::core_proto::Vector* PlannerStatus::_internal_mutable_collision_result() {
  
  if (collision_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::core_proto::Vector>(GetArena());
    collision_result_ = p;
  }
  return collision_result_;
}
inline ::galbot::core_proto::Vector* PlannerStatus::mutable_collision_result() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PlannerStatus.collision_result)
  return _internal_mutable_collision_result();
}
inline void PlannerStatus::set_allocated_collision_result(::galbot::core_proto::Vector* collision_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(collision_result_);
  }
  if (collision_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collision_result)->GetArena();
    if (message_arena != submessage_arena) {
      collision_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collision_result, submessage_arena);
    }
    
  } else {
    
  }
  collision_result_ = collision_result;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PlannerStatus.collision_result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace aphropm_proto
}  // namespace galbot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::galbot::aphropm_proto::MotionPlannerOutput_RpcErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::MotionPlannerOutput_RpcErrorCode>() {
  return ::galbot::aphropm_proto::MotionPlannerOutput_RpcErrorCode_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::PlannerStatus_ServiceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::PlannerStatus_ServiceStatus>() {
  return ::galbot::aphropm_proto::PlannerStatus_ServiceStatus_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::PlannerStatus_ServiceErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::PlannerStatus_ServiceErrorCode>() {
  return ::galbot::aphropm_proto::PlannerStatus_ServiceErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fmps_5fstatus_2eproto
