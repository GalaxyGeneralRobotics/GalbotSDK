// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: galbot/aphropm_proto/common_def.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "galbot/core_proto/math.pb.h"
#include "galbot/spatial_proto/pose.pb.h"
#include "galbot/spatial_proto/twist.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
namespace galbot {
namespace aphropm_proto {
class BaseState;
class BaseStateDefaultTypeInternal;
extern BaseStateDefaultTypeInternal _BaseState_default_instance_;
class BodyState;
class BodyStateDefaultTypeInternal;
extern BodyStateDefaultTypeInternal _BodyState_default_instance_;
class ChainFrame;
class ChainFrameDefaultTypeInternal;
extern ChainFrameDefaultTypeInternal _ChainFrame_default_instance_;
class ChainState;
class ChainStateDefaultTypeInternal;
extern ChainStateDefaultTypeInternal _ChainState_default_instance_;
class JointState;
class JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class ParentFrame;
class ParentFrameDefaultTypeInternal;
extern ParentFrameDefaultTypeInternal _ParentFrame_default_instance_;
class PoseState;
class PoseStateDefaultTypeInternal;
extern PoseStateDefaultTypeInternal _PoseState_default_instance_;
class RobotStates;
class RobotStatesDefaultTypeInternal;
extern RobotStatesDefaultTypeInternal _RobotStates_default_instance_;
class RobotTrajectory;
class RobotTrajectoryDefaultTypeInternal;
extern RobotTrajectoryDefaultTypeInternal _RobotTrajectory_default_instance_;
class RobotTrajectoryVec;
class RobotTrajectoryVecDefaultTypeInternal;
extern RobotTrajectoryVecDefaultTypeInternal _RobotTrajectoryVec_default_instance_;
}  // namespace aphropm_proto
}  // namespace galbot
PROTOBUF_NAMESPACE_OPEN
template<> ::galbot::aphropm_proto::BaseState* Arena::CreateMaybeMessage<::galbot::aphropm_proto::BaseState>(Arena*);
template<> ::galbot::aphropm_proto::BodyState* Arena::CreateMaybeMessage<::galbot::aphropm_proto::BodyState>(Arena*);
template<> ::galbot::aphropm_proto::ChainFrame* Arena::CreateMaybeMessage<::galbot::aphropm_proto::ChainFrame>(Arena*);
template<> ::galbot::aphropm_proto::ChainState* Arena::CreateMaybeMessage<::galbot::aphropm_proto::ChainState>(Arena*);
template<> ::galbot::aphropm_proto::JointState* Arena::CreateMaybeMessage<::galbot::aphropm_proto::JointState>(Arena*);
template<> ::galbot::aphropm_proto::ParentFrame* Arena::CreateMaybeMessage<::galbot::aphropm_proto::ParentFrame>(Arena*);
template<> ::galbot::aphropm_proto::PoseState* Arena::CreateMaybeMessage<::galbot::aphropm_proto::PoseState>(Arena*);
template<> ::galbot::aphropm_proto::RobotStates* Arena::CreateMaybeMessage<::galbot::aphropm_proto::RobotStates>(Arena*);
template<> ::galbot::aphropm_proto::RobotTrajectory* Arena::CreateMaybeMessage<::galbot::aphropm_proto::RobotTrajectory>(Arena*);
template<> ::galbot::aphropm_proto::RobotTrajectoryVec* Arena::CreateMaybeMessage<::galbot::aphropm_proto::RobotTrajectoryVec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace galbot {
namespace aphropm_proto {

enum ChainFrame_FrameType : int {
  ChainFrame_FrameType_EE_BASE = 0,
  ChainFrame_FrameType_CAMERA_BASE = 1,
  ChainFrame_FrameType_CAMERA_OBJECT = 2,
  ChainFrame_FrameType_ChainFrame_FrameType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChainFrame_FrameType_ChainFrame_FrameType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChainFrame_FrameType_IsValid(int value);
constexpr ChainFrame_FrameType ChainFrame_FrameType_FrameType_MIN = ChainFrame_FrameType_EE_BASE;
constexpr ChainFrame_FrameType ChainFrame_FrameType_FrameType_MAX = ChainFrame_FrameType_CAMERA_OBJECT;
constexpr int ChainFrame_FrameType_FrameType_ARRAYSIZE = ChainFrame_FrameType_FrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChainFrame_FrameType_descriptor();
template<typename T>
inline const std::string& ChainFrame_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChainFrame_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChainFrame_FrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChainFrame_FrameType_descriptor(), enum_t_value);
}
inline bool ChainFrame_FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChainFrame_FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChainFrame_FrameType>(
    ChainFrame_FrameType_descriptor(), name, value);
}
enum BodyState_BodyStateType : int {
  BodyState_BodyStateType_JOINT = 0,
  BodyState_BodyStateType_CART = 1,
  BodyState_BodyStateType_BodyState_BodyStateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BodyState_BodyStateType_BodyState_BodyStateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BodyState_BodyStateType_IsValid(int value);
constexpr BodyState_BodyStateType BodyState_BodyStateType_BodyStateType_MIN = BodyState_BodyStateType_JOINT;
constexpr BodyState_BodyStateType BodyState_BodyStateType_BodyStateType_MAX = BodyState_BodyStateType_CART;
constexpr int BodyState_BodyStateType_BodyStateType_ARRAYSIZE = BodyState_BodyStateType_BodyStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BodyState_BodyStateType_descriptor();
template<typename T>
inline const std::string& BodyState_BodyStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BodyState_BodyStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BodyState_BodyStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BodyState_BodyStateType_descriptor(), enum_t_value);
}
inline bool BodyState_BodyStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BodyState_BodyStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BodyState_BodyStateType>(
    BodyState_BodyStateType_descriptor(), name, value);
}
enum ChainType : int {
  left_arm = 0,
  right_arm = 1,
  head = 2,
  leg = 3,
  mobile_base = 4,
  torso = 5,
  ChainType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChainType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChainType_IsValid(int value);
constexpr ChainType ChainType_MIN = left_arm;
constexpr ChainType ChainType_MAX = torso;
constexpr int ChainType_ARRAYSIZE = ChainType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChainType_descriptor();
template<typename T>
inline const std::string& ChainType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChainType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChainType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChainType_descriptor(), enum_t_value);
}
inline bool ChainType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChainType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChainType>(
    ChainType_descriptor(), name, value);
}
enum ActuateType : int {
  ACTUATE_WITH_CHAIN_ONLY = 0,
  ACTUATE_WITH_TORSO = 1,
  ACTUATE_WITH_LEG = 2,
  ActuateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActuateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActuateType_IsValid(int value);
constexpr ActuateType ActuateType_MIN = ACTUATE_WITH_CHAIN_ONLY;
constexpr ActuateType ActuateType_MAX = ACTUATE_WITH_LEG;
constexpr int ActuateType_ARRAYSIZE = ActuateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActuateType_descriptor();
template<typename T>
inline const std::string& ActuateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActuateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActuateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActuateType_descriptor(), enum_t_value);
}
inline bool ActuateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActuateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActuateType>(
    ActuateType_descriptor(), name, value);
}
enum CameraType : int {
  LEFT_ARM = 0,
  RIGHT_ARM = 1,
  FRONT_HEAD = 2,
  CameraType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraType_IsValid(int value);
constexpr CameraType CameraType_MIN = LEFT_ARM;
constexpr CameraType CameraType_MAX = FRONT_HEAD;
constexpr int CameraType_ARRAYSIZE = CameraType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraType_descriptor();
template<typename T>
inline const std::string& CameraType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraType_descriptor(), enum_t_value);
}
inline bool CameraType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CameraType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraType>(
    CameraType_descriptor(), name, value);
}
enum MapFrame : int {
  WORLD = 0,
  BASE = 1,
  MapFrame_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MapFrame_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MapFrame_IsValid(int value);
constexpr MapFrame MapFrame_MIN = WORLD;
constexpr MapFrame MapFrame_MAX = BASE;
constexpr int MapFrame_ARRAYSIZE = MapFrame_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapFrame_descriptor();
template<typename T>
inline const std::string& MapFrame_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapFrame>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapFrame_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapFrame_descriptor(), enum_t_value);
}
inline bool MapFrame_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MapFrame* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapFrame>(
    MapFrame_descriptor(), name, value);
}
// ===================================================================

class ChainFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.ChainFrame) */ {
 public:
  inline ChainFrame() : ChainFrame(nullptr) {}
  virtual ~ChainFrame();

  ChainFrame(const ChainFrame& from);
  ChainFrame(ChainFrame&& from) noexcept
    : ChainFrame() {
    *this = ::std::move(from);
  }

  inline ChainFrame& operator=(const ChainFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainFrame& operator=(ChainFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChainFrame& default_instance();

  static inline const ChainFrame* internal_default_instance() {
    return reinterpret_cast<const ChainFrame*>(
               &_ChainFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChainFrame& a, ChainFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChainFrame* New() const final {
    return CreateMaybeMessage<ChainFrame>(nullptr);
  }

  ChainFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChainFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChainFrame& from);
  void MergeFrom(const ChainFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.ChainFrame";
  }
  protected:
  explicit ChainFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChainFrame_FrameType FrameType;
  static constexpr FrameType EE_BASE =
    ChainFrame_FrameType_EE_BASE;
  static constexpr FrameType CAMERA_BASE =
    ChainFrame_FrameType_CAMERA_BASE;
  static constexpr FrameType CAMERA_OBJECT =
    ChainFrame_FrameType_CAMERA_OBJECT;
  static inline bool FrameType_IsValid(int value) {
    return ChainFrame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    ChainFrame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    ChainFrame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    ChainFrame_FrameType_FrameType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FrameType_descriptor() {
    return ChainFrame_FrameType_descriptor();
  }
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return ChainFrame_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FrameType* value) {
    return ChainFrame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChainFieldNumber = 1,
    kFrameTypeFieldNumber = 2,
  };
  // .galbot.aphropm_proto.ChainType chain = 1;
  void clear_chain();
  ::galbot::aphropm_proto::ChainType chain() const;
  void set_chain(::galbot::aphropm_proto::ChainType value);
  private:
  ::galbot::aphropm_proto::ChainType _internal_chain() const;
  void _internal_set_chain(::galbot::aphropm_proto::ChainType value);
  public:

  // .galbot.aphropm_proto.ChainFrame.FrameType frame_type = 2;
  void clear_frame_type();
  ::galbot::aphropm_proto::ChainFrame_FrameType frame_type() const;
  void set_frame_type(::galbot::aphropm_proto::ChainFrame_FrameType value);
  private:
  ::galbot::aphropm_proto::ChainFrame_FrameType _internal_frame_type() const;
  void _internal_set_frame_type(::galbot::aphropm_proto::ChainFrame_FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.ChainFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int chain_;
  int frame_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class ParentFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.ParentFrame) */ {
 public:
  inline ParentFrame() : ParentFrame(nullptr) {}
  virtual ~ParentFrame();

  ParentFrame(const ParentFrame& from);
  ParentFrame(ParentFrame&& from) noexcept
    : ParentFrame() {
    *this = ::std::move(from);
  }

  inline ParentFrame& operator=(const ParentFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParentFrame& operator=(ParentFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParentFrame& default_instance();

  enum FrametypeCase {
    kMapFrame = 1,
    kChainFrame = 2,
    kParentLinkName = 3,
    FRAMETYPE_NOT_SET = 0,
  };

  static inline const ParentFrame* internal_default_instance() {
    return reinterpret_cast<const ParentFrame*>(
               &_ParentFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ParentFrame& a, ParentFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ParentFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParentFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParentFrame* New() const final {
    return CreateMaybeMessage<ParentFrame>(nullptr);
  }

  ParentFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParentFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParentFrame& from);
  void MergeFrom(const ParentFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParentFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.ParentFrame";
  }
  protected:
  explicit ParentFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFrameFieldNumber = 1,
    kChainFrameFieldNumber = 2,
    kParentLinkNameFieldNumber = 3,
  };
  // .galbot.aphropm_proto.MapFrame map_frame = 1;
  private:
  bool _internal_has_map_frame() const;
  public:
  void clear_map_frame();
  ::galbot::aphropm_proto::MapFrame map_frame() const;
  void set_map_frame(::galbot::aphropm_proto::MapFrame value);
  private:
  ::galbot::aphropm_proto::MapFrame _internal_map_frame() const;
  void _internal_set_map_frame(::galbot::aphropm_proto::MapFrame value);
  public:

  // .galbot.aphropm_proto.ChainFrame chain_frame = 2;
  bool has_chain_frame() const;
  private:
  bool _internal_has_chain_frame() const;
  public:
  void clear_chain_frame();
  const ::galbot::aphropm_proto::ChainFrame& chain_frame() const;
  ::galbot::aphropm_proto::ChainFrame* release_chain_frame();
  ::galbot::aphropm_proto::ChainFrame* mutable_chain_frame();
  void set_allocated_chain_frame(::galbot::aphropm_proto::ChainFrame* chain_frame);
  private:
  const ::galbot::aphropm_proto::ChainFrame& _internal_chain_frame() const;
  ::galbot::aphropm_proto::ChainFrame* _internal_mutable_chain_frame();
  public:
  void unsafe_arena_set_allocated_chain_frame(
      ::galbot::aphropm_proto::ChainFrame* chain_frame);
  ::galbot::aphropm_proto::ChainFrame* unsafe_arena_release_chain_frame();

  // string parent_link_name = 3;
  private:
  bool _internal_has_parent_link_name() const;
  public:
  void clear_parent_link_name();
  const std::string& parent_link_name() const;
  void set_parent_link_name(const std::string& value);
  void set_parent_link_name(std::string&& value);
  void set_parent_link_name(const char* value);
  void set_parent_link_name(const char* value, size_t size);
  std::string* mutable_parent_link_name();
  std::string* release_parent_link_name();
  void set_allocated_parent_link_name(std::string* parent_link_name);
  private:
  const std::string& _internal_parent_link_name() const;
  void _internal_set_parent_link_name(const std::string& value);
  std::string* _internal_mutable_parent_link_name();
  public:

  void clear_frametype();
  FrametypeCase frametype_case() const;
  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.ParentFrame)
 private:
  class _Internal;
  void set_has_map_frame();
  void set_has_chain_frame();
  void set_has_parent_link_name();

  inline bool has_frametype() const;
  inline void clear_has_frametype();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FrametypeUnion {
    FrametypeUnion() {}
    int map_frame_;
    ::galbot::aphropm_proto::ChainFrame* chain_frame_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_link_name_;
  } frametype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BaseState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.BaseState) */ {
 public:
  inline BaseState() : BaseState(nullptr) {}
  virtual ~BaseState();

  BaseState(const BaseState& from);
  BaseState(BaseState&& from) noexcept
    : BaseState() {
    *this = ::std::move(from);
  }

  inline BaseState& operator=(const BaseState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseState& operator=(BaseState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BaseState& default_instance();

  static inline const BaseState* internal_default_instance() {
    return reinterpret_cast<const BaseState*>(
               &_BaseState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BaseState& a, BaseState& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseState* New() const final {
    return CreateMaybeMessage<BaseState>(nullptr);
  }

  BaseState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BaseState& from);
  void MergeFrom(const BaseState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.BaseState";
  }
  protected:
  explicit BaseState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointNamesFieldNumber = 1,
    kPoseFieldNumber = 3,
    kTwistFieldNumber = 4,
    kAccFieldNumber = 5,
    kMapFrameFieldNumber = 2,
  };
  // repeated string joint_names = 1;
  int joint_names_size() const;
  private:
  int _internal_joint_names_size() const;
  public:
  void clear_joint_names();
  const std::string& joint_names(int index) const;
  std::string* mutable_joint_names(int index);
  void set_joint_names(int index, const std::string& value);
  void set_joint_names(int index, std::string&& value);
  void set_joint_names(int index, const char* value);
  void set_joint_names(int index, const char* value, size_t size);
  std::string* add_joint_names();
  void add_joint_names(const std::string& value);
  void add_joint_names(std::string&& value);
  void add_joint_names(const char* value);
  void add_joint_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& joint_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_joint_names();
  private:
  const std::string& _internal_joint_names(int index) const;
  std::string* _internal_add_joint_names();
  public:

  // .galbot.spatial_proto.Pose pose = 3;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::galbot::spatial_proto::Pose& pose() const;
  ::galbot::spatial_proto::Pose* release_pose();
  ::galbot::spatial_proto::Pose* mutable_pose();
  void set_allocated_pose(::galbot::spatial_proto::Pose* pose);
  private:
  const ::galbot::spatial_proto::Pose& _internal_pose() const;
  ::galbot::spatial_proto::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::galbot::spatial_proto::Pose* pose);
  ::galbot::spatial_proto::Pose* unsafe_arena_release_pose();

  // .galbot.spatial_proto.Twist twist = 4;
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::galbot::spatial_proto::Twist& twist() const;
  ::galbot::spatial_proto::Twist* release_twist();
  ::galbot::spatial_proto::Twist* mutable_twist();
  void set_allocated_twist(::galbot::spatial_proto::Twist* twist);
  private:
  const ::galbot::spatial_proto::Twist& _internal_twist() const;
  ::galbot::spatial_proto::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::galbot::spatial_proto::Twist* twist);
  ::galbot::spatial_proto::Twist* unsafe_arena_release_twist();

  // .galbot.spatial_proto.Twist acc = 5;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  const ::galbot::spatial_proto::Twist& acc() const;
  ::galbot::spatial_proto::Twist* release_acc();
  ::galbot::spatial_proto::Twist* mutable_acc();
  void set_allocated_acc(::galbot::spatial_proto::Twist* acc);
  private:
  const ::galbot::spatial_proto::Twist& _internal_acc() const;
  ::galbot::spatial_proto::Twist* _internal_mutable_acc();
  public:
  void unsafe_arena_set_allocated_acc(
      ::galbot::spatial_proto::Twist* acc);
  ::galbot::spatial_proto::Twist* unsafe_arena_release_acc();

  // .galbot.aphropm_proto.MapFrame map_frame = 2;
  void clear_map_frame();
  ::galbot::aphropm_proto::MapFrame map_frame() const;
  void set_map_frame(::galbot::aphropm_proto::MapFrame value);
  private:
  ::galbot::aphropm_proto::MapFrame _internal_map_frame() const;
  void _internal_set_map_frame(::galbot::aphropm_proto::MapFrame value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.BaseState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> joint_names_;
  ::galbot::spatial_proto::Pose* pose_;
  ::galbot::spatial_proto::Twist* twist_;
  ::galbot::spatial_proto::Twist* acc_;
  int map_frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class JointState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.JointState) */ {
 public:
  inline JointState() : JointState(nullptr) {}
  virtual ~JointState();

  JointState(const JointState& from);
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  inline JointState& operator=(JointState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JointState& default_instance();

  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }
  inline void Swap(JointState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JointState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JointState* New() const final {
    return CreateMaybeMessage<JointState>(nullptr);
  }

  JointState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.JointState";
  }
  protected:
  explicit JointState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionsFieldNumber = 1,
    kVelocitiesFieldNumber = 2,
    kAccelerationsFieldNumber = 3,
  };
  // .galbot.core_proto.Vector positions = 1;
  bool has_positions() const;
  private:
  bool _internal_has_positions() const;
  public:
  void clear_positions();
  const ::galbot::core_proto::Vector& positions() const;
  ::galbot::core_proto::Vector* release_positions();
  ::galbot::core_proto::Vector* mutable_positions();
  void set_allocated_positions(::galbot::core_proto::Vector* positions);
  private:
  const ::galbot::core_proto::Vector& _internal_positions() const;
  ::galbot::core_proto::Vector* _internal_mutable_positions();
  public:
  void unsafe_arena_set_allocated_positions(
      ::galbot::core_proto::Vector* positions);
  ::galbot::core_proto::Vector* unsafe_arena_release_positions();

  // .galbot.core_proto.Vector velocities = 2;
  bool has_velocities() const;
  private:
  bool _internal_has_velocities() const;
  public:
  void clear_velocities();
  const ::galbot::core_proto::Vector& velocities() const;
  ::galbot::core_proto::Vector* release_velocities();
  ::galbot::core_proto::Vector* mutable_velocities();
  void set_allocated_velocities(::galbot::core_proto::Vector* velocities);
  private:
  const ::galbot::core_proto::Vector& _internal_velocities() const;
  ::galbot::core_proto::Vector* _internal_mutable_velocities();
  public:
  void unsafe_arena_set_allocated_velocities(
      ::galbot::core_proto::Vector* velocities);
  ::galbot::core_proto::Vector* unsafe_arena_release_velocities();

  // .galbot.core_proto.Vector accelerations = 3;
  bool has_accelerations() const;
  private:
  bool _internal_has_accelerations() const;
  public:
  void clear_accelerations();
  const ::galbot::core_proto::Vector& accelerations() const;
  ::galbot::core_proto::Vector* release_accelerations();
  ::galbot::core_proto::Vector* mutable_accelerations();
  void set_allocated_accelerations(::galbot::core_proto::Vector* accelerations);
  private:
  const ::galbot::core_proto::Vector& _internal_accelerations() const;
  ::galbot::core_proto::Vector* _internal_mutable_accelerations();
  public:
  void unsafe_arena_set_allocated_accelerations(
      ::galbot::core_proto::Vector* accelerations);
  ::galbot::core_proto::Vector* unsafe_arena_release_accelerations();

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.JointState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::core_proto::Vector* positions_;
  ::galbot::core_proto::Vector* velocities_;
  ::galbot::core_proto::Vector* accelerations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class PoseState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.PoseState) */ {
 public:
  inline PoseState() : PoseState(nullptr) {}
  virtual ~PoseState();

  PoseState(const PoseState& from);
  PoseState(PoseState&& from) noexcept
    : PoseState() {
    *this = ::std::move(from);
  }

  inline PoseState& operator=(const PoseState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoseState& operator=(PoseState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PoseState& default_instance();

  static inline const PoseState* internal_default_instance() {
    return reinterpret_cast<const PoseState*>(
               &_PoseState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PoseState& a, PoseState& b) {
    a.Swap(&b);
  }
  inline void Swap(PoseState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoseState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PoseState* New() const final {
    return CreateMaybeMessage<PoseState>(nullptr);
  }

  PoseState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PoseState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PoseState& from);
  void MergeFrom(const PoseState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoseState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.PoseState";
  }
  protected:
  explicit PoseState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPoseFieldNumber = 1,
    kParentFrameFieldNumber = 2,
    kIsRelativeFieldNumber = 4,
    kIsToolPoseFieldNumber = 5,
  };
  // .galbot.spatial_proto.Pose pose = 1;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::galbot::spatial_proto::Pose& pose() const;
  ::galbot::spatial_proto::Pose* release_pose();
  ::galbot::spatial_proto::Pose* mutable_pose();
  void set_allocated_pose(::galbot::spatial_proto::Pose* pose);
  private:
  const ::galbot::spatial_proto::Pose& _internal_pose() const;
  ::galbot::spatial_proto::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::galbot::spatial_proto::Pose* pose);
  ::galbot::spatial_proto::Pose* unsafe_arena_release_pose();

  // .galbot.aphropm_proto.ParentFrame parent_frame = 2;
  bool has_parent_frame() const;
  private:
  bool _internal_has_parent_frame() const;
  public:
  void clear_parent_frame();
  const ::galbot::aphropm_proto::ParentFrame& parent_frame() const;
  ::galbot::aphropm_proto::ParentFrame* release_parent_frame();
  ::galbot::aphropm_proto::ParentFrame* mutable_parent_frame();
  void set_allocated_parent_frame(::galbot::aphropm_proto::ParentFrame* parent_frame);
  private:
  const ::galbot::aphropm_proto::ParentFrame& _internal_parent_frame() const;
  ::galbot::aphropm_proto::ParentFrame* _internal_mutable_parent_frame();
  public:
  void unsafe_arena_set_allocated_parent_frame(
      ::galbot::aphropm_proto::ParentFrame* parent_frame);
  ::galbot::aphropm_proto::ParentFrame* unsafe_arena_release_parent_frame();

  // bool is_relative = 4;
  void clear_is_relative();
  bool is_relative() const;
  void set_is_relative(bool value);
  private:
  bool _internal_is_relative() const;
  void _internal_set_is_relative(bool value);
  public:

  // bool is_tool_pose = 5;
  void clear_is_tool_pose();
  bool is_tool_pose() const;
  void set_is_tool_pose(bool value);
  private:
  bool _internal_is_tool_pose() const;
  void _internal_set_is_tool_pose(bool value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.PoseState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::spatial_proto::Pose* pose_;
  ::galbot::aphropm_proto::ParentFrame* parent_frame_;
  bool is_relative_;
  bool is_tool_pose_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BodyState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.BodyState) */ {
 public:
  inline BodyState() : BodyState(nullptr) {}
  virtual ~BodyState();

  BodyState(const BodyState& from);
  BodyState(BodyState&& from) noexcept
    : BodyState() {
    *this = ::std::move(from);
  }

  inline BodyState& operator=(const BodyState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BodyState& operator=(BodyState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BodyState& default_instance();

  static inline const BodyState* internal_default_instance() {
    return reinterpret_cast<const BodyState*>(
               &_BodyState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BodyState& a, BodyState& b) {
    a.Swap(&b);
  }
  inline void Swap(BodyState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BodyState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BodyState* New() const final {
    return CreateMaybeMessage<BodyState>(nullptr);
  }

  BodyState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BodyState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BodyState& from);
  void MergeFrom(const BodyState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BodyState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.BodyState";
  }
  protected:
  explicit BodyState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BodyState_BodyStateType BodyStateType;
  static constexpr BodyStateType JOINT =
    BodyState_BodyStateType_JOINT;
  static constexpr BodyStateType CART =
    BodyState_BodyStateType_CART;
  static inline bool BodyStateType_IsValid(int value) {
    return BodyState_BodyStateType_IsValid(value);
  }
  static constexpr BodyStateType BodyStateType_MIN =
    BodyState_BodyStateType_BodyStateType_MIN;
  static constexpr BodyStateType BodyStateType_MAX =
    BodyState_BodyStateType_BodyStateType_MAX;
  static constexpr int BodyStateType_ARRAYSIZE =
    BodyState_BodyStateType_BodyStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  BodyStateType_descriptor() {
    return BodyState_BodyStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& BodyStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BodyStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BodyStateType_Name.");
    return BodyState_BodyStateType_Name(enum_t_value);
  }
  static inline bool BodyStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BodyStateType* value) {
    return BodyState_BodyStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJointFieldNumber = 2,
    kPoseFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .galbot.aphropm_proto.JointState joint = 2;
  bool has_joint() const;
  private:
  bool _internal_has_joint() const;
  public:
  void clear_joint();
  const ::galbot::aphropm_proto::JointState& joint() const;
  ::galbot::aphropm_proto::JointState* release_joint();
  ::galbot::aphropm_proto::JointState* mutable_joint();
  void set_allocated_joint(::galbot::aphropm_proto::JointState* joint);
  private:
  const ::galbot::aphropm_proto::JointState& _internal_joint() const;
  ::galbot::aphropm_proto::JointState* _internal_mutable_joint();
  public:
  void unsafe_arena_set_allocated_joint(
      ::galbot::aphropm_proto::JointState* joint);
  ::galbot::aphropm_proto::JointState* unsafe_arena_release_joint();

  // .galbot.aphropm_proto.PoseState pose = 3;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::galbot::aphropm_proto::PoseState& pose() const;
  ::galbot::aphropm_proto::PoseState* release_pose();
  ::galbot::aphropm_proto::PoseState* mutable_pose();
  void set_allocated_pose(::galbot::aphropm_proto::PoseState* pose);
  private:
  const ::galbot::aphropm_proto::PoseState& _internal_pose() const;
  ::galbot::aphropm_proto::PoseState* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::galbot::aphropm_proto::PoseState* pose);
  ::galbot::aphropm_proto::PoseState* unsafe_arena_release_pose();

  // .galbot.aphropm_proto.BodyState.BodyStateType type = 1;
  void clear_type();
  ::galbot::aphropm_proto::BodyState_BodyStateType type() const;
  void set_type(::galbot::aphropm_proto::BodyState_BodyStateType value);
  private:
  ::galbot::aphropm_proto::BodyState_BodyStateType _internal_type() const;
  void _internal_set_type(::galbot::aphropm_proto::BodyState_BodyStateType value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.BodyState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::JointState* joint_;
  ::galbot::aphropm_proto::PoseState* pose_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class RobotStates PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.RobotStates) */ {
 public:
  inline RobotStates() : RobotStates(nullptr) {}
  virtual ~RobotStates();

  RobotStates(const RobotStates& from);
  RobotStates(RobotStates&& from) noexcept
    : RobotStates() {
    *this = ::std::move(from);
  }

  inline RobotStates& operator=(const RobotStates& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotStates& operator=(RobotStates&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotStates& default_instance();

  static inline const RobotStates* internal_default_instance() {
    return reinterpret_cast<const RobotStates*>(
               &_RobotStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RobotStates& a, RobotStates& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotStates* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotStates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotStates* New() const final {
    return CreateMaybeMessage<RobotStates>(nullptr);
  }

  RobotStates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotStates>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotStates& from);
  void MergeFrom(const RobotStates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotStates* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.RobotStates";
  }
  protected:
  explicit RobotStates(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  // .galbot.aphropm_proto.BaseState base = 1;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::galbot::aphropm_proto::BaseState& base() const;
  ::galbot::aphropm_proto::BaseState* release_base();
  ::galbot::aphropm_proto::BaseState* mutable_base();
  void set_allocated_base(::galbot::aphropm_proto::BaseState* base);
  private:
  const ::galbot::aphropm_proto::BaseState& _internal_base() const;
  ::galbot::aphropm_proto::BaseState* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::galbot::aphropm_proto::BaseState* base);
  ::galbot::aphropm_proto::BaseState* unsafe_arena_release_base();

  // .galbot.aphropm_proto.BodyState body = 2;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const ::galbot::aphropm_proto::BodyState& body() const;
  ::galbot::aphropm_proto::BodyState* release_body();
  ::galbot::aphropm_proto::BodyState* mutable_body();
  void set_allocated_body(::galbot::aphropm_proto::BodyState* body);
  private:
  const ::galbot::aphropm_proto::BodyState& _internal_body() const;
  ::galbot::aphropm_proto::BodyState* _internal_mutable_body();
  public:
  void unsafe_arena_set_allocated_body(
      ::galbot::aphropm_proto::BodyState* body);
  ::galbot::aphropm_proto::BodyState* unsafe_arena_release_body();

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.RobotStates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::BaseState* base_;
  ::galbot::aphropm_proto::BodyState* body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class ChainState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.ChainState) */ {
 public:
  inline ChainState() : ChainState(nullptr) {}
  virtual ~ChainState();

  ChainState(const ChainState& from);
  ChainState(ChainState&& from) noexcept
    : ChainState() {
    *this = ::std::move(from);
  }

  inline ChainState& operator=(const ChainState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChainState& operator=(ChainState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChainState& default_instance();

  static inline const ChainState* internal_default_instance() {
    return reinterpret_cast<const ChainState*>(
               &_ChainState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChainState& a, ChainState& b) {
    a.Swap(&b);
  }
  inline void Swap(ChainState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChainState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChainState* New() const final {
    return CreateMaybeMessage<ChainState>(nullptr);
  }

  ChainState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChainState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChainState& from);
  void MergeFrom(const ChainState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChainState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.ChainState";
  }
  protected:
  explicit ChainState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainStateFieldNumber = 2,
    kChainFieldNumber = 1,
  };
  // .galbot.aphropm_proto.RobotStates chain_state = 2;
  bool has_chain_state() const;
  private:
  bool _internal_has_chain_state() const;
  public:
  void clear_chain_state();
  const ::galbot::aphropm_proto::RobotStates& chain_state() const;
  ::galbot::aphropm_proto::RobotStates* release_chain_state();
  ::galbot::aphropm_proto::RobotStates* mutable_chain_state();
  void set_allocated_chain_state(::galbot::aphropm_proto::RobotStates* chain_state);
  private:
  const ::galbot::aphropm_proto::RobotStates& _internal_chain_state() const;
  ::galbot::aphropm_proto::RobotStates* _internal_mutable_chain_state();
  public:
  void unsafe_arena_set_allocated_chain_state(
      ::galbot::aphropm_proto::RobotStates* chain_state);
  ::galbot::aphropm_proto::RobotStates* unsafe_arena_release_chain_state();

  // .galbot.aphropm_proto.ChainType chain = 1;
  void clear_chain();
  ::galbot::aphropm_proto::ChainType chain() const;
  void set_chain(::galbot::aphropm_proto::ChainType value);
  private:
  ::galbot::aphropm_proto::ChainType _internal_chain() const;
  void _internal_set_chain(::galbot::aphropm_proto::ChainType value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.ChainState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::galbot::aphropm_proto::RobotStates* chain_state_;
  int chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class RobotTrajectory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.RobotTrajectory) */ {
 public:
  inline RobotTrajectory() : RobotTrajectory(nullptr) {}
  virtual ~RobotTrajectory();

  RobotTrajectory(const RobotTrajectory& from);
  RobotTrajectory(RobotTrajectory&& from) noexcept
    : RobotTrajectory() {
    *this = ::std::move(from);
  }

  inline RobotTrajectory& operator=(const RobotTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotTrajectory& operator=(RobotTrajectory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotTrajectory& default_instance();

  static inline const RobotTrajectory* internal_default_instance() {
    return reinterpret_cast<const RobotTrajectory*>(
               &_RobotTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RobotTrajectory& a, RobotTrajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotTrajectory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotTrajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotTrajectory* New() const final {
    return CreateMaybeMessage<RobotTrajectory>(nullptr);
  }

  RobotTrajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotTrajectory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotTrajectory& from);
  void MergeFrom(const RobotTrajectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotTrajectory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.RobotTrajectory";
  }
  protected:
  explicit RobotTrajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJointsFieldNumber = 2,
    kPosesFieldNumber = 3,
    kBaseTrajFieldNumber = 4,
    kTimesFieldNumber = 5,
    kStartTimeFieldNumber = 6,
    kChainFieldNumber = 1,
  };
  // repeated .galbot.aphropm_proto.JointState joints = 2;
  int joints_size() const;
  private:
  int _internal_joints_size() const;
  public:
  void clear_joints();
  ::galbot::aphropm_proto::JointState* mutable_joints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::JointState >*
      mutable_joints();
  private:
  const ::galbot::aphropm_proto::JointState& _internal_joints(int index) const;
  ::galbot::aphropm_proto::JointState* _internal_add_joints();
  public:
  const ::galbot::aphropm_proto::JointState& joints(int index) const;
  ::galbot::aphropm_proto::JointState* add_joints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::JointState >&
      joints() const;

  // repeated .galbot.aphropm_proto.PoseState poses = 3;
  int poses_size() const;
  private:
  int _internal_poses_size() const;
  public:
  void clear_poses();
  ::galbot::aphropm_proto::PoseState* mutable_poses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::PoseState >*
      mutable_poses();
  private:
  const ::galbot::aphropm_proto::PoseState& _internal_poses(int index) const;
  ::galbot::aphropm_proto::PoseState* _internal_add_poses();
  public:
  const ::galbot::aphropm_proto::PoseState& poses(int index) const;
  ::galbot::aphropm_proto::PoseState* add_poses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::PoseState >&
      poses() const;

  // repeated .galbot.aphropm_proto.BaseState base_traj = 4;
  int base_traj_size() const;
  private:
  int _internal_base_traj_size() const;
  public:
  void clear_base_traj();
  ::galbot::aphropm_proto::BaseState* mutable_base_traj(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::BaseState >*
      mutable_base_traj();
  private:
  const ::galbot::aphropm_proto::BaseState& _internal_base_traj(int index) const;
  ::galbot::aphropm_proto::BaseState* _internal_add_base_traj();
  public:
  const ::galbot::aphropm_proto::BaseState& base_traj(int index) const;
  ::galbot::aphropm_proto::BaseState* add_base_traj();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::BaseState >&
      base_traj() const;

  // repeated double times = 5;
  int times_size() const;
  private:
  int _internal_times_size() const;
  public:
  void clear_times();
  private:
  double _internal_times(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_times() const;
  void _internal_add_times(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_times();
  public:
  double times(int index) const;
  void set_times(int index, double value);
  void add_times(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      times() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_times();

  // int64 start_time = 6;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .galbot.aphropm_proto.ChainType chain = 1;
  void clear_chain();
  ::galbot::aphropm_proto::ChainType chain() const;
  void set_chain(::galbot::aphropm_proto::ChainType value);
  private:
  ::galbot::aphropm_proto::ChainType _internal_chain() const;
  void _internal_set_chain(::galbot::aphropm_proto::ChainType value);
  public:

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.RobotTrajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::JointState > joints_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::PoseState > poses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::BaseState > base_traj_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > times_;
  mutable std::atomic<int> _times_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  int chain_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// -------------------------------------------------------------------

class RobotTrajectoryVec PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:galbot.aphropm_proto.RobotTrajectoryVec) */ {
 public:
  inline RobotTrajectoryVec() : RobotTrajectoryVec(nullptr) {}
  virtual ~RobotTrajectoryVec();

  RobotTrajectoryVec(const RobotTrajectoryVec& from);
  RobotTrajectoryVec(RobotTrajectoryVec&& from) noexcept
    : RobotTrajectoryVec() {
    *this = ::std::move(from);
  }

  inline RobotTrajectoryVec& operator=(const RobotTrajectoryVec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotTrajectoryVec& operator=(RobotTrajectoryVec&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotTrajectoryVec& default_instance();

  static inline const RobotTrajectoryVec* internal_default_instance() {
    return reinterpret_cast<const RobotTrajectoryVec*>(
               &_RobotTrajectoryVec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RobotTrajectoryVec& a, RobotTrajectoryVec& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotTrajectoryVec* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotTrajectoryVec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotTrajectoryVec* New() const final {
    return CreateMaybeMessage<RobotTrajectoryVec>(nullptr);
  }

  RobotTrajectoryVec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotTrajectoryVec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotTrajectoryVec& from);
  void MergeFrom(const RobotTrajectoryVec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotTrajectoryVec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "galbot.aphropm_proto.RobotTrajectoryVec";
  }
  protected:
  explicit RobotTrajectoryVec(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto);
    return ::descriptor_table_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoriesFieldNumber = 1,
  };
  // repeated .galbot.aphropm_proto.RobotTrajectory trajectories = 1;
  int trajectories_size() const;
  private:
  int _internal_trajectories_size() const;
  public:
  void clear_trajectories();
  ::galbot::aphropm_proto::RobotTrajectory* mutable_trajectories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::RobotTrajectory >*
      mutable_trajectories();
  private:
  const ::galbot::aphropm_proto::RobotTrajectory& _internal_trajectories(int index) const;
  ::galbot::aphropm_proto::RobotTrajectory* _internal_add_trajectories();
  public:
  const ::galbot::aphropm_proto::RobotTrajectory& trajectories(int index) const;
  ::galbot::aphropm_proto::RobotTrajectory* add_trajectories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::RobotTrajectory >&
      trajectories() const;

  // @@protoc_insertion_point(class_scope:galbot.aphropm_proto.RobotTrajectoryVec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::RobotTrajectory > trajectories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChainFrame

// .galbot.aphropm_proto.ChainType chain = 1;
inline void ChainFrame::clear_chain() {
  chain_ = 0;
}
inline ::galbot::aphropm_proto::ChainType ChainFrame::_internal_chain() const {
  return static_cast< ::galbot::aphropm_proto::ChainType >(chain_);
}
inline ::galbot::aphropm_proto::ChainType ChainFrame::chain() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ChainFrame.chain)
  return _internal_chain();
}
inline void ChainFrame::_internal_set_chain(::galbot::aphropm_proto::ChainType value) {
  
  chain_ = value;
}
inline void ChainFrame::set_chain(::galbot::aphropm_proto::ChainType value) {
  _internal_set_chain(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ChainFrame.chain)
}

// .galbot.aphropm_proto.ChainFrame.FrameType frame_type = 2;
inline void ChainFrame::clear_frame_type() {
  frame_type_ = 0;
}
inline ::galbot::aphropm_proto::ChainFrame_FrameType ChainFrame::_internal_frame_type() const {
  return static_cast< ::galbot::aphropm_proto::ChainFrame_FrameType >(frame_type_);
}
inline ::galbot::aphropm_proto::ChainFrame_FrameType ChainFrame::frame_type() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ChainFrame.frame_type)
  return _internal_frame_type();
}
inline void ChainFrame::_internal_set_frame_type(::galbot::aphropm_proto::ChainFrame_FrameType value) {
  
  frame_type_ = value;
}
inline void ChainFrame::set_frame_type(::galbot::aphropm_proto::ChainFrame_FrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ChainFrame.frame_type)
}

// -------------------------------------------------------------------

// ParentFrame

// .galbot.aphropm_proto.MapFrame map_frame = 1;
inline bool ParentFrame::_internal_has_map_frame() const {
  return frametype_case() == kMapFrame;
}
inline void ParentFrame::set_has_map_frame() {
  _oneof_case_[0] = kMapFrame;
}
inline void ParentFrame::clear_map_frame() {
  if (_internal_has_map_frame()) {
    frametype_.map_frame_ = 0;
    clear_has_frametype();
  }
}
inline ::galbot::aphropm_proto::MapFrame ParentFrame::_internal_map_frame() const {
  if (_internal_has_map_frame()) {
    return static_cast< ::galbot::aphropm_proto::MapFrame >(frametype_.map_frame_);
  }
  return static_cast< ::galbot::aphropm_proto::MapFrame >(0);
}
inline ::galbot::aphropm_proto::MapFrame ParentFrame::map_frame() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ParentFrame.map_frame)
  return _internal_map_frame();
}
inline void ParentFrame::_internal_set_map_frame(::galbot::aphropm_proto::MapFrame value) {
  if (!_internal_has_map_frame()) {
    clear_frametype();
    set_has_map_frame();
  }
  frametype_.map_frame_ = value;
}
inline void ParentFrame::set_map_frame(::galbot::aphropm_proto::MapFrame value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ParentFrame.map_frame)
  _internal_set_map_frame(value);
}

// .galbot.aphropm_proto.ChainFrame chain_frame = 2;
inline bool ParentFrame::_internal_has_chain_frame() const {
  return frametype_case() == kChainFrame;
}
inline bool ParentFrame::has_chain_frame() const {
  return _internal_has_chain_frame();
}
inline void ParentFrame::set_has_chain_frame() {
  _oneof_case_[0] = kChainFrame;
}
inline void ParentFrame::clear_chain_frame() {
  if (_internal_has_chain_frame()) {
    if (GetArena() == nullptr) {
      delete frametype_.chain_frame_;
    }
    clear_has_frametype();
  }
}
inline ::galbot::aphropm_proto::ChainFrame* ParentFrame::release_chain_frame() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.ParentFrame.chain_frame)
  if (_internal_has_chain_frame()) {
    clear_has_frametype();
      ::galbot::aphropm_proto::ChainFrame* temp = frametype_.chain_frame_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    frametype_.chain_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::galbot::aphropm_proto::ChainFrame& ParentFrame::_internal_chain_frame() const {
  return _internal_has_chain_frame()
      ? *frametype_.chain_frame_
      : reinterpret_cast< ::galbot::aphropm_proto::ChainFrame&>(::galbot::aphropm_proto::_ChainFrame_default_instance_);
}
inline const ::galbot::aphropm_proto::ChainFrame& ParentFrame::chain_frame() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ParentFrame.chain_frame)
  return _internal_chain_frame();
}
inline ::galbot::aphropm_proto::ChainFrame* ParentFrame::unsafe_arena_release_chain_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:galbot.aphropm_proto.ParentFrame.chain_frame)
  if (_internal_has_chain_frame()) {
    clear_has_frametype();
    ::galbot::aphropm_proto::ChainFrame* temp = frametype_.chain_frame_;
    frametype_.chain_frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParentFrame::unsafe_arena_set_allocated_chain_frame(::galbot::aphropm_proto::ChainFrame* chain_frame) {
  clear_frametype();
  if (chain_frame) {
    set_has_chain_frame();
    frametype_.chain_frame_ = chain_frame;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.ParentFrame.chain_frame)
}
inline ::galbot::aphropm_proto::ChainFrame* ParentFrame::_internal_mutable_chain_frame() {
  if (!_internal_has_chain_frame()) {
    clear_frametype();
    set_has_chain_frame();
    frametype_.chain_frame_ = CreateMaybeMessage< ::galbot::aphropm_proto::ChainFrame >(GetArena());
  }
  return frametype_.chain_frame_;
}
inline ::galbot::aphropm_proto::ChainFrame* ParentFrame::mutable_chain_frame() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.ParentFrame.chain_frame)
  return _internal_mutable_chain_frame();
}

// string parent_link_name = 3;
inline bool ParentFrame::_internal_has_parent_link_name() const {
  return frametype_case() == kParentLinkName;
}
inline void ParentFrame::set_has_parent_link_name() {
  _oneof_case_[0] = kParentLinkName;
}
inline void ParentFrame::clear_parent_link_name() {
  if (_internal_has_parent_link_name()) {
    frametype_.parent_link_name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_frametype();
  }
}
inline const std::string& ParentFrame::parent_link_name() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ParentFrame.parent_link_name)
  return _internal_parent_link_name();
}
inline void ParentFrame::set_parent_link_name(const std::string& value) {
  _internal_set_parent_link_name(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ParentFrame.parent_link_name)
}
inline std::string* ParentFrame::mutable_parent_link_name() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.ParentFrame.parent_link_name)
  return _internal_mutable_parent_link_name();
}
inline const std::string& ParentFrame::_internal_parent_link_name() const {
  if (_internal_has_parent_link_name()) {
    return frametype_.parent_link_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ParentFrame::_internal_set_parent_link_name(const std::string& value) {
  if (!_internal_has_parent_link_name()) {
    clear_frametype();
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  frametype_.parent_link_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ParentFrame::set_parent_link_name(std::string&& value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ParentFrame.parent_link_name)
  if (!_internal_has_parent_link_name()) {
    clear_frametype();
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  frametype_.parent_link_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:galbot.aphropm_proto.ParentFrame.parent_link_name)
}
inline void ParentFrame::set_parent_link_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_parent_link_name()) {
    clear_frametype();
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  frametype_.parent_link_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.ParentFrame.parent_link_name)
}
inline void ParentFrame::set_parent_link_name(const char* value,
                             size_t size) {
  if (!_internal_has_parent_link_name()) {
    clear_frametype();
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  frametype_.parent_link_name_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.ParentFrame.parent_link_name)
}
inline std::string* ParentFrame::_internal_mutable_parent_link_name() {
  if (!_internal_has_parent_link_name()) {
    clear_frametype();
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return frametype_.parent_link_name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ParentFrame::release_parent_link_name() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.ParentFrame.parent_link_name)
  if (_internal_has_parent_link_name()) {
    clear_has_frametype();
    return frametype_.parent_link_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void ParentFrame::set_allocated_parent_link_name(std::string* parent_link_name) {
  if (has_frametype()) {
    clear_frametype();
  }
  if (parent_link_name != nullptr) {
    set_has_parent_link_name();
    frametype_.parent_link_name_.UnsafeSetDefault(parent_link_name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(parent_link_name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.ParentFrame.parent_link_name)
}

inline bool ParentFrame::has_frametype() const {
  return frametype_case() != FRAMETYPE_NOT_SET;
}
inline void ParentFrame::clear_has_frametype() {
  _oneof_case_[0] = FRAMETYPE_NOT_SET;
}
inline ParentFrame::FrametypeCase ParentFrame::frametype_case() const {
  return ParentFrame::FrametypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BaseState

// repeated string joint_names = 1;
inline int BaseState::_internal_joint_names_size() const {
  return joint_names_.size();
}
inline int BaseState::joint_names_size() const {
  return _internal_joint_names_size();
}
inline void BaseState::clear_joint_names() {
  joint_names_.Clear();
}
inline std::string* BaseState::add_joint_names() {
  // @@protoc_insertion_point(field_add_mutable:galbot.aphropm_proto.BaseState.joint_names)
  return _internal_add_joint_names();
}
inline const std::string& BaseState::_internal_joint_names(int index) const {
  return joint_names_.Get(index);
}
inline const std::string& BaseState::joint_names(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BaseState.joint_names)
  return _internal_joint_names(index);
}
inline std::string* BaseState::mutable_joint_names(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BaseState.joint_names)
  return joint_names_.Mutable(index);
}
inline void BaseState::set_joint_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.BaseState.joint_names)
  joint_names_.Mutable(index)->assign(value);
}
inline void BaseState::set_joint_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.BaseState.joint_names)
  joint_names_.Mutable(index)->assign(std::move(value));
}
inline void BaseState::set_joint_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  joint_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:galbot.aphropm_proto.BaseState.joint_names)
}
inline void BaseState::set_joint_names(int index, const char* value, size_t size) {
  joint_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:galbot.aphropm_proto.BaseState.joint_names)
}
inline std::string* BaseState::_internal_add_joint_names() {
  return joint_names_.Add();
}
inline void BaseState::add_joint_names(const std::string& value) {
  joint_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.BaseState.joint_names)
}
inline void BaseState::add_joint_names(std::string&& value) {
  joint_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.BaseState.joint_names)
}
inline void BaseState::add_joint_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  joint_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:galbot.aphropm_proto.BaseState.joint_names)
}
inline void BaseState::add_joint_names(const char* value, size_t size) {
  joint_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:galbot.aphropm_proto.BaseState.joint_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BaseState::joint_names() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.BaseState.joint_names)
  return joint_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BaseState::mutable_joint_names() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.BaseState.joint_names)
  return &joint_names_;
}

// .galbot.aphropm_proto.MapFrame map_frame = 2;
inline void BaseState::clear_map_frame() {
  map_frame_ = 0;
}
inline ::galbot::aphropm_proto::MapFrame BaseState::_internal_map_frame() const {
  return static_cast< ::galbot::aphropm_proto::MapFrame >(map_frame_);
}
inline ::galbot::aphropm_proto::MapFrame BaseState::map_frame() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BaseState.map_frame)
  return _internal_map_frame();
}
inline void BaseState::_internal_set_map_frame(::galbot::aphropm_proto::MapFrame value) {
  
  map_frame_ = value;
}
inline void BaseState::set_map_frame(::galbot::aphropm_proto::MapFrame value) {
  _internal_set_map_frame(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.BaseState.map_frame)
}

// .galbot.spatial_proto.Pose pose = 3;
inline bool BaseState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool BaseState::has_pose() const {
  return _internal_has_pose();
}
inline const ::galbot::spatial_proto::Pose& BaseState::_internal_pose() const {
  const ::galbot::spatial_proto::Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::spatial_proto::Pose&>(
      ::galbot::spatial_proto::_Pose_default_instance_);
}
inline const ::galbot::spatial_proto::Pose& BaseState::pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BaseState.pose)
  return _internal_pose();
}
inline void BaseState::unsafe_arena_set_allocated_pose(
    ::galbot::spatial_proto::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.BaseState.pose)
}
inline ::galbot::spatial_proto::Pose* BaseState::release_pose() {
  
  ::galbot::spatial_proto::Pose* temp = pose_;
  pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::spatial_proto::Pose* BaseState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.BaseState.pose)
  
  ::galbot::spatial_proto::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::galbot::spatial_proto::Pose* BaseState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::spatial_proto::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::galbot::spatial_proto::Pose* BaseState::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BaseState.pose)
  return _internal_mutable_pose();
}
inline void BaseState::set_allocated_pose(::galbot::spatial_proto::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose)->GetArena();
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.BaseState.pose)
}

// .galbot.spatial_proto.Twist twist = 4;
inline bool BaseState::_internal_has_twist() const {
  return this != internal_default_instance() && twist_ != nullptr;
}
inline bool BaseState::has_twist() const {
  return _internal_has_twist();
}
inline const ::galbot::spatial_proto::Twist& BaseState::_internal_twist() const {
  const ::galbot::spatial_proto::Twist* p = twist_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::spatial_proto::Twist&>(
      ::galbot::spatial_proto::_Twist_default_instance_);
}
inline const ::galbot::spatial_proto::Twist& BaseState::twist() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BaseState.twist)
  return _internal_twist();
}
inline void BaseState::unsafe_arena_set_allocated_twist(
    ::galbot::spatial_proto::Twist* twist) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(twist_);
  }
  twist_ = twist;
  if (twist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.BaseState.twist)
}
inline ::galbot::spatial_proto::Twist* BaseState::release_twist() {
  
  ::galbot::spatial_proto::Twist* temp = twist_;
  twist_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::spatial_proto::Twist* BaseState::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.BaseState.twist)
  
  ::galbot::spatial_proto::Twist* temp = twist_;
  twist_ = nullptr;
  return temp;
}
inline ::galbot::spatial_proto::Twist* BaseState::_internal_mutable_twist() {
  
  if (twist_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::spatial_proto::Twist>(GetArena());
    twist_ = p;
  }
  return twist_;
}
inline ::galbot::spatial_proto::Twist* BaseState::mutable_twist() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BaseState.twist)
  return _internal_mutable_twist();
}
inline void BaseState::set_allocated_twist(::galbot::spatial_proto::Twist* twist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(twist_);
  }
  if (twist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(twist)->GetArena();
    if (message_arena != submessage_arena) {
      twist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, twist, submessage_arena);
    }
    
  } else {
    
  }
  twist_ = twist;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.BaseState.twist)
}

// .galbot.spatial_proto.Twist acc = 5;
inline bool BaseState::_internal_has_acc() const {
  return this != internal_default_instance() && acc_ != nullptr;
}
inline bool BaseState::has_acc() const {
  return _internal_has_acc();
}
inline const ::galbot::spatial_proto::Twist& BaseState::_internal_acc() const {
  const ::galbot::spatial_proto::Twist* p = acc_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::spatial_proto::Twist&>(
      ::galbot::spatial_proto::_Twist_default_instance_);
}
inline const ::galbot::spatial_proto::Twist& BaseState::acc() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BaseState.acc)
  return _internal_acc();
}
inline void BaseState::unsafe_arena_set_allocated_acc(
    ::galbot::spatial_proto::Twist* acc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  acc_ = acc;
  if (acc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.BaseState.acc)
}
inline ::galbot::spatial_proto::Twist* BaseState::release_acc() {
  
  ::galbot::spatial_proto::Twist* temp = acc_;
  acc_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::spatial_proto::Twist* BaseState::unsafe_arena_release_acc() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.BaseState.acc)
  
  ::galbot::spatial_proto::Twist* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::galbot::spatial_proto::Twist* BaseState::_internal_mutable_acc() {
  
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::spatial_proto::Twist>(GetArena());
    acc_ = p;
  }
  return acc_;
}
inline ::galbot::spatial_proto::Twist* BaseState::mutable_acc() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BaseState.acc)
  return _internal_mutable_acc();
}
inline void BaseState::set_allocated_acc(::galbot::spatial_proto::Twist* acc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  if (acc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc)->GetArena();
    if (message_arena != submessage_arena) {
      acc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    
  } else {
    
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.BaseState.acc)
}

// -------------------------------------------------------------------

// JointState

// .galbot.core_proto.Vector positions = 1;
inline bool JointState::_internal_has_positions() const {
  return this != internal_default_instance() && positions_ != nullptr;
}
inline bool JointState::has_positions() const {
  return _internal_has_positions();
}
inline const ::galbot::core_proto::Vector& JointState::_internal_positions() const {
  const ::galbot::core_proto::Vector* p = positions_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::core_proto::Vector&>(
      ::galbot::core_proto::_Vector_default_instance_);
}
inline const ::galbot::core_proto::Vector& JointState::positions() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.JointState.positions)
  return _internal_positions();
}
inline void JointState::unsafe_arena_set_allocated_positions(
    ::galbot::core_proto::Vector* positions) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positions_);
  }
  positions_ = positions;
  if (positions) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.JointState.positions)
}
inline ::galbot::core_proto::Vector* JointState::release_positions() {
  
  ::galbot::core_proto::Vector* temp = positions_;
  positions_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::unsafe_arena_release_positions() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.JointState.positions)
  
  ::galbot::core_proto::Vector* temp = positions_;
  positions_ = nullptr;
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::_internal_mutable_positions() {
  
  if (positions_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::core_proto::Vector>(GetArena());
    positions_ = p;
  }
  return positions_;
}
inline ::galbot::core_proto::Vector* JointState::mutable_positions() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.JointState.positions)
  return _internal_mutable_positions();
}
inline void JointState::set_allocated_positions(::galbot::core_proto::Vector* positions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(positions_);
  }
  if (positions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(positions)->GetArena();
    if (message_arena != submessage_arena) {
      positions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, positions, submessage_arena);
    }
    
  } else {
    
  }
  positions_ = positions;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.JointState.positions)
}

// .galbot.core_proto.Vector velocities = 2;
inline bool JointState::_internal_has_velocities() const {
  return this != internal_default_instance() && velocities_ != nullptr;
}
inline bool JointState::has_velocities() const {
  return _internal_has_velocities();
}
inline const ::galbot::core_proto::Vector& JointState::_internal_velocities() const {
  const ::galbot::core_proto::Vector* p = velocities_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::core_proto::Vector&>(
      ::galbot::core_proto::_Vector_default_instance_);
}
inline const ::galbot::core_proto::Vector& JointState::velocities() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.JointState.velocities)
  return _internal_velocities();
}
inline void JointState::unsafe_arena_set_allocated_velocities(
    ::galbot::core_proto::Vector* velocities) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocities_);
  }
  velocities_ = velocities;
  if (velocities) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.JointState.velocities)
}
inline ::galbot::core_proto::Vector* JointState::release_velocities() {
  
  ::galbot::core_proto::Vector* temp = velocities_;
  velocities_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::unsafe_arena_release_velocities() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.JointState.velocities)
  
  ::galbot::core_proto::Vector* temp = velocities_;
  velocities_ = nullptr;
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::_internal_mutable_velocities() {
  
  if (velocities_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::core_proto::Vector>(GetArena());
    velocities_ = p;
  }
  return velocities_;
}
inline ::galbot::core_proto::Vector* JointState::mutable_velocities() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.JointState.velocities)
  return _internal_mutable_velocities();
}
inline void JointState::set_allocated_velocities(::galbot::core_proto::Vector* velocities) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocities_);
  }
  if (velocities) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocities)->GetArena();
    if (message_arena != submessage_arena) {
      velocities = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocities, submessage_arena);
    }
    
  } else {
    
  }
  velocities_ = velocities;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.JointState.velocities)
}

// .galbot.core_proto.Vector accelerations = 3;
inline bool JointState::_internal_has_accelerations() const {
  return this != internal_default_instance() && accelerations_ != nullptr;
}
inline bool JointState::has_accelerations() const {
  return _internal_has_accelerations();
}
inline const ::galbot::core_proto::Vector& JointState::_internal_accelerations() const {
  const ::galbot::core_proto::Vector* p = accelerations_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::core_proto::Vector&>(
      ::galbot::core_proto::_Vector_default_instance_);
}
inline const ::galbot::core_proto::Vector& JointState::accelerations() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.JointState.accelerations)
  return _internal_accelerations();
}
inline void JointState::unsafe_arena_set_allocated_accelerations(
    ::galbot::core_proto::Vector* accelerations) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accelerations_);
  }
  accelerations_ = accelerations;
  if (accelerations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.JointState.accelerations)
}
inline ::galbot::core_proto::Vector* JointState::release_accelerations() {
  
  ::galbot::core_proto::Vector* temp = accelerations_;
  accelerations_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::unsafe_arena_release_accelerations() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.JointState.accelerations)
  
  ::galbot::core_proto::Vector* temp = accelerations_;
  accelerations_ = nullptr;
  return temp;
}
inline ::galbot::core_proto::Vector* JointState::_internal_mutable_accelerations() {
  
  if (accelerations_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::core_proto::Vector>(GetArena());
    accelerations_ = p;
  }
  return accelerations_;
}
inline ::galbot::core_proto::Vector* JointState::mutable_accelerations() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.JointState.accelerations)
  return _internal_mutable_accelerations();
}
inline void JointState::set_allocated_accelerations(::galbot::core_proto::Vector* accelerations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(accelerations_);
  }
  if (accelerations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accelerations)->GetArena();
    if (message_arena != submessage_arena) {
      accelerations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerations, submessage_arena);
    }
    
  } else {
    
  }
  accelerations_ = accelerations;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.JointState.accelerations)
}

// -------------------------------------------------------------------

// PoseState

// .galbot.spatial_proto.Pose pose = 1;
inline bool PoseState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool PoseState::has_pose() const {
  return _internal_has_pose();
}
inline const ::galbot::spatial_proto::Pose& PoseState::_internal_pose() const {
  const ::galbot::spatial_proto::Pose* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::spatial_proto::Pose&>(
      ::galbot::spatial_proto::_Pose_default_instance_);
}
inline const ::galbot::spatial_proto::Pose& PoseState::pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseState.pose)
  return _internal_pose();
}
inline void PoseState::unsafe_arena_set_allocated_pose(
    ::galbot::spatial_proto::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PoseState.pose)
}
inline ::galbot::spatial_proto::Pose* PoseState::release_pose() {
  
  ::galbot::spatial_proto::Pose* temp = pose_;
  pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::spatial_proto::Pose* PoseState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PoseState.pose)
  
  ::galbot::spatial_proto::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::galbot::spatial_proto::Pose* PoseState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::spatial_proto::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::galbot::spatial_proto::Pose* PoseState::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PoseState.pose)
  return _internal_mutable_pose();
}
inline void PoseState::set_allocated_pose(::galbot::spatial_proto::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose)->GetArena();
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PoseState.pose)
}

// .galbot.aphropm_proto.ParentFrame parent_frame = 2;
inline bool PoseState::_internal_has_parent_frame() const {
  return this != internal_default_instance() && parent_frame_ != nullptr;
}
inline bool PoseState::has_parent_frame() const {
  return _internal_has_parent_frame();
}
inline void PoseState::clear_parent_frame() {
  if (GetArena() == nullptr && parent_frame_ != nullptr) {
    delete parent_frame_;
  }
  parent_frame_ = nullptr;
}
inline const ::galbot::aphropm_proto::ParentFrame& PoseState::_internal_parent_frame() const {
  const ::galbot::aphropm_proto::ParentFrame* p = parent_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::ParentFrame&>(
      ::galbot::aphropm_proto::_ParentFrame_default_instance_);
}
inline const ::galbot::aphropm_proto::ParentFrame& PoseState::parent_frame() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseState.parent_frame)
  return _internal_parent_frame();
}
inline void PoseState::unsafe_arena_set_allocated_parent_frame(
    ::galbot::aphropm_proto::ParentFrame* parent_frame) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_frame_);
  }
  parent_frame_ = parent_frame;
  if (parent_frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.PoseState.parent_frame)
}
inline ::galbot::aphropm_proto::ParentFrame* PoseState::release_parent_frame() {
  
  ::galbot::aphropm_proto::ParentFrame* temp = parent_frame_;
  parent_frame_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::ParentFrame* PoseState::unsafe_arena_release_parent_frame() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.PoseState.parent_frame)
  
  ::galbot::aphropm_proto::ParentFrame* temp = parent_frame_;
  parent_frame_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::ParentFrame* PoseState::_internal_mutable_parent_frame() {
  
  if (parent_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::ParentFrame>(GetArena());
    parent_frame_ = p;
  }
  return parent_frame_;
}
inline ::galbot::aphropm_proto::ParentFrame* PoseState::mutable_parent_frame() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.PoseState.parent_frame)
  return _internal_mutable_parent_frame();
}
inline void PoseState::set_allocated_parent_frame(::galbot::aphropm_proto::ParentFrame* parent_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parent_frame_;
  }
  if (parent_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parent_frame);
    if (message_arena != submessage_arena) {
      parent_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_frame, submessage_arena);
    }
    
  } else {
    
  }
  parent_frame_ = parent_frame;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.PoseState.parent_frame)
}

// bool is_relative = 4;
inline void PoseState::clear_is_relative() {
  is_relative_ = false;
}
inline bool PoseState::_internal_is_relative() const {
  return is_relative_;
}
inline bool PoseState::is_relative() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseState.is_relative)
  return _internal_is_relative();
}
inline void PoseState::_internal_set_is_relative(bool value) {
  
  is_relative_ = value;
}
inline void PoseState::set_is_relative(bool value) {
  _internal_set_is_relative(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PoseState.is_relative)
}

// bool is_tool_pose = 5;
inline void PoseState::clear_is_tool_pose() {
  is_tool_pose_ = false;
}
inline bool PoseState::_internal_is_tool_pose() const {
  return is_tool_pose_;
}
inline bool PoseState::is_tool_pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.PoseState.is_tool_pose)
  return _internal_is_tool_pose();
}
inline void PoseState::_internal_set_is_tool_pose(bool value) {
  
  is_tool_pose_ = value;
}
inline void PoseState::set_is_tool_pose(bool value) {
  _internal_set_is_tool_pose(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.PoseState.is_tool_pose)
}

// -------------------------------------------------------------------

// BodyState

// .galbot.aphropm_proto.BodyState.BodyStateType type = 1;
inline void BodyState::clear_type() {
  type_ = 0;
}
inline ::galbot::aphropm_proto::BodyState_BodyStateType BodyState::_internal_type() const {
  return static_cast< ::galbot::aphropm_proto::BodyState_BodyStateType >(type_);
}
inline ::galbot::aphropm_proto::BodyState_BodyStateType BodyState::type() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BodyState.type)
  return _internal_type();
}
inline void BodyState::_internal_set_type(::galbot::aphropm_proto::BodyState_BodyStateType value) {
  
  type_ = value;
}
inline void BodyState::set_type(::galbot::aphropm_proto::BodyState_BodyStateType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.BodyState.type)
}

// .galbot.aphropm_proto.JointState joint = 2;
inline bool BodyState::_internal_has_joint() const {
  return this != internal_default_instance() && joint_ != nullptr;
}
inline bool BodyState::has_joint() const {
  return _internal_has_joint();
}
inline void BodyState::clear_joint() {
  if (GetArena() == nullptr && joint_ != nullptr) {
    delete joint_;
  }
  joint_ = nullptr;
}
inline const ::galbot::aphropm_proto::JointState& BodyState::_internal_joint() const {
  const ::galbot::aphropm_proto::JointState* p = joint_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::JointState&>(
      ::galbot::aphropm_proto::_JointState_default_instance_);
}
inline const ::galbot::aphropm_proto::JointState& BodyState::joint() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BodyState.joint)
  return _internal_joint();
}
inline void BodyState::unsafe_arena_set_allocated_joint(
    ::galbot::aphropm_proto::JointState* joint) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joint_);
  }
  joint_ = joint;
  if (joint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.BodyState.joint)
}
inline ::galbot::aphropm_proto::JointState* BodyState::release_joint() {
  
  ::galbot::aphropm_proto::JointState* temp = joint_;
  joint_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::JointState* BodyState::unsafe_arena_release_joint() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.BodyState.joint)
  
  ::galbot::aphropm_proto::JointState* temp = joint_;
  joint_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::JointState* BodyState::_internal_mutable_joint() {
  
  if (joint_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::JointState>(GetArena());
    joint_ = p;
  }
  return joint_;
}
inline ::galbot::aphropm_proto::JointState* BodyState::mutable_joint() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BodyState.joint)
  return _internal_mutable_joint();
}
inline void BodyState::set_allocated_joint(::galbot::aphropm_proto::JointState* joint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joint_;
  }
  if (joint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joint);
    if (message_arena != submessage_arena) {
      joint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint, submessage_arena);
    }
    
  } else {
    
  }
  joint_ = joint;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.BodyState.joint)
}

// .galbot.aphropm_proto.PoseState pose = 3;
inline bool BodyState::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool BodyState::has_pose() const {
  return _internal_has_pose();
}
inline void BodyState::clear_pose() {
  if (GetArena() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::galbot::aphropm_proto::PoseState& BodyState::_internal_pose() const {
  const ::galbot::aphropm_proto::PoseState* p = pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::PoseState&>(
      ::galbot::aphropm_proto::_PoseState_default_instance_);
}
inline const ::galbot::aphropm_proto::PoseState& BodyState::pose() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.BodyState.pose)
  return _internal_pose();
}
inline void BodyState::unsafe_arena_set_allocated_pose(
    ::galbot::aphropm_proto::PoseState* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.BodyState.pose)
}
inline ::galbot::aphropm_proto::PoseState* BodyState::release_pose() {
  
  ::galbot::aphropm_proto::PoseState* temp = pose_;
  pose_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::PoseState* BodyState::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.BodyState.pose)
  
  ::galbot::aphropm_proto::PoseState* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::PoseState* BodyState::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::PoseState>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::galbot::aphropm_proto::PoseState* BodyState::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.BodyState.pose)
  return _internal_mutable_pose();
}
inline void BodyState::set_allocated_pose(::galbot::aphropm_proto::PoseState* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.BodyState.pose)
}

// -------------------------------------------------------------------

// RobotStates

// .galbot.aphropm_proto.BaseState base = 1;
inline bool RobotStates::_internal_has_base() const {
  return this != internal_default_instance() && base_ != nullptr;
}
inline bool RobotStates::has_base() const {
  return _internal_has_base();
}
inline void RobotStates::clear_base() {
  if (GetArena() == nullptr && base_ != nullptr) {
    delete base_;
  }
  base_ = nullptr;
}
inline const ::galbot::aphropm_proto::BaseState& RobotStates::_internal_base() const {
  const ::galbot::aphropm_proto::BaseState* p = base_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::BaseState&>(
      ::galbot::aphropm_proto::_BaseState_default_instance_);
}
inline const ::galbot::aphropm_proto::BaseState& RobotStates::base() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotStates.base)
  return _internal_base();
}
inline void RobotStates::unsafe_arena_set_allocated_base(
    ::galbot::aphropm_proto::BaseState* base) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.RobotStates.base)
}
inline ::galbot::aphropm_proto::BaseState* RobotStates::release_base() {
  
  ::galbot::aphropm_proto::BaseState* temp = base_;
  base_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::BaseState* RobotStates::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.RobotStates.base)
  
  ::galbot::aphropm_proto::BaseState* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::BaseState* RobotStates::_internal_mutable_base() {
  
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::BaseState>(GetArena());
    base_ = p;
  }
  return base_;
}
inline ::galbot::aphropm_proto::BaseState* RobotStates::mutable_base() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotStates.base)
  return _internal_mutable_base();
}
inline void RobotStates::set_allocated_base(::galbot::aphropm_proto::BaseState* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.RobotStates.base)
}

// .galbot.aphropm_proto.BodyState body = 2;
inline bool RobotStates::_internal_has_body() const {
  return this != internal_default_instance() && body_ != nullptr;
}
inline bool RobotStates::has_body() const {
  return _internal_has_body();
}
inline void RobotStates::clear_body() {
  if (GetArena() == nullptr && body_ != nullptr) {
    delete body_;
  }
  body_ = nullptr;
}
inline const ::galbot::aphropm_proto::BodyState& RobotStates::_internal_body() const {
  const ::galbot::aphropm_proto::BodyState* p = body_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::BodyState&>(
      ::galbot::aphropm_proto::_BodyState_default_instance_);
}
inline const ::galbot::aphropm_proto::BodyState& RobotStates::body() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotStates.body)
  return _internal_body();
}
inline void RobotStates::unsafe_arena_set_allocated_body(
    ::galbot::aphropm_proto::BodyState* body) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_);
  }
  body_ = body;
  if (body) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.RobotStates.body)
}
inline ::galbot::aphropm_proto::BodyState* RobotStates::release_body() {
  
  ::galbot::aphropm_proto::BodyState* temp = body_;
  body_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::BodyState* RobotStates::unsafe_arena_release_body() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.RobotStates.body)
  
  ::galbot::aphropm_proto::BodyState* temp = body_;
  body_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::BodyState* RobotStates::_internal_mutable_body() {
  
  if (body_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::BodyState>(GetArena());
    body_ = p;
  }
  return body_;
}
inline ::galbot::aphropm_proto::BodyState* RobotStates::mutable_body() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotStates.body)
  return _internal_mutable_body();
}
inline void RobotStates::set_allocated_body(::galbot::aphropm_proto::BodyState* body) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete body_;
  }
  if (body) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(body);
    if (message_arena != submessage_arena) {
      body = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.RobotStates.body)
}

// -------------------------------------------------------------------

// ChainState

// .galbot.aphropm_proto.ChainType chain = 1;
inline void ChainState::clear_chain() {
  chain_ = 0;
}
inline ::galbot::aphropm_proto::ChainType ChainState::_internal_chain() const {
  return static_cast< ::galbot::aphropm_proto::ChainType >(chain_);
}
inline ::galbot::aphropm_proto::ChainType ChainState::chain() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ChainState.chain)
  return _internal_chain();
}
inline void ChainState::_internal_set_chain(::galbot::aphropm_proto::ChainType value) {
  
  chain_ = value;
}
inline void ChainState::set_chain(::galbot::aphropm_proto::ChainType value) {
  _internal_set_chain(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.ChainState.chain)
}

// .galbot.aphropm_proto.RobotStates chain_state = 2;
inline bool ChainState::_internal_has_chain_state() const {
  return this != internal_default_instance() && chain_state_ != nullptr;
}
inline bool ChainState::has_chain_state() const {
  return _internal_has_chain_state();
}
inline void ChainState::clear_chain_state() {
  if (GetArena() == nullptr && chain_state_ != nullptr) {
    delete chain_state_;
  }
  chain_state_ = nullptr;
}
inline const ::galbot::aphropm_proto::RobotStates& ChainState::_internal_chain_state() const {
  const ::galbot::aphropm_proto::RobotStates* p = chain_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::galbot::aphropm_proto::RobotStates&>(
      ::galbot::aphropm_proto::_RobotStates_default_instance_);
}
inline const ::galbot::aphropm_proto::RobotStates& ChainState::chain_state() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.ChainState.chain_state)
  return _internal_chain_state();
}
inline void ChainState::unsafe_arena_set_allocated_chain_state(
    ::galbot::aphropm_proto::RobotStates* chain_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chain_state_);
  }
  chain_state_ = chain_state;
  if (chain_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:galbot.aphropm_proto.ChainState.chain_state)
}
inline ::galbot::aphropm_proto::RobotStates* ChainState::release_chain_state() {
  
  ::galbot::aphropm_proto::RobotStates* temp = chain_state_;
  chain_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* ChainState::unsafe_arena_release_chain_state() {
  // @@protoc_insertion_point(field_release:galbot.aphropm_proto.ChainState.chain_state)
  
  ::galbot::aphropm_proto::RobotStates* temp = chain_state_;
  chain_state_ = nullptr;
  return temp;
}
inline ::galbot::aphropm_proto::RobotStates* ChainState::_internal_mutable_chain_state() {
  
  if (chain_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::galbot::aphropm_proto::RobotStates>(GetArena());
    chain_state_ = p;
  }
  return chain_state_;
}
inline ::galbot::aphropm_proto::RobotStates* ChainState::mutable_chain_state() {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.ChainState.chain_state)
  return _internal_mutable_chain_state();
}
inline void ChainState::set_allocated_chain_state(::galbot::aphropm_proto::RobotStates* chain_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete chain_state_;
  }
  if (chain_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(chain_state);
    if (message_arena != submessage_arena) {
      chain_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chain_state, submessage_arena);
    }
    
  } else {
    
  }
  chain_state_ = chain_state;
  // @@protoc_insertion_point(field_set_allocated:galbot.aphropm_proto.ChainState.chain_state)
}

// -------------------------------------------------------------------

// RobotTrajectory

// .galbot.aphropm_proto.ChainType chain = 1;
inline void RobotTrajectory::clear_chain() {
  chain_ = 0;
}
inline ::galbot::aphropm_proto::ChainType RobotTrajectory::_internal_chain() const {
  return static_cast< ::galbot::aphropm_proto::ChainType >(chain_);
}
inline ::galbot::aphropm_proto::ChainType RobotTrajectory::chain() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.chain)
  return _internal_chain();
}
inline void RobotTrajectory::_internal_set_chain(::galbot::aphropm_proto::ChainType value) {
  
  chain_ = value;
}
inline void RobotTrajectory::set_chain(::galbot::aphropm_proto::ChainType value) {
  _internal_set_chain(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.RobotTrajectory.chain)
}

// repeated .galbot.aphropm_proto.JointState joints = 2;
inline int RobotTrajectory::_internal_joints_size() const {
  return joints_.size();
}
inline int RobotTrajectory::joints_size() const {
  return _internal_joints_size();
}
inline void RobotTrajectory::clear_joints() {
  joints_.Clear();
}
inline ::galbot::aphropm_proto::JointState* RobotTrajectory::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotTrajectory.joints)
  return joints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::JointState >*
RobotTrajectory::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.RobotTrajectory.joints)
  return &joints_;
}
inline const ::galbot::aphropm_proto::JointState& RobotTrajectory::_internal_joints(int index) const {
  return joints_.Get(index);
}
inline const ::galbot::aphropm_proto::JointState& RobotTrajectory::joints(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.joints)
  return _internal_joints(index);
}
inline ::galbot::aphropm_proto::JointState* RobotTrajectory::_internal_add_joints() {
  return joints_.Add();
}
inline ::galbot::aphropm_proto::JointState* RobotTrajectory::add_joints() {
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.RobotTrajectory.joints)
  return _internal_add_joints();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::JointState >&
RobotTrajectory::joints() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.RobotTrajectory.joints)
  return joints_;
}

// repeated .galbot.aphropm_proto.PoseState poses = 3;
inline int RobotTrajectory::_internal_poses_size() const {
  return poses_.size();
}
inline int RobotTrajectory::poses_size() const {
  return _internal_poses_size();
}
inline void RobotTrajectory::clear_poses() {
  poses_.Clear();
}
inline ::galbot::aphropm_proto::PoseState* RobotTrajectory::mutable_poses(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotTrajectory.poses)
  return poses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::PoseState >*
RobotTrajectory::mutable_poses() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.RobotTrajectory.poses)
  return &poses_;
}
inline const ::galbot::aphropm_proto::PoseState& RobotTrajectory::_internal_poses(int index) const {
  return poses_.Get(index);
}
inline const ::galbot::aphropm_proto::PoseState& RobotTrajectory::poses(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.poses)
  return _internal_poses(index);
}
inline ::galbot::aphropm_proto::PoseState* RobotTrajectory::_internal_add_poses() {
  return poses_.Add();
}
inline ::galbot::aphropm_proto::PoseState* RobotTrajectory::add_poses() {
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.RobotTrajectory.poses)
  return _internal_add_poses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::PoseState >&
RobotTrajectory::poses() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.RobotTrajectory.poses)
  return poses_;
}

// repeated .galbot.aphropm_proto.BaseState base_traj = 4;
inline int RobotTrajectory::_internal_base_traj_size() const {
  return base_traj_.size();
}
inline int RobotTrajectory::base_traj_size() const {
  return _internal_base_traj_size();
}
inline void RobotTrajectory::clear_base_traj() {
  base_traj_.Clear();
}
inline ::galbot::aphropm_proto::BaseState* RobotTrajectory::mutable_base_traj(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotTrajectory.base_traj)
  return base_traj_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::BaseState >*
RobotTrajectory::mutable_base_traj() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.RobotTrajectory.base_traj)
  return &base_traj_;
}
inline const ::galbot::aphropm_proto::BaseState& RobotTrajectory::_internal_base_traj(int index) const {
  return base_traj_.Get(index);
}
inline const ::galbot::aphropm_proto::BaseState& RobotTrajectory::base_traj(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.base_traj)
  return _internal_base_traj(index);
}
inline ::galbot::aphropm_proto::BaseState* RobotTrajectory::_internal_add_base_traj() {
  return base_traj_.Add();
}
inline ::galbot::aphropm_proto::BaseState* RobotTrajectory::add_base_traj() {
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.RobotTrajectory.base_traj)
  return _internal_add_base_traj();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::BaseState >&
RobotTrajectory::base_traj() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.RobotTrajectory.base_traj)
  return base_traj_;
}

// repeated double times = 5;
inline int RobotTrajectory::_internal_times_size() const {
  return times_.size();
}
inline int RobotTrajectory::times_size() const {
  return _internal_times_size();
}
inline void RobotTrajectory::clear_times() {
  times_.Clear();
}
inline double RobotTrajectory::_internal_times(int index) const {
  return times_.Get(index);
}
inline double RobotTrajectory::times(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.times)
  return _internal_times(index);
}
inline void RobotTrajectory::set_times(int index, double value) {
  times_.Set(index, value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.RobotTrajectory.times)
}
inline void RobotTrajectory::_internal_add_times(double value) {
  times_.Add(value);
}
inline void RobotTrajectory::add_times(double value) {
  _internal_add_times(value);
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.RobotTrajectory.times)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RobotTrajectory::_internal_times() const {
  return times_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RobotTrajectory::times() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.RobotTrajectory.times)
  return _internal_times();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RobotTrajectory::_internal_mutable_times() {
  return &times_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RobotTrajectory::mutable_times() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.RobotTrajectory.times)
  return _internal_mutable_times();
}

// int64 start_time = 6;
inline void RobotTrajectory::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotTrajectory::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotTrajectory::start_time() const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectory.start_time)
  return _internal_start_time();
}
inline void RobotTrajectory::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_time_ = value;
}
inline void RobotTrajectory::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:galbot.aphropm_proto.RobotTrajectory.start_time)
}

// -------------------------------------------------------------------

// RobotTrajectoryVec

// repeated .galbot.aphropm_proto.RobotTrajectory trajectories = 1;
inline int RobotTrajectoryVec::_internal_trajectories_size() const {
  return trajectories_.size();
}
inline int RobotTrajectoryVec::trajectories_size() const {
  return _internal_trajectories_size();
}
inline void RobotTrajectoryVec::clear_trajectories() {
  trajectories_.Clear();
}
inline ::galbot::aphropm_proto::RobotTrajectory* RobotTrajectoryVec::mutable_trajectories(int index) {
  // @@protoc_insertion_point(field_mutable:galbot.aphropm_proto.RobotTrajectoryVec.trajectories)
  return trajectories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::RobotTrajectory >*
RobotTrajectoryVec::mutable_trajectories() {
  // @@protoc_insertion_point(field_mutable_list:galbot.aphropm_proto.RobotTrajectoryVec.trajectories)
  return &trajectories_;
}
inline const ::galbot::aphropm_proto::RobotTrajectory& RobotTrajectoryVec::_internal_trajectories(int index) const {
  return trajectories_.Get(index);
}
inline const ::galbot::aphropm_proto::RobotTrajectory& RobotTrajectoryVec::trajectories(int index) const {
  // @@protoc_insertion_point(field_get:galbot.aphropm_proto.RobotTrajectoryVec.trajectories)
  return _internal_trajectories(index);
}
inline ::galbot::aphropm_proto::RobotTrajectory* RobotTrajectoryVec::_internal_add_trajectories() {
  return trajectories_.Add();
}
inline ::galbot::aphropm_proto::RobotTrajectory* RobotTrajectoryVec::add_trajectories() {
  // @@protoc_insertion_point(field_add:galbot.aphropm_proto.RobotTrajectoryVec.trajectories)
  return _internal_add_trajectories();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::galbot::aphropm_proto::RobotTrajectory >&
RobotTrajectoryVec::trajectories() const {
  // @@protoc_insertion_point(field_list:galbot.aphropm_proto.RobotTrajectoryVec.trajectories)
  return trajectories_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace aphropm_proto
}  // namespace galbot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::galbot::aphropm_proto::ChainFrame_FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::ChainFrame_FrameType>() {
  return ::galbot::aphropm_proto::ChainFrame_FrameType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::BodyState_BodyStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::BodyState_BodyStateType>() {
  return ::galbot::aphropm_proto::BodyState_BodyStateType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::ChainType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::ChainType>() {
  return ::galbot::aphropm_proto::ChainType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::ActuateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::ActuateType>() {
  return ::galbot::aphropm_proto::ActuateType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::CameraType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::CameraType>() {
  return ::galbot::aphropm_proto::CameraType_descriptor();
}
template <> struct is_proto_enum< ::galbot::aphropm_proto::MapFrame> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::galbot::aphropm_proto::MapFrame>() {
  return ::galbot::aphropm_proto::MapFrame_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_galbot_2faphropm_5fproto_2fcommon_5fdef_2eproto
